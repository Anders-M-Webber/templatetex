\documentclass{book}
%\makeatletter\@addtoreset{chapter}{part}\makeatother
\usepackage{diagbox}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{graphicx}
\usepackage{CJKutf8} %support Chinese Character
\usepackage{color}
\usepackage{booktabs}
\usepackage{floatrow}
\usepackage{caption}
%to show these emojis/happy faces...
\usepackage{tikzsymbols}
\usepackage{textcomp}
\usepackage{parskip}
% to add code in text
\usepackage{filecontents}
% to format inserted source code, i.e, c/c++, java
\usepackage{listings}
\usepackage{color}
% to use color in verbatim env
\usepackage{fancyvrb}
\usepackage{xcolor}
% to use more logos
\usepackage{bclogo}
% to use hand icons
%\usepackage{bbding}
% to avoid the confliction between two packages
\usepackage{savesym}
\savesymbol{checkmark}
\usepackage{dingbat}
%\usepackage{fontawesome}  % black-white info icons
%\usepackage{marvosym} %Black-white info icons
%to setup font size for picture caption: large  small  footnotesize scriptsize
\captionsetup{font={scriptsize}}
\usepackage{hyperref}
%subpart--->
\usepackage[newparttoc]{titlesec}
\usepackage{titletoc}
%for Chinese characters, compilation error!!!
%\usepackage[UTF8]{ctex}
% setting for the package "listings"
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\setlength{\parindent}{2em} % indentation at the first line of a paragraph
%\setlength{\parskip}{1em} % distance between paragraphs
%\renewcommand{\baselinestretch}{1.0}// distance between lines
\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
% for setting of Verbatim, or it won't work!!!
%\fvset{frame=single,framesep=1mm,fontfamily=courier,fontsize=\scriptsize,numbers=left,framerule=.3mm,numbersep=1mm,commandchars=\\\{\}}
\fvset{fontfamily=courier,fontsize=\scriptsize,framerule=.3mm,numbersep=1mm,commandchars=\\\{\}}

%subpart--->
\titleformat{\part}[display]{\normalfont\Huge\bfseries}%
{\partname~\thepart}{1pc}{\Huge\bfseries}
\titleclass{\subpart}{page}[\part]
\newcounter{subpart}
\renewcommand{\thesubpart}{\Alph{subpart}}
\newcommand{\subpartname}{Subpart}
\titleformat{\subpart}[display]{\normalfont\Large\bfseries}%
{\subpartname~\thesubpart}{1pc}{\Huge\bfseries}
\titlespacing{\subpart}{0pt}{0pt}{0pt}
\titlecontents{subpart}[0pt]{\addvspace{1pc}\normalfont\bfseries}%
{\thecontentslabel\enspace ---\enspace\large}%
{\normalfont\large\bfseries}{\hspace{2em plus 1fill}\large\contentspage}
%subpart<---
%===========main()
\begin{document}

%-----------title()
\title{Design patterns and software Architecures}
\author{ERL SW}
\date{\today}
\maketitle


\tableofcontents
%----------abstract()
%\begin{abstract}
%This document is intended to depict classic Design patterns and software Architecures.
%This docment is a collection of most of patterns and relevant concepts. 
%\end{abstract}
%\begin{CJK}{UTF8}{gbsn}
%你好
%\end{CJK}
\part{Basis}
%\chapter{Preliminary}
%After you finish flashing these ``*.src'' files, you may continue.% \Laughey[][green!60!white!] \\
%\bcinfo{are used.}
%\bclogo[logo=\bcinfo, noborder=true, couleurBarre=Red, couleurBord=Black, couleur=orange!10, arrondi = 0.2, epBarre=3.5]{hellow}
%\begin{bclogo}[logo=\bcinfo, noborder=true]
%\faInfoCircle{ Before flashing system images, all ``*.src'' files need to be flashed. }
%\Info{ Before flashing system images, all ``*.src'' files need to be flashed. }
%\bclampe{Before flashing system images, all ``*.src'' files need to be flashed. Refer to Chapter.3 in ``RENESAS\_RCH3M3\_Android\_O\_ReleaseNote\_2017\_7B.pdf'' for details. }
%\end{bclogo}
\chapter{Multiple Dispatch}\label{md}
\section{Double Dispatch}\label{dd}
\paragraph{What is Double Dispatch?}
Technically, Double Dispatch refers to a technique used in the context of a polymorphic method call for mitigating the lack of multimethod support in programming languages.
More simply, Double Dispatch is used to \textcolor{red}{invoke an overloaded method} where the parameters vary \textcolor{red}{among an inheritance hierarchy}.
To explain fully, let’s start with a review of polymorphism.
 
$\bullet$ Polymorphism (Function overriding)

$\bullet$Method (Function) Overloading, also called compile-time or static polymorphism

%\paragraph{double dispatch: Example 1}
%https://en.wikipedia.org/wiki/Double_dispatch#Double_dispatch_in_C++
At first glance, double dispatch appears to be a natural result of function overloading. 
Function overloading allows the function called to depend on \textbf{the type of the argument}.
Function overloading, however, is done at \textcolor{red}{compile time} using ``name mangling'' where the internal name of the function encodes the argument's type.
For example, a function ``foo(int)'' may internally be called ``\_\_foo\_i'' and the function ``foo(double)'' may be called ``\_\_foo\_d''. 
Thus, there is no name collision, and no virtual table lookup. 

By contrast, \colorbox{gray!30}{dynamic dispatch} is based on \textbf{the type of the calling object}, meaning it uses virtual functions (overriding) instead of function overloading, and does result in a vtable lookup.

{Consider the following example written in C++, of collisions in a game}

%{\color{blue}
\begin{lstlisting}[caption={sample - collisions in a game}, language=C++]
class SpaceShip {};
class ApolloSpacecraft : public SpaceShip {};

class Asteroid 
{
  public:
      virtual void CollideWith(SpaceShip&) {cout << "Asteroid hit a SpaceShip\n"; }
      virtual void CollideWith(ApolloSpacecraft&) //overloading
            {cout<<"Asteroid hit an ApolloSpacecraft\n";}
};

class ExplodingAsteroid : public Asteroid {
  public:
     virtual void CollideWith(SpaceShip&) {cout<<"ExplodingAsteroid hit a SpaceShip\n";}
     virtual void CollideWith(ApolloSpacecraft&)  //overloading
            {cout<<"ExplodingAsteroid hit an ApolloSpacecraft\n";}
};
\end{lstlisting}%}
If you have:
{\color{blue}\begin{verbatim}
Asteroid theAsteroid;
SpaceShip theSpaceShip;
ApolloSpacecraft theApolloSpacecraft;
\end{verbatim}}
then, because of \textcolor{red}{function overloading} in class ``Asteroid'',
\begin{verbatim}
theAsteroid.CollideWith(theSpaceShip); 
theAsteroid.CollideWith(theApolloSpacecraft);
\end{verbatim}
will print, respectively, without using any dynamic dispatch.
{\color{gray}\begin{verbatim}
Asteroid hit a SpaceShip 
Asteroid hit an ApolloSpacecraft
\end{verbatim}}

$\bullet$Furthermore:
%{\color{blue}
\begin{lstlisting}
ExplodingAsteroid theExplodingAsteroid;
theExplodingAsteroid.CollideWith(theSpaceShip); 
theExplodingAsteroid.CollideWith(theApolloSpacecraft);
\end{lstlisting}%}
will print, respectively, again without dynamic dispatch.
{\color{gray}\begin{verbatim}
ExplodingAsteroid hit a SpaceShip 
ExplodingAsteroid hit an ApolloSpacecraft
\end{verbatim}}

$\bullet$ With a reference (or pointer) to an Asteroid, dynamic dispatch is used, and this code:

%{\color{blue}
\begin{lstlisting}
Asteroid& theAsteroidReference = theExplodingAsteroid;
theAsteroidReference.CollideWith(theSpaceShip);//argument is an object 
theAsteroidReference.CollideWith(theApolloSpacecraft);//argument is an object
\end{lstlisting}%}
prints 
{\color{gray}\begin{verbatim}
ExplodingAsteroid hit a SpaceShip 
ExplodingAsteroid hit an ApolloSpacecraft
\end{verbatim}}
again as expected.

$\bullet$ However, the following code does not work as desired:
%{\color{blue}
\begin{lstlisting}
Asteroid& theAsteroidReference = theExplodingAsteroid;
SpaceShip& theSpaceShipReference = theApolloSpacecraft;
theAsteroid.CollideWith(theSpaceShipReference);//argument is a reference
theAsteroidReference.CollideWith(theSpaceShipReference);//argument is a reference
\end{lstlisting}%}
The desired behaviour is to bind these calls to the function that takes theApolloSpacecraft as its argument, 
as that is the instantiated type of the variable, meaning the expected output would be 
{\color{green}\begin{verbatim}
Asteroid hit an ApolloSpacecraft 
ExplodingAsteroid hit an ApolloSpacecraft
\end{verbatim}}
However, the output is actually 
{\color{red}\begin{verbatim}
Asteroid hit a SpaceShip 
ExplodingAsteroid hit a SpaceShip
\end{verbatim}}
The problem is that, while virtual functions are dispatched (\textcolor{red}{so-called first dispatch}) dynamically in C++, function overloading is done statically
so that (\textcolor{red}{second dispatch} cannot be done.

The problem described above can be resolved by simulating double dispatch, 
for example by using a visitor pattern~\ref{VisitorPattern}. Suppose the existing code is extended so that both SpaceShip and ApolloSpacecraft are given the function, see complete code~\ref{ddcc}.
%{\color{purple}
\begin{lstlisting}
virtual void CollideWith(Asteroid& inAsteroid) { inAsteroid.CollideWith(*this); }
\end{lstlisting}%}
Then, while the previous example still does not work correctly, reframing the calls so that the spaceship is the agent gives us the desired behaviour:
%{\color{blue}
\begin{lstlisting}
Asteroid& theAsteroidReference = theExplodingAsteroid;
SpaceShip& theSpaceShipReference = theApolloSpacecraft;
theSpaceShipReference.CollideWith(theAsteroid);
theSpaceShipReference.CollideWith(theAsteroidReference);
\end{lstlisting}%}
It prints out 
{\color{gray}\begin{verbatim}
Asteroid hit an ApolloSpacecraft 
ExplodingAsteroid hit an ApolloSpacecraft
\end{verbatim}}
as expected. 

\textbf{The key} is that ``theSpaceShipReference.CollideWith(theAsteroidReference);'' does the following at run time:

1. ``theSpaceShipReference'' is a reference, so C++ looks up the correct method in the vtable. In this case, it will call ``ApolloSpacecraft::CollideWith(Asteroid\&)'', this is the first Dispatch.

2. Within ``ApolloSpacecraft::CollideWith(Asteroid\&)'', ``inAsteroid'' is a reference, so ``inAsteroid.CollideWith(*this)'' will result in another vtable lookup, this is the second Dispatch.

In this case, ``inAsteroid'' is a reference to an ``ExplodingAsteroid'',
so 
\begin{verbatim}
ExplodingAsteroid::CollideWith(ApolloSpacecraft&)
\end{verbatim}
will be called.

\begin{lstlisting}[caption={Double Dispatch sample code 1 - complete code},label={ddcc},language=C++]
#include <iostream>

class ApolloSapceCraft;
class SpaceShip;

class Asteroid {// i.e., Visitor
  public:
      virtual void CollideWith(SpaceShip&)  {    std::cout<<"Asteroid hit a SpaceShip!"<<std::endl;  }
      virtual void CollideWith(ApolloSapceCraft&)  {    std::cout<<"Asteroid hit a ApolloSapceCraft!"<<std::endl;  }
};

class SpaceShip// i.e., Element
{
  public:
    virtual void CollideWith(Asteroid& inasteroid) { inasteroid.CollideWith(*this); }
};

class ApolloSapceCraft: public SpaceShip{// i.e., concrete element
  public:
    virtual void CollideWith(Asteroid& inasteroid){ inasteroid.CollideWith(*this); }
};

class ExplodingAsteroid: public Asteroid {// i.e., concrete visitor
  public:
     virtual void CollideWith(SpaceShip&)  { std::cout<<"ExplodingAsteroid hit a SpaceShip!"<<std::endl;  }
     virtual void CollideWith(ApolloSapceCraft&)  { std::cout<<"ExplodingAsteroid hit a ApolloSapceCraft!"<<std::endl;  }
};

int main()
{
  Asteroid theasteroid;
  ExplodingAsteroid theexploidingasteroid; 
  SpaceShip thespaceship;
  ApolloSapceCraft theapollospacecraft;

  Asteroid& theasteroidreference = theasteroid;
  Asteroid& theexploidingsteroidreference = theexploidingasteroid;
  SpaceShip& thespaceshipreference = thespaceship;// do the first Dispatch
  //changed the name of theSpaceShipReference to theapollospaceshipreference
  SpaceShip& theapollospaceshipreference = theapollospacecraft;// do the first Dispatch

 // thespaceshipreference.CollideWith(theasteroid);// Asteroid hit a SpaceShip!
  thespaceshipreference.CollideWith(theasteroidreference);//Asteroid hit a SpaceShip!
  thespaceshipreference.CollideWith(theexploidingsteroidreference);//ExplodingAsteroid hit a SpaceShip!
  
 // theapollospaceshipreference.CollideWith(theasteroid);//Asteroid hit a ApolloSapceCraft!
  theapollospaceshipreference.CollideWith(theasteroidreference);//Asteroid hit a ApolloSapceCraft!
  theapollospaceshipreference.CollideWith(theexploidingsteroidreference);//ExplodingAsteroid hit a ApolloSapceCraft!

 // theasteroidreference.CollideWith(thespaceship);//Asteroid hit a SpaceShip!
 // theasteroidreference.CollideWith(thespaceshipreference);//Asteroid hit a SpaceShip!
 // theasteroidreference.CollideWith(theapollospaceshipreference);//Asteroid hit a SpaceShip!

 //  theexploidingsteroidreference.CollideWith(thespaceship);//ExplodingAsteroid hit a SpaceShip!
 //  theexploidingsteroidreference.CollideWith(thespaceshipreference);//ExplodingAsteroid hit a SpaceShip!
 //  theexploidingsteroidreference.CollideWith(theapollospaceshipreference);//ExplodingAsteroid hit a SpaceShip!
}
\end{lstlisting}

\begin{lstlisting}[caption={Double Dispatch sample code 1 - similar code},label={lst:ddsc},language=C++]
class Problem;
class SpecialProblem;

class Supporter
{
    public:
     virtual void solve(Problem &p) { std::cout<<"Supporter to solve Problem"<<std::endl; }
     virtual void solve(SpecialProblem &sp) { std::cout<<"Supporter to solve SpecialProblem"<<std::endl; }
};

class Problem// do the first Dispatch
{
    public:
     virtual void solve(Supporter *s)  {  s->solve(*this);  }   
};

class SpecialProblem:public Problem// do the first Dispatch
{
    public:
     virtual void solve(Supporter *s)  {  s->solve(*this);  }   
};

class SeniorSupporter:public Supporter
{
    public:
      virtual  void solve(Problem &p) { std::cout<<"SeniorSupporter to solve Problem"<<std::endl; }
      virtual  void solve(SpecialProblem &sp) { std::cout<<"SeniorSupporter to solve SpecialProblem"<<std::endl; }
};

int main()
{
     Problem *p=new Problem();
     Problem *sp=new SpecialProblem();
     Supporter *s=new SeniorSupporter();

/* below won't work since s cannot do the first Dispatch 
     s->solve(*p);// SeniorSupporter to solve Problem
     s->solve(*sp); //SeniorSupporter to solve Problem
*/
     p->solve(s);//SeniorSupporter to solve Problem
     sp->solve(s);//SeniorSupporter to solve SpecialProblem
}
\end{lstlisting}
\paragraph{Double Dispatch: example 2}
Let's look at another exmaple.
We'll assume that the printers all have a common base class (APrinter), and the shapes also have a common base class (AShape).

In the simplest case, as you say, you extend the printer interface with a separate function per shape that it can render.
Now, given some code where you have a printer object, and a shape object.
But the code only knows the printer object to be of type APrinter (assuming a statically typed language), and the shape object to be of type AShape.
How do you, or the compiler, know which printer method to call? That's the crux of the problem.
You need to select the method based on the run-time types, not the static types, of two objects. 

\begin{lstlisting}[caption={Double Dispatch sample code 2},label={lst:vps12},language=C++]
#include <iostream>
using std::cout;

class Printer;

class Shape {//interface for shapes
	public:// each shape needs to implement the print operation!!!
    	virtual void printOn(Printer* printer) = 0;
 };

class Circle;//one concrete shape
class Rectangle;//one concrete shape

class Printer {//interface for printers 
	public:
    	virtual void printCircle(const Circle* circle) = 0;
        virtual void printRectangle(const Rectangle* rectangle) = 0;
 };

class Client { // Prints all shapes on each of the printers.
 public:
  void printAllEverywhere(Shape **shapes, Printer **printers) {

	for (Shape **shape = shapes; *shape; shape++) {
    	for (Printer **printer = printers; *printer; printer++) {
        	 Shape *shp = *shape;
	         shp->printOn(*printer);  // must work for any printer or shape !
	        }
	    }
    }
 };

class InkjetPrinter : public Printer {
	public:
	// ... rasterizing logic for inkjet printing of circles here ...
	void printCircle(const Circle *circle) {cout<<"Inkjet printer prints a circle.";}
	void printRectangle(const Rectangle *rectangle)
                                        {cout<<"Inkjet printer prints a rectangle.";}
 };

class PostscriptPrinter : public Printer {
	public:
	// ... postscript preprocessing logic for circles here ...
	void printCircle(const Circle *circle) {cout<<"PostScript printer prints a cirlce.";}
	void printRectangle(const Rectangle *rectangle)
                                    {cout<<"PostScript printer prints a rectangle.";}
 };

class Circle : public Shape {
	public:
	    void printOn(Printer* printer) {printer->printCircle(this); /*<--the "trick"!*/}
 };

 class Rectangle : public Shape {
	public:
	    void printOn(Printer* printer) { printer->printRectangle(this); }
 };

 int main()
 {
	Shape  *shapes[]  = { new Circle,		new Rectangle,	0 };
	Printer *printers[] = { new PostscriptPrinter, new InkjetPrinter, 0 };

	Client c;
	c.printAllEverywhere(shapes, printers);
	return 0;
 }
\end{lstlisting}
\paragraph{Explanation:}
What happens when shape.printOn(printer) is called at runtime? This depends on the types of the objects referenced by the shape and printer variables at that time.
Let's assume that at the moment, shape points to an instance of class Circle, and printer to an InkjetPrinter.
So, the implementation of printOn(printer) being called will be that of the circle instance, defined in the Circle class (\textbf{first dispatch}).
This method just contains one line: printer.printCircle(this), which delegates the work to the printer object.
As this object is of the class InkjetPrinter, the printCircle(circle) method of the InkjetPrinter class will be executed (\textbf{second dispatch}), which is just what we wanted. 

\section{Multiple dispatch}\label{multid}
\url{https://eli.thegreenplace.net/tag/c-c}
This is the first article in a series dedicated to multiple dispatch - an advanced abstraction technique available to programmers out-of-the-box in some languages, and implementable in others.
This first post in the series presents the technique and explains the problem it intends to solve.
It uses C++ as the presentation language because C++ does not support multiple dispatch directly, but can be used to implement it in various ways.
Showing how multiple dispatch is implemented in a language that doesn't support it natively is important, in my opinion, as it lets us understand the issue on a deeper level.

\paragraph{Polymorphism, single dispatch, multiple dispatch}

There are many kinds of polymorphism in programming. 
The kind we're talking about here is runtime subtype-based polymorphism, where behavior is chosen dynamically based on the runtime \textbf{types of objects}.
More specifically, multiple dispatch is all about the runtime types of more than one object.

The best way to understand multiple dispatch is to first think about single dispatch.
Single dispatch is what we usually refer to as "runtime polymorphism" in languages like C++ and Java (As opposed to "compile-time" polymorphism which in C++ 
is done with overloaded functions and templates).
We have an object on which we call a method, and the actual method being called at runtime depends on the runtime type of the object.
In C++ this is done with virtual functions:

\begin{lstlisting}[caption={C++ runtime polymorphism}, language=C++]
#include<memory>//unique_ptr

class Shape {
    public:
        virtual void ComputeArea() const = 0;
};

class Rectangle : public Shape {
    public:
        virtual void ComputeArea() const {cout << "Rectangle: width times height\n"; }
};

class Ellipse : public Shape {
    public:
        virtual void ComputeArea() const {cout << "Ellipse: width times height times pi/4\n"; }
};

int main(int argc, const char** argv) 
{
  std::unique_ptr<Shape> prec(new Rectangle);
  std::unique_ptr<Shape> pell(new Ellipse);

  prec->ComputeArea();    // invokes Rectangle::ComputeArea
  pell->ComputeArea();    // invokes Ellipse::ComputeArea

  return 0;
}
\end{lstlisting}

Even though both ``prec'' and ``pell'' are pointers to a Shape as far as the C++ compiler is concerned,
the two calls to ``ComputeArea()'' get dispatched to different methods at runtime due to C++'s implementation of runtime polymorphism via virtual functions.

Now, spend a few seconds thinking about the question: "What is the dispatch done upon in the code sample above?"

It's fairly obvious that the entity we dispatch upon is a pointer to Shape. We have ``prec'' and we call a method on it.
The C++ compiler emits code for this call such that at runtime the right function is invoked.
\textit{The decision which function to invoke is based upon examining a single object - what ``prec'' points to. Hence single dispatch.}

A natural extension of this idea is multiple dispatch, wherein the decision which function to call is based on the runtime types of multiple objects.
Why is this useful? It's not a tool programmers reach for very often, but when it is appropriate, alternatives tend to be cumbersome and repetitive.
A telling sign that multiple dispatch may be in order is when you have some operation that involves more than one class and there is no single obvious class where this operation belongs.
Think of simulating a sound when a drumstick hits a drum. There are many kinds of drumsticks, and many kinds of drums; their combinations produce different sounds.
Say we want to write a function (or family of functions) that determines which sound is produced.
Should this function be a method of the Drum class or the DrumStick class? Forcing this decision is one of the follies of classical OOP,
and multiple dispatch helps us solve it naturally without adding a kludge into our design.

A simpler and more canonical example is computing intersections of shapes - maybe for computer graphics, or for simulation, or other use cases.
A generic shape intersection computation can be complex to implement, but in many specific cases it's easy.
For example, computing intersections of rectangles with rectangles is trivial; same for circles and ellipses; rectangles with triangles may be a tiny bit harder,
but still much simpler than artibrary polygons, and so on. 
More examples: You may have multiple event types handled by multiple handlers - mixing and matching them boils down to the same problem. 
Or in game code, you may have collision detection between different kinds of objects; 
or completely different battle scenarios depending on two kinds of units - knight vs. mage, mage vs. mage, knight vs. elf, or whatever. 
These examples sound like toys, but this is because realistic examples are often much more boring and more difficult to explain. 
Battles between mages and knights is more reasonable to discuss in an introductory article than different kinds of mathematical transforms applied to different kinds of nodes in a dataflow graph.

How do we write code to handle all these cases? All in all, we just need an intersect function that takes two shapes and computes an intersection.
This function may have a whole bunch of special cases inside for different combinations of shapes it knows how to do easily, before it resorts to some heavy-handed generic polygon intersection approach.
Such code, however, would be gross to develop and maintain. Wouldn't it be nice if we could have:

\begin{lstlisting}[caption={C++ runtime polymorphism}, language=C++]
void Intersect(const Rectangle* r, const Ellipse* e) {
  // implement intersection of rectangle with ellipse
}

void Intersect(const Rectangle* r1, const Rectangle* r2) {
  // implement intersection of rectangle with another rectangle
}

void Intersect(const Shape* s1, const Shape* s2) {
  // implement interesction of two generic shapes
}
\end{lstlisting}
And then the call \textbf{Intersect(some\_shape, other\_shape)} would just magically dispatch to the right function? 
This capability is what's most often referred to by multiple dispatch in programming language parlance.To be more precise, 
this is a special case - double dispatch, where dispatch is done on two objects. 
I will mostly focus on double dispatch in this series, even though some of the languages and techniques presented support an arbitrary number of objects. 
In my experience, in 99\% of the cases where multiple dispatch is useful, two objects are sufficient.
\paragraph{A failed attempt in C++}\mbox{}

You may be tempted to come up with the following "trivial" solution in C++:

\begin{lstlisting}[caption={function overloading}, language=C++]
class Shape {
public://https://stackoverflow.com/questions/281818/unmangling-the-result-of-stdtype-infoname
  virtual std::string name() const { return typeid(*this).name(); }// check above link 
};

class Rectangle : public Shape {};
class Ellipse : public Shape {};
class Triangle : public Shape {};

// Overloaded Intersect methods.
void Intersect(const Rectangle* r, const Ellipse* e) {
  std::cout<<"Rectangle x Ellipse [names r=" << r->name()<<", e="<<e->name()<<"]\n";
}

void Intersect(const Rectangle* r1, const Rectangle* r2) {
  std::cout<<"Rectangle x Rectangle [names r1="<< r1->name()<<", r2="<< r2->name()<<"]\n";
}

// Fallback to shapes
void Intersect(const Shape* s1, const Shape* s2) {//generic handler 
  std::cout << "Shape x Shape [names s1=" << s1->name()<<", s2=" << s2->name() << "]\n";
}

int main() {
    Rectangle r1, r2;
    Ellipse e;
    Triangle t;

    std::cout << "Static type dispatch\n";
    Intersect(&r1, &e);
    Intersect(&r1, &r2);
    Intersect(&r1, &t);
}
\end{lstlisting}
We'll see:
\begin{verbatim}
Static type dispatch
Rectangle x Ellipse [names r=9Rectangle, e=7Ellipse]
Rectangle x Rectangle [names r1=9Rectangle, r2=9Rectangle]
Shape x Shape [names s1=9Rectangle, s2=8Triangle]
\end{verbatim}

Note how the intersections get dispatched to specialized functions when these exist and to a generic catch-all ``Shape x Shape'' handler when there is no specialized function.

So that's it, multiple dispatch works out of the box? Not so fast... What we see here is just C++ \textbf{function overloading} in action.
The compiler knows the \textcolor{red}{static, compile-time} types of the pointers passed to the Intersect calls, so it just emits the right call.
Function overloading is great and useful, but this is not the general problem we're trying to solve.
In a realistic code-base, you won't be passing pointers to concrete subclasses of Shape around.
You are almost certainly going to be dealing with pointers to the Shape base class. Let's try to see how the code in the previous sample works with dynamic types:

\begin{lstlisting}[caption={still NOT Multiple dispatch}, language=C++]
#include<memory>
std::unique_ptr<Shape> pr1(new Rectangle);
std::unique_ptr<Shape> pr2(new Rectangle);
std::unique_ptr<Shape> pe(new Ellipse);
std::unique_ptr<Shape> pt(new Triangle);

std::cout << "Dynamic type dispatch\n";
Intersect(pr1.get(), pe.get());
Intersect(pr1.get(), pr2.get());
Intersect(pr1.get(), pt.get());
\end{lstlisting}
Prints:
\begin{verbatim}
Dynamic type dispatch
Shape x Shape [names s1=9Rectangle, s2=7Ellipse]
Shape x Shape [names s1=9Rectangle, s2=9Rectangle]
Shape x Shape [names s1=9Rectangle, s2=8Triangle]
\end{verbatim}
Yeah... that's not good. All calls were dispatched to the \textit{generic} ``Shape * Shape'' handler, even though the runtime types of the objects are different (see the names gathered from typeid).
This is hardly surprising, because when the compiler sees Intersect(pr1.get(), pr2.get()), the static types for the two arguments are Shape* and Shape*.
You could be forgiven for thinking that the compiler may invoke virtual dispatch here, but virtual dispatch in C++ doesn't work this way.
It only works when a virtual method is called on a pointer to a base object, which is not what's happening here.

\paragraph{Multiple dispatch in C++ with the visitor pattern~\ref{VisitorPattern}}

I'll admit I'm calling this approach ``the visitor pattern'' only because this is how it's called elsewhere and because I don't have a better name for it.
In fact, it's probably closer to an "inverted" visitor pattern, and in general the pattern name may obscure the code more than help.
So forget about the name, and just study the code.

The last paragraph of the previous section ended with an important observation: \textbf{virtual dispatch in C++ kicks in only when a virtual method is called on a pointer to a base object.}
Let's leverage this idea to simulate double dispatch on our hierarchy of shapes.
The plan is to arrange Intersect to hop through virtual dispatches on both its arguments to get to the right method for their runtime types.

We'll start by defining Shape like this:

\begin{lstlisting}
class Shape {
public:
  virtual std::string name() const { return typeid(*this).name(); }

  // Dispatcher that should be called by clients to intersect different shapes.
  virtual void Intersect(const Shape*) const = 0;

  // Specific interesection methods implemented by subclasses. If subclass A
  // has a special way to intersect with subclass B, it should implement
  // InteresectWith(const B*).
  virtual void IntersectWith(const Shape*) const {}
  virtual void IntersectWith(const Rectangle*) const {}
  virtual void IntersectWith(const Ellipse*) const {}
};
\end{lstlisting}
The Intersect method is what the users of the code will invoke.
To be able to make use of virtual dispatches, we are forced to turn a two-argument call Intersect(A*, B*) to a method call A-$>$Intersect(B).
The IntersectWith methods are concrete implementations of intersections the code will dispatch to and should be implemented by subclasses on a case-per-case basis.

\begin{lstlisting}
class Rectangle : public Shape {
public:
  virtual void Intersect(const Shape* s) const { s->IntersectWith(this); }

  virtual void IntersectWith(const Shape* s) const {
    cout<<"Rectangle x Shape [names this="<<this->name()<<", s=" << s->name() << "]\n"; }

  virtual void IntersectWith(const Rectangle* r) const {
    cout<<"Rectangle x Rectangle [names this="<<this->name()<<", r="<<r->name() << "]\n";
  }
};

class Ellipse : public Shape {
public:
  virtual void Intersect(const Shape* s) const { s->IntersectWith(this); }

  virtual void IntersectWith(const Rectangle* r) const {
    cout<<"Ellipse x Rectangle [names this="<<this->name() <<", r="<<r->name()<<"]\n";}
};

std::unique_ptr<Shape> pr1(new Rectangle);
std::unique_ptr<Shape> pr2(new Rectangle);
std::unique_ptr<Shape> pe(new Ellipse);

std::cout << "Dynamic type dispatch\n";
pr1->Intersect(pe.get());
pr1->Intersect(pr2.get());
\end{lstlisting}
Will now print:

\begin{verbatim}
Dynamic type dispatch
Ellipse x Rectangle [names this=7Ellipse, r=9Rectangle]
Rectangle x Rectangle [names this=9Rectangle, r=9Rectangle]
\end{verbatim}
Success! Even though we're dealing solely in pointers to Shape, the right intersections are computed. Why does this work?

As I've mentioned before, the key here is use C++'s virtual function dispatch capability, \underline{\textbf{twice}}. Let's trace through one execution to see what's going on. We have:
\begin{verbatim}
pr1->Intersect(pe.get());
\end{verbatim}
``pr1'' is a pointer to Shape, and ``Intersect'' is a pure virtual method in Shape class. Therefore, the runtime type's ``Intersect'' is called here, which is ``Rectangle::Intersect''.
The argument passed into the method of ``Rectangle::Intersect'' is another pointer to Shape which at runtime points to an ``Ellipse (pe)''.
Rectangle::Intersect calls ``s-$>$IntersectWith(this)''. The compiler sees that ``s'' is a ``Shape*'', and IntersectWith is a virtual method, so this is another virtual dispatch.
What gets called is ``Ellipse::IntersectWith''. But which overload of this method is called?

This is an extremely crucial point in the explanation, so please focus :-) Here is Rectangle::Intersect again:
\begin{verbatim}
virtual void Intersect(const Shape* s) const { s->IntersectWith(this); }
\end{verbatim}
``s-$>$IntersectWith'' is called with this, which the compiler knows is a pointer to Rectangle, statically.
If you wondered why I define \textbf{``Intersect''} in \textbf{each subclass} rather than doing it once in Shape, even though its code is exactly the same for each subclass, this is the reason.
Had I defined it in Shape, the compiler would think the type of this is Shape* and would always dispatch to the IntersectWith(const Shape*) overload.
Defining this method in each subclass helps the compiler leverage overloading to call the right method.

What happens eventually is that the call ``pr1-$>$Intersect(pe.get())'' gets routed to ``Ellipse::IntersectWith(const Rectangle*)'', thanks to \textcolor{red}{two virtual dispatches 
and one use of method overloading.}
The end result is double dispatch!  
I'll lament again that the ``visitor'' pattern is not a great name to apply here. 
An alternative way to talk about this approach is ``partial application''. 
With double dispatch, we route the call through two virtual method calls. 
The first of these can be seen to create a partially applied method that knows the dynamic type of one of its arguments, and what remains is to grab the other.
This idea also extends naturally to multiple dispatch with more than 2 objects. As an exercise, try to figure out how to do triple dispatch using this technique.

But wait a second, how did we end up with ``Ellipse::IntersectWith(Rectangle)''? Shouldn't ``pr1-$>$Intersect(pe.get())'' go to ``Rectangle::IntersectWith(Ellipse)'' instead? Well, yes and no.
Yes - because this is what you'd expect from how the call is syntactically structured.
No - because you almost certainly want double dispatches to be symmetric. I'll discuss this and other related issues in the next section.
\paragraph{Symmetry and base-class defaults}

When we come up with ways to do multiple dispatch, whether in C++ or in other languages, there are two aspects of the solution we should always keep in mind:

    Does it permit symmetry? In other words, does the \textcolor{red}{order} of objects dispatched upon matters? And if it doesn't, how much extra code is needed to express this fact.

    Does base-class default dispatch work as expected? Suppose we create a new subclass of Rectangle, called Square and we don't explicitly create an IntersectWith method for Square and Ellipse.
    Will the right thing happen and the intersection between a Rectangle and Ellipse be invoked when we ask for Square x Ellipse?
    This is the right thing because this is what we've come to expect from class hierarchies in object-oriented languages.

In the visitor-based solution presented above, both aspects will work, though symmetry needs a bit of extra code.
The full code sample is available here: 
\begin{lstlisting}
// A more complete sample of the visitor pattern for multiple dispatch.
// Separates header and implementation so that the implementations of classes
// can circularly refer to other classes.
//
// Eli Bendersky [http://eli.thegreenplace.net]
// This code is in the public domain.
#ifndef VISITOR_FULL_H
#define VISITOR_FULL_H

#include <string>
#include <typeinfo>

class Rectangle;
class Ellipse;
class Triangle;

class Shape {
public:
  virtual std::string name() const { return typeid(*this).name(); }

  // Dispatcher that should be called by clients to intersect different shapes.
  virtual void Intersect(const Shape*) const = 0;

  // Specific interesection methods implemented by subclasses. If subclass A
  // has a special way to intersect with subclass B, it should implement
  // InteresectWith(const B*). Otherwise, the IntersectWith(const B*) method
  // of Shape will be called.
  virtual void IntersectWith(const Shape*) const;
  virtual void IntersectWith(const Rectangle*) const;
  virtual void IntersectWith(const Ellipse*) const;
  virtual void IntersectWith(const Triangle*) const;
};

class Rectangle : public Shape {
public:
  virtual void Intersect(const Shape* s) const override { s->IntersectWith(this); }

  virtual void IntersectWith(const Rectangle*) const override;
  virtual void IntersectWith(const Ellipse*) const override;
};

class Ellipse : public Shape {
public:
  virtual void Intersect(const Shape* s) const override { s->IntersectWith(this); }

  virtual void IntersectWith(const Rectangle*) const override;

  // As an example, Ellipse does not define intersection with Ellipse, so the
  // calls will be routed to IntersectWith(const Shape*) instead.
};

class Triangle : public Shape {
public:
  virtual void Intersect(const Shape* s) const override { s->IntersectWith(this); }

  // Triangle has no IntersectWith methods and the other shapes have no
  // IntersectWith(Triangle) overloads; therefore, Triangle intersections will
  // always be deferred to Shape.
};

#endif // VISITOR_FULL_H
\end{lstlisting}

It's conceptually similar to the code shown above, but with a bit more details. In particular, it implements symmetry between rectangle and ellipse intersections as follows:
\begin{lstlisting}
namespace {

// All intersections between rectangles and ellipses dispatch here.
void SymmetricIntersectRectangleEllipse(const Rectangle* r, const Ellipse* e) {
  std::cout << "IntersectRectangleEllipse [names r=" << r->name() << ", e=" << e->name() << "]\n";}
}

void Rectangle::IntersectWith(const Ellipse* e) const {
  SymmetricIntersectRectangleEllipse(this, e);
}

void Ellipse::IntersectWith(const Rectangle* r) const {
  SymmetricIntersectRectangleEllipse(r, this);
}
\end{lstlisting}
This ensures that both ``rectangle->Intersect(ellipse)'' and ``ellipse->Intersect(rectangle)'' end up in the same function.
As far as I know there's not way to do this automatically in the visitor approach, so a bit of extra coding is due when symmetry between subclasses is desired.

Note also that this method doesn't force symmetry either. If some form of dispatch is order-dependent, it's easy to express.
\paragraph{The problem with the visitor-based approach}

Although the visitor-based approach works, enables fairly clean client code and is efficient (constant time - two virtual calls),
there's a glaring issue with it that's apparent with the most cursory look at the code: it's very intrusive, and hence hard to maintain.

Imagine we want to add a new kind of shape - a HyperFrob. Suppose also that there's an efficient algorithm for intersecting a HyperFrob with an Ellipse.
Ideally, we'd only have to write code for the new functionality:

    Define the new HyperFrob class deriving from Shape.

    Implement the generic HyperFrob x Shape intersection algorithm.

    Implement the specific HyperFrom x Ellipse algorithm.

But in reality, we're forced to modify the definition of the base class Shape to add an overload of IntersectWith for HyperFrob.
Moreover, if we want intersections between HyperFrob and Ellipse to be symmetric (which we almost certainly do), we'll have to modify Ellipse as well to add the same overload.

If we don't control the Shape base class at all, we're in real trouble.
This is an instance of the \textit{expression problem}.
I'll have more to say about the expression problem in a future post, but for now the Wikipedia link will have to do.
It's not an easy problem to solve in C++, and the approaches to implement multiple dispatch should be judged by how flexible they are in this respect, along with the other considerations.
\paragraph{Multiple-dispatch in C++ by brute-force}

The visitor-based approach is kind-of clever, leveraging single virtual dispatch multiple times to simulate multiple dispatch.
But if we go back to first principles for a moment, it becomes clear that there's a much more obvious solution to the problem - brute-force if-else checks.
I mentioned this possibility early in the article and called it "gross to develop and maintain", but it makes sense to at least get a feel for how it would look:
\begin{lstlisting}
class Shape {
public:
  virtual std::string name() const { return typeid(*this).name(); }
};

class Rectangle : public Shape {};
class Ellipse : public Shape {};
class Triangle : public Shape {};

void Intersect(const Shape* s1, const Shape* s2) {
  if (const Rectangle* r1 = dynamic_cast<const Rectangle*>(s1)) {
    if (const Rectangle* r2 = dynamic_cast<const Rectangle*>(s2)) {
      cout<<"Rectangle x Rectangle [names r1="<<r1->name()<<", r2=" << r2->name()<<"]\n";
    } else if (const Ellipse* e2 = dynamic_cast<const Ellipse*>(s2)) {
      cout<<"Rectangle x Ellipse [names r1=" << r1->name() << ", e2=" << e2->name()<<"]\n";
    } else {
      cout<<"Rectangle x Shape [names r1=" << r1->name() <<", s2="<<s2->name()<<"]\n";
    }
  } else if (const Ellipse* e1 = dynamic_cast<const Ellipse*>(s1)) {
    if (const Ellipse* e2 = dynamic_cast<const Ellipse*>(s2)) {
      cout<<"Ellipse x Ellipse [names e1=" << e1->name()<<", e2="<<e2->name()<<"]\n";
    } else {
      // Handle other Ellipse x ... dispatches.
    }
  } else {
    // Handle Triangle s1
  }
}
\end{lstlisting}
One thing is immediately noticeable: the intrusiveness issue of the visitor-based approach is completely solved.
Obliterated! Intersect is now a stand-alone function that encapsulates the dispatch. If we add new kinds of shape, we only have to change Intersect, nothing else. Perfect... or is it?

The other immediately noticeable fact about this code is: holy cow, how long it is.
I'm only showing a small snippet here, but the number of these ``if'' clauses grows as square of the number of subclasses.
Imagine how this could look for 20 kinds of shapes. Moreover, Intersect is just one algorithm. We may have other "multi methods" - this travesty would have to be repeated for each algorithm.

Another, less obvious problem is that the code is somewhat brittle. Given a non-trivial inheritance hierarchy,
we have to be very careful about the order of the if clauses, lest a parent class "shadows" all its subclasses by coming before them in the chain.

It's no wonder that one would be very reluctant to write all this code. In fact, smart folks came up with all kinds of ways to automate such if chains.
If you're thinking - "hey I could just store pairs of typeids in a map and dispatch upon that" - congrats, you're in the right direction.

One of the most notable experts to tackle the beast is Andrei Alexandrescu, who dedicated chapter 11 of "Modern C++ Design" to this problem,
implementing all kinds of automated solutions based on heavy template metaprogramming. It's a fairly impressive piece of work,
presenting multiple approaches with different tradeoffs in terms of performance and intrusiveness.
If you Google for Loki (his C++ template library) and look into the ``MultiMethods.h'' header you'll see it in all its glory - complete with type lists, traits, policies, and template templates.
This is C++, and these are the abstractions the language provides for meta-programming - so take it or leave it :-)
If you are seriously considering using multiple dispatch in your C++ code, Loki is well worth a look.
\paragraph{An attempt for standardization}

By far the most interesting attempt to solve this problem came from Bjarne Stroustrup himself, who co-authored a paper with two of his students named "Open Multi-Methods for C++" [5].
In this paper, the authors thoroughly review the problem and propose a C++ language extension that will implement it efficiently in the compiler.

The main idea is to let function arguments be potentially virtual, meaning that they perform dynamic dispatch and not just static overloading.
So we could implement our intersection problem as follows:
\begin{lstlisting}
// This is not real C++: the syntax is based on the paper
// "Open Multi-Methods for C++" and was only implemented experimentally.

// Generic Shape x Shape intersection.
void Intersect(virtual const Shape*, virtual const Shape*);

// Interesection for Rectangle x Ellipse.
void Intersect(virtual const Rectangle*, virtual const Ellipse*);
\end{lstlisting}
Note how similar this is to the failed attempt to leverage overloading for multiple dispatch in the beginning of this article.
All we add is the virtual keyword for arguments, and the dispatch turns from static to dynamic.

Unfortunately, the proposal never made it into the standard (it was proposed as document number N2216).
\paragraph{Conclusions and next steps}

This part in the series presented the multiple dispatch problem and demonstrated possible solutions in C++.
Each solution has its advantages and issues, and choosing one depends on the exact needs of your project.
C++ presents unique challenges in designing such high-level abstractions, because it's comparatively rigid and statically typed.
Abstractions in C++ also tend to strive to being as cheap as possible in terms of runtime performance and memory consumption, which adds another dimension of complexity to the problem.

In the following parts of the series we'll examine how the same problem is solved in other, more dynamic and structurally flexible programming languages.

[5]	The paper is available from Stroustrup's home page.
\chapter{Delegation}
\paragraph{Definition}
In the Introduction to Gamma et al. 1994, Grady Booch defined delegation as:
Delegation is a way to make composition as powerful for reuse as inheritance [Lie86, JZ91]. 
In delegation, two objects are involved in handling a request: a receiving object delegates operations to its delegate.
This is analogous to subclasses deferring requests to parent classes. 
But with inheritance, an inherited operation can always refer to the receiving object through the this member variable in C++ and self in Smalltalk.
To achieve the same effect with delegation, the receiver passes itself to the delegate to let the delegated operation refer to the receiver.
Note that this article uses "sending object/receiving object" for the two objects,
rather than "receiving object/delegate", emphasizing which objects send and receive the delegation call, not the original call.

Delegation is used in several design patterns: state~\ref{StatePattern}, strategy~\ref{StrategyPattern}, visitor~\ref{VisitorPattern}.
% or \url{http://www.bogotobogo.com/CSharp/csharp_delegates.php} in C\#. 
Conceptually, a delegate is nothing more than a type-safe method reference.
A delegate allows us to delegate the act of calling a method to somebody else.
A delegate also can be thought of as an object that contains an ordered list of methods with the same signature and return type. 

"Delegation is a good design choice only when it simplifies more than it complicates.
It isn't easy to give rules that tell you exactly when to use delegation, because how effective it will be depends on the context and on how much experience you have with it. 
Delegation works best when it's used in highly stylized ways - that is, in standard patterns." - from Design Pattern - Elements of Resuable Object-Oriented Software by Eirch Gamma et al.

Using delegation can make a design more flexible as shown in the example below.
The ``RemoteHost'' does not have to refer to ``RemoteHostA'' or ``RemoteHostB'' in any way because the switching of delegation is abstracted from ``RemoteHost''.
The ``RemoteHost'' class can \textbf{delegate} to ``RemoteHostA'' or ``RemoteHostB''.
%\subsection{Example code 1}
\begin{lstlisting}[caption={Delegation Exmaple code 1},language=C++]
class Host
{
    public:
    	virtual void f() = 0;
};

class RemoteHostA : public Host
{
    public:
    	void f() { cout << "A::f()" << endl; }
};

class RemoteHostB : public Host
{
    public:
    	void f() { cout << "B::f()" << endl; }
};

// This class has a delegate switch to either RemoteHostA or RemoteHostB
class RemoteHost : public Host
{
    public:
    //The explicit specifier specifies that a constructor or conversion function (since C++11) doesn't allow implicit conversions or copy-initialization.
    //It may only appear within the decl-specifier-seq of the declaration of such a function within its class definition. 

    	explicit RemoteHost() { mHost = new RemoteHostA;}
        void f() { mHost->f(); }
        void connectA() { mHost = new RemoteHostA(); }
        void connectB() { mHost = new RemoteHostB(); }
    private:
    	Host *mHost;
};

int main()
{
    RemoteHost *remote = new RemoteHost();
    remote->f();         // A::f() from default constructor

    remote->connectB();
    remote->f();         // B::f()

    remote->connectA();
    remote->f();         // A::f()

    return 0;
}
\end{lstlisting}
\paragraph{When would I use the delegation pattern instead of inheritence to extend a class's behavior?}
Both delegation and inheritance are important concepts in object-oriented software design, but not everyone would label them as patterns.
In particular, the seminal book on design patterns by the “Gang of Four” contains a discussion of inheritance and delegation, but the authors do not treat these topics as specific patterns.
It is reasonable to think of them as design concepts which are more general than specific design patterns.

Inheritance is a relationship between two classes where one class, called a subclass in this context, inherits the attributes and operations of another class, called its superclass.
Inheritance can be a powerful design/reuse technique, especially when it is used in the context of the Liskov Substitution Principle~\ref{LSP}.
(The article by Robert Martin at \url{http://www.objectmentor.com/publications/lsp.pdf} provides an excellent explanation of the ideas behind
Barbara Liskov’s original paper on using inheritance correctly.) 

The primary advantages of inheritance are 1) it is directly supported by object-oriented languages, and
2) it provides the context for polymorphism in strongly-typed object-oriented languages such as C++ and Java.

But since the inheritance relationship is defined at compile-time, a class can’t change its superclass dynamically during program execution.
Moreover, modifications to a superclass automatically propagate to the subclass, providing a two-edged sword for software maintenance and reuse.
In summary, inheritance creates a strong, static coupling between a superclass and its subclasses.

Delegation can be viewed as a relationship between objects where one object forwards certain method calls to another object, called its delegate.
Delegation can also a powerful design/reuse technique. The primary advantage of delegation is run-time flexibility – the delegate can easily be changed at run-time.
But unlike inheritance, delegation is not directly supported by most popular object-oriented languages, and it doesn’t facilitate dynamic polymorphism.

As a simple example, consider the relationship between a Rectangle class and a Window class.
With inheritance, a Window class would inherit its rectangular properties from class Rectangle.
With delegation, a Window object would maintain a reference or pointer to a Rectangle object, 
and calls to rectangle-like methods of the Window object would be delegated to corresponding methods of the Rectangle object.

Now let’s consider a slightly more complex example.
Suppose employees can classified based on how they are paid; e.g., hourly or salaried.
Using inheritance, we might design three classes: an ``Employee'' class which encapsulates the functionality common to all employees,
and two subclasses ``HourlyEmployee'' and ``SalariedEmployee'' which encapsulates pay-specific details. While this design might be suitable for some applications,
we would encounter problems in a scenario where a person changes, say from hourly to salaried.
The class of an object and the inheritance relationship are both static, and objects can’t change their class easily (but see the State pattern~\ref{StatePattern} for tips on how to fake it).

A more flexible design would involve delegation – an Employee object could delegate pay-related method calls to an object whose responsibilities focused solely on how the employee is paid. 
In fact, we might still use inheritance here in a slightly different manner by creating an abstract class (or interface) called
PayClassification with two subclasses HourlyPayClassification and SalariedPayClassification which implement classification-specific computations.
Using delegation as shown, it would be much easier to change the pay classification of an existing Employee object.

This second example illustrates an important point: In implementing delegation, we often want the capability to replace the delegate with another object,
possibly of a different class. Therefore delegation will often use inheritance and polymorphism,
with classes of potential delegates being subclasses of an abstract class which encapsulates general delegate responsibilities.

One final point. Sometimes, the choice between delegation and inheritance is driven by external factors such associate
programming language support for multiple inheritance or design constraints requiring polymorphism.
Consider threads in Java. You can associate a class with a thread in one of two ways: either by extending (inheriting) directly from class Thread,
or by implementing the Runnable interface and then delegating to a Thread object.
Often the approach taken is based on the restriction in Java that a class can only extend one class (i.e., Java does not support multiple inheritance).
If the class you want to associate with a thread already extends some other class in the design,
then you would have to use delegation; otherwise, extending class Thread would usually be the simpler approach. 
\paragraph{More examples}
\textcolor{blue}{A delegate is a helper object used by another object.}
The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message.
This pattern is heavily used in Cocoa framework on Mac OS X.(from \url{http://rosettacode.org/wiki/Delegates#C.2B.2B}

Objects responsibilities:

Delegator(sender):
    Keep an optional delegate instance.
    Implement ``operation'' method, returning the delegate ``thing'' if the delegate respond to ``thing'', or the string ``default implementation''.

Delegate(receiver):
    Implement ``thing'' and return the string ``delegate implementation''

Show how objects are created and used. First, without a delegate, then with a delegate that does not implement "thing", and last with a delegate that implements ``thing''. 
As best you can do, without support for classes.
\begin{lstlisting}[caption={Delegation Exmaple code, C implementation},language=C]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
typedef const char * (*Responder)( int p1);
 
typedef struct sDelegate {
    Responder operation;
} *Delegate;
 
/* Delegate class constructor */
Delegate NewDelegate( Responder rspndr )
{
    Delegate dl = malloc(sizeof(struct sDelegate));
    dl->operation = rspndr;
    return dl;
}
 
/* Thing method of Delegate */
const char *DelegateThing(Delegate dl, int p1)
{
    return  (dl->operation)? (*dl->operation)(p1) : NULL;
}
 
/** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
typedef struct sDelegator {
    int     param;
    char    *phrase;
    Delegate delegate;
} *Delegator;
 
const char * defaultResponse( int p1)
{
    return "default implementation";
}
 
static struct sDelegate defaultDel = { &defaultResponse };
 
/* Delegator class constructor */
Delegator NewDelegator( int p, char *phrase)
{
    Delegator d  = malloc(sizeof(struct sDelegator));
    d->param = p;
    d->phrase = phrase;
    d->delegate = &defaultDel;	/* default delegate */
    return d;
}
 
/* Operation method of Delegator */
const char *Delegator_Operation( Delegator theDelegator, int p1, Delegate delroy)
{
    const char *rtn;
    if (delroy) {
        rtn = DelegateThing(delroy, p1);
        if (!rtn) {			/* delegate didn't handle 'thing' */
            rtn = DelegateThing(theDelegator->delegate, p1);
        }
    }
    else 		/* no delegate */
        rtn = DelegateThing(theDelegator->delegate, p1);
 
    printf("%s\n", theDelegator->phrase );
    return rtn;
}
 
/** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
const char *thing1( int p1)
{
    printf("We're in thing1 with value %d\n" , p1);
    return "delegate implementation";
}
 
int main()
{
    Delegate del1 = NewDelegate(&thing1);
    Delegate del2 = NewDelegate(NULL);
    Delegator theDelegator = NewDelegator( 14, "A stellar vista, Baby.");
 
    printf("Delegator returns %s\n\n", Delegator_Operation( theDelegator, 3, NULL));
    printf("Delegator returns %s\n\n", Delegator_Operation( theDelegator, 3, del1));
    printf("Delegator returns %s\n\n", Delegator_Operation( theDelegator, 3, del2));
    return 0;
}
\end{lstlisting}
Delegates in the C\# or D style are available in C++ through std::tr1::function class template (tr1 is C++ Technical Report 1 namespace).
These delegates don't exactly match this problem statement though, 
as they only support a single method call (which is operator()), and so don't support querying for support of particular methods. 
\begin{lstlisting}[caption={Delegation example code C++ tr1 implementation}, language=C++]
#include <tr1/memory>
#include <string>
#include <iostream>
#include <tr1/functional>
 
using namespace std;
using namespace std::tr1;
using std::tr1::function;
 
// interface for all delegates
class IDelegate
{
public:
    virtual ~IDelegate() {}
};
 
//interface for delegates supporting thing 
class IThing
{
public:
    virtual ~IThing() {}
    virtual std::string Thing() = 0;
};
 
class DelegateA : virtual public IDelegate { }; // Does not handle Thing
 
// Handles Thing
class DelegateB : public IThing, public IDelegate
{
    std::string Thing() { return "delegate implementation"; }
};
 
class Delegator
{
public:
    std::string Operation()
    {
        if(Delegate) //have delegate
           if (IThing * pThing = dynamic_cast<IThing*>(Delegate.get()))
            //delegate provides IThing interface
            return pThing->Thing();
 
        return "default implementation";
    }
 
    shared_ptr<IDelegate> Delegate;
};
 
int main()
{
    shared_ptr<DelegateA> delegateA(new DelegateA());
    shared_ptr<DelegateB> delegateB(new DelegateB());
    Delegator delegator;
 
    // No delegate
    std::cout << delegator.Operation() << std::endl;
 
    // Delegate doesn't handle "Thing"
    delegator.Delegate = delegateA;
    std::cout << delegator.Operation() << std::endl;
 
    // Delegate handles "Thing"
    delegator.Delegate = delegateB;
    std::cout << delegator.Operation() << std::endl;
 
/*
Prints:
 
  default implementation
  default implementation
  delegate implementation
 */
}
\end{lstlisting}
\paragraph{How about Delegation is private inheritance?}
%\url{http://www.cpptips.com/delegation}
%APPLETON: bradapp@enteract.com (Brad Appleton)
That would be incorrect. Strictly speaking, delegation is the ability of one object to forward messages and/or the responsibility for
servicing one or more messages to another object. The other object does not have to be a component, or superclass portion of the
forwarding object; it could an object associated via some other means, or even a global object of some kind (perish the thought ;-).

[ I would also add the important definition that all method invocations and data accessing is done in the context of the
  delegator, not the delegatee. For example,
\begin{lstlisting}
class Delegator
{
  public:
      void foo () { fDelegatee->foo (); }
      void bar () { cout << "Delegator::bar"; }
  private:
      Delegatee* fDelegatee;
};

class Delegatee
{
  public:
      void foo () { /* fDelegator-> */ bar(); }
      void bar () { cout << "Delegatee::bar"; }
  private:
      /* Delegator* fDelegator; */
};
\end{lstlisting}
If C++ had delegation, the result of calling "foo" on the delegator would result in "Delegator::bar" being output. Since C++ does not directly support this, you
as designer, would have to uncomment the code to manually make sure that bar() is invoked in the context of the delegator.  - adc ]

Inheritance is actually a special form of delegation: a subclass delegates to its superclass, the responsibility for servicing all
messages that it accepts but does not implement. Such delegation does not restrict the delegate to be only a private superclass. It could
just as easily be a public one, where the method that does the delegation has a different name and/or signature from the method of
the delegate the is ultimately invoked to fulfill the request.

The concept of delegation is orthogonal to the concept of class.  It is possible for a language to have ``objects + delegation'' but no classes
(Self is such a langauge).  It is also possible for a language to have objects and classes, but no direct support for delegation (which means
no inheritance of method implementations among other things, although you could still inherit data).

Languages like C++ do not have direct support for delegation (other than method-by-method): You have to explicitly code up all message
forwarding calls (as in Robert's example) like:
\begin{verbatim}
       Foo::bar() { myItem->bar(); }
\end{verbatim}
This type of delegation is often referred to as "propagation". There are other forms however. For example, it would be nice if you could
tell an object to forward (or delegate) all messages that it doesn't understand to some other object (like one of its components). This
would be very useful for implementing proxies, surrogates, and wrappers (perhaps adding some additional pre and/or post invocation
code). If this were added to C++, the syntax might perhaps look something like a switch statement by adding reserved words "delegate"
and "method" as in:
\begin{lstlisting}[caption={Delegation pseudocode in C++}]
class MyDelegator {
private:
   MyDelegate  delegate1, *delegate2;

   // ... the usual stuff here

   // Now specify delegation details using method names and/or method signatures to be forwarded.
   delegate {

      method foo :  // all methods named foo() regardless of the args

      method bar(int) :

         delegate1.method; // <- invokes the method of delegate1 with
         break;            // the same signature and arguments as the
                           // method being delegated

      default : // delegate everything else that we dont understand  to delegate2
         delegate2->lock();    // do some pre-delegation code
         delegate2->method;    // forward the message
         delegate2->unlock();  // do some post-delegation code
   };
}
\end{lstlisting}
PLEASE NOTE that I am *not* proposing the above syntax be added to C++, or even that delegation be added as a language feature. This is
just an example whipped up for demonstrative purposes (and probably not even a very good one at that)!

\paragraph{What does it mean to "cross delegation" or "delegate to a sister class" via virtual inheritance? }

Consider the following example:
\begin{lstlisting}[caption={delegation example code}, language=C++]
class Base {
public:
  virtual void foo() = 0;
  virtual void bar() = 0;
};

class Der1 : public virtual Base {
public:
  virtual void foo(){ cout<<"Der1::foo calling bar"<<endl; bar(); }
};

class Der2 : public virtual Base {
public:
  virtual void bar(){cout<<"Der2::bar called "<<endl;}
};

class Join : public Der1, public Der2 {
public:
  ...
};

int main()
{
  Join* p1 = new Join();
  Der1* p2 = p1;
  Base* p3 = p1;

  p1->foo();
  p2->foo();
  p3->foo();
}
\end{lstlisting}
Output:
\begin{verbatim}
Der1::foo calling bar
Der2::bar called 
Der1::foo calling bar
Der2::bar called 
Der1::foo calling bar
Der2::bar called 
\end{verbatim}
Believe it or not, when Der1::foo() calls this-$>$bar(), it ends up calling Der2::bar().
Yes, that's right: a class that Der1 knows nothing about will supply the override of a virtual function invoked by Der1::foo().
This "cross delegation" can be a powerful technique for customizing the behavior of polymorphic classes. 
\paragraph{Delegating constructors, Since C++11}
%\url{https://thenewcpp.wordpress.com/2013/07/25/delegating-constructors/}
To delegate a constructor means that one constructor can call another to initialise the object.
When member object initialisation needed to be shared between constructors, or one constructor was the same as another but with some default arguments,
the only way to do this was to either duplicate code or call some common function.
Both have their problems, the first being that duplicated code is usually bad,
the second being that you throw out any initialisation list advantages that you might get by calling some common function in the body of the constructor.
Delegating constructors fixes this.

The syntax is quite simple, you simply call the constructor as the only item in an initialiser list.
For example, the default constructor delegates to the integer constructor with the argument 42.
\begin{lstlisting}
class C
{
  public:
      C(int) { }
      C() : C(42) { }
};
\end{lstlisting}
The standard specifies that if a constructor delegates to itself, the program is ill-formed. It also states that in that case no diagnostic is required.
Given this example right out of the standard
\begin{lstlisting}
class C
{
  public:
      C(int) { }
      C() : C(42) { }
      C(char) : C(42.0) { }
      C(double) : C('a') { }
};
 
int main()
{
  C c('b');
  return 0;
}
\end{lstlisting}
Clang complains with the following error
\begin{verbatim}
delegate.cpp:8:15: error: constructor for 'C' creates a delegation cycle [-Wdelegating-ctor-cycles]
  C(double) : C('a') { }
              ^
delegate.cpp:7:3: note: it delegates to
  C(char) : C(42.0) { }
  ^
delegate.cpp:8:3: note: which delegates to
  C(double) : C('a') { }
  ^
1 error generated.
\end{verbatim}
GCC issues no such error, and compiles. The resulting executable crashes with a stack overflow.
So be careful when you delegate constructors that you don’t create an infinite loop, because your compiler might not pick it up.

\chapter{Static Polymorphism}\label{stp}\mbox{}
\url{http://blog.aaronballman.com/2011/08/static-polymorphism-in-c/}
One of my coworkers recently asked me to help him solve a problem he was having in code.
He had a base class with several derived classes, and he wanted to add a static method to the base class, but have the derived classes determine the implementation.
Basically, he wanted virtual method dispatch semantics, while still using static method dispatching. Obviously he couldn’t just declare a static virtual function!

While there’s certainly more than one way to skin a cat in C++, I felt that a good answer would be to use CRTP — the Curiously Recurring Template Pattern.
Essentially, it’s a design pattern where the base class is a templated class, and the derived class is a template specialization, containing the derived class itself as the template parameter.
For instance:
\begin{lstlisting}
template< class Derived >
class Base 
{ 
};
 
class Derived1: public Base< Derived1 > { };
 
class Derived2 : public Base< Derived2 > { };
\end{lstlisting}

As you can see, each of the derived classes are a specialization of the Base class, but the template parameter is the derived class itself.

The problem that my coworker wanted to solve was: he wanted to call a method on the base class to determine whether an action was possible or not. 
However, the derived classes were ultimately responsible for determining whether the action was possible.
Also, at the call site, there were no instances of the class available. 
Ultimately, he wanted the Base class to have a method like:
\begin{lstlisting}
static bool CanPerformAction();
\end{lstlisting}

But he wanted the base classes to determine the outcome. When using the CRTP, the Base class has access to the derived type through the template parameter.
Due to the way templates work in C++, you can use one to call a static method. So the trick here is to use the template parameter to call a static method on the base classes.
\begin{lstlisting}
template< class Derived >
class Base {
public:
    static bool CanPerformAction() { return Derived::canPerformActionImpl(); }
};
 
class Derived1: public Base< Derived1 > {
    friend class Base< Derived1 >;
private:
    static bool canPerformActionImpl() { return true; }
};
 
class Derived2: public Base< Derived2 > {
    friend class Base< Derived2 >;
private:
    static bool canPerformActionImpl() { return false; }
};
\end{lstlisting}

You can then use the base class to perform static polymorphic function calls by using the template argument at the call site:
\begin{lstlisting}
if (Base< Derived1 >::CanPerformAction()) {
 
}
\end{lstlisting}

What happens is that Base::CanPerformAction has a template parameter of Derived1. 
So the canPerformActionImpl call will resolve to Derived1::canPerformActionImpl, which is exactly what’s wanted, without requiring a class instance.

Of course, you don’t have to use CRTP with static methods. You can do the same thing with instances as well. 
For instance, let’s say Base had the following method (Note that SomeFunction is not a virtual method!):
\begin{lstlisting}
void SomeFunction() {
  // What goes here if I want to call someFunctionImpl on a derived class?
}
\end{lstlisting}

You can use CRTP in this case as well by using static\_cast to cast the Base type to the derived type specified by the template parameter. Like this:
\begin{lstlisting}
static_cast< Derived * >( this )->someFunctionImpl();
\end{lstlisting}

So even though there’s not a virtual function involved, you still get polymorphic dispatching, just without the overhead of vtables.
This works because all of the dispatching can be determined at compile time instead of at runtime.

This isn’t a design pattern you’re likely to need very often, but you should be aware that it exists and is perfectly legal just so you don’t get surprised when you see it in the wild.

\chapter{CRTP and Static Polymorphism}\label{CRTP}\mbox{}
\url{http://karthikpresumes.blogspot.com/2011/10/curiously-recurring-template-pattern.html}
This is Curiously Recurring Template Pattern. Let us start this discussion with some minimal C++ classes, which doesn't convey any meaning but serves the purpose of discussion.
\begin{lstlisting}
class Base
{
public:
 void PrintMe() { std::cout << "Print: Base" << std::endl; }
};

class Derived : public Base
{
public:
 void PrintMe() { std::cout << "Print: Derived" << std::endl; }
};

void TestPolymorphism()
{
 Base *ptrBase = new Derived();
 ptrBase->PrintMe(); // This would print "Print: Base"
}
\end{lstlisting}

In the above code, ptrBase is initialized with an object of Derived. Ideally, PrintMe should have printed "Print: Derived".
But it would print "Print: Base". Any C++ programmer could identify the issue; early binding according to the type.
It means when we say, ptrBase-$>$PrintMe(), compiler would check whether the function called is virtual or not.
If it is not virtual, it would bound this call to the address of function defined in the calling type; In this case calling type is Base.

Dynamic binding can be achieved using "Virtual" specifier, in method declaration.
When we mark a function with Virtual, compiler wouldn't make early binding; it would resolve the same using V-Table.
Every class which has a virtual method, would have a table of function pointers.
And a hidden pointer for the table, will be inserted into the class and will be initialized during construction of objects of the class.
So, during a real method invocation on objects, two things would happen.
Getting the right function address from V-Table and calling the function pointed by the same.
Even though this extra indirection doesn't cause much performance degradation, in several scenarios this could be easily avoided.
Please find the snippet below, after adding virtual specifiers.

\begin{lstlisting}
class Base
{
public:
 virtual void PrintMe() { std::cout << "Print: Base" << std::endl; }
};

class Derived : public Base
{
public:
 virtual void PrintMe() { std::cout << "Print: Derived" << std::endl; }
};

void TestPolymorphism()
{
 Base *ptrBase = new Derived();
 ptrBase->PrintMe(); // This would print "Print: Derived"
}
\end{lstlisting}

As we discussed early, even though dynamic polymorphism doesn't cause much performance overhead, it would make a function not "in-line"able.
Sometimes, in-lining a simple function would improve performance especially if it is being called several times in code.
Since normal function call breaks code execution flow, CPU level, caching like optimizations, are not possible.
\textit{With static polymorphism, we could achieve the in-lining capability.} Now let us get into the topic of Static polymorphism.

Let us try to make Base class function a bit intelligent.

In Base class, if we could cast the "this" pointer's type to the right Derived class, we could be able to solve the issue of Dynamic binding; Means avoiding Virtual specifier.

The below code snippet won't compile, but it gives the idea of what to do.
\begin{verbatim}
class Base
{
public:
 void PrintMe()
 {
  static_cast<Derived*>(this)->PrintMe(); // This would call "Print: Derived"
 }
};
\end{verbatim}

We had successfully removed Virtual Keyword; So, V-Table wouldn't be created and function can be in-lined.
There are some problems; First off, it wouldn't compile, as compiler doesn't know the Derived class yet.
Secondly, this is specialized for only one derived class. This specialization can be removed with templates. Yes. that is the whole idea.

\begin{verbatim}
template<typename Derived>
class Base
{
public:
 void PrintMe()
 {
  static_cast<Derived*>(this)->PrintMe(); // This would call "Print: Derived"
 }
};
\end{verbatim}

Now, you could derive classes from the above class like this,

\begin{verbatim}
class Derived : public Base<Derived>{ };
\end{verbatim}

Deriving from template classes, specialized with the same Derived class type, is called as CRTP, curiously recurring template pattern.
Even though the above example is very minimalistic, there are several uses for this pattern.
One of the great examples, as given by Wikipedia is \textit{Counter base class.}
In order to get the statistics of objects of a particular type, we can implement a Counter class as below.

\begin{lstlisting}
template<typename T>
class Counter
{
  public:
      static int GetTotalObjectsCreated() { return nObjectsCreated; }
  protected:
      Counter() { nObjectsCreated++;}
      ~Counter() { nObjectsCreated--; }
  private:
      static int nObjectsCreated;
};

template<T>
int Counter<T>::nObjectsCreated = 0;
\end{lstlisting}

Let us assume we need to get the number of objects created for a particular type, Test. Derive Test from Counter, specialized with Test itself.

\begin{verbatim}
Class Test : private Counter<Test>{ };
  // Private derivation is to show that it is not 'is a' relationship.
\end{verbatim}
Now at any point of time, in program execution, we could get the number of objects alive using the call like this.

\begin{verbatim}
int nObjects = Counter<Test>::GetTotalObjectsCreated();
\end{verbatim}

CRTP is cool and positive side effect of Code replication based generics mechanism, unlike Java and .NET. 

Second article:
\url{https://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c}

C++ provides pretty good support for polymorphism by means of virtual functions. 
This is dynamic polymorphism (or runtime polymorphism), since the actual function to be called is resolved at runtime. 
It's usually implemented by adding a hidden pointer in every object of a class with virtual functions. 
The pointer will point for any given object at the actual functions to call for it, so even when the compiler only knows this object through a pointer to a base class, it can generate correct code.

The problem with dynamic polymorphism is its runtime cost. This usually consists of the following components [1]:

    Extra indirection (pointer dereference) for each call to a virtual method.
    Virtual methods usually can't be inlined, which may be a significant cost hit for some small methods.
    Additional pointer per object. On 64-bit systems which are prevalent these days, this is 8 bytes per object. For small objects that carry little data this may be a serious overhead.

Although in general dynamic polymorphism is a great tool, due to the aforementioned costs some applications prefer not to use it, at least for some performance-critical classes. 

So what is the alterantive?

It turns out that using templates, C++ provides an alternative way to implement polymorphism without the extra costs.
There's a catch, of course - the types of objects have to be resolvable by the compiler at compile-time. This is called static polymorphism (or "simulated dynamic binding").

Here's the simplest code sample I could come up with that demonstrates the technique:

\begin{lstlisting}
template <typename Child>
struct Base
{
    void interface()
    {
        static_cast<Child*>(this)->implementation();//call member function in derived class
    }
};

struct Derived : Base<Derived>
{
    void implementation()
    {
        cerr << "Derived implementation\n";
    }
};

int main()
{
    Derived d;//define Derived object
    d.interface();  // Prints "Derived implementation"
}
\end{lstlisting}

The key to the technique is the strange template trickery that's being used: note that Derived inherits from Base<Derived>. 
What gives? The idea is to ``inject'' the real type of the derived class into the base, at compile time, allowing the static\_cast of this in the interface to produce the desired result. 
This technique has a name - it's called Curiously Recurring Template Pattern (CRTP from now on).

Synthetic examples are prone to not being exciting, and this one is no exception. 
Why not just implement interface in Derived, if its type is known at compile-time anyway, you may ask. 
This is a good question, which is why I plan to provide more examples to show how CRTP is useful.

The following example is much longer - although it is also a simplification. It presents a generic base class for visiting binary trees in various orders. 
This base class can be inherited to specify special handling of some types of nodes. 
Here is the tree node definition and the base class:
\begin{lstlisting}
struct TreeNode
{
    enum Kind {RED, BLUE};

    TreeNode(Kind kind_, TreeNode* left_ = NULL, TreeNode* right_ = NULL)
        : kind(kind_), left(left_), right(right_)
    {}

    Kind kind;
    TreeNode *left, *right;
};

template <typename Derived>
class GenericVisitor
{
public:
    void visit_preorder(TreeNode* node)
    {
        if (node) {
            dispatch_node(node);
            visit_preorder(node->left);
            visit_preorder(node->right);
        }
    }

    void visit_inorder(TreeNode* node)
    {
        if (node) {
            visit_inorder(node->left);
            dispatch_node(node);
            visit_inorder(node->right);
        }
    }

    void visit_postorder(TreeNode* node)
    {
        if (node) {
            visit_postorder(node->left);
            visit_postorder(node->right);
            dispatch_node(node);
        }
    }

    void handle_RED(TreeNode* node) { cerr << "Generic handle RED\n"; }

    void handle_BLUE(TreeNode* node) { cerr << "Generic handle BLUE\n"; }

private:
    Derived& derived() // Convenience method for CRTP
    {
        return *static_cast<Derived*>(this);
    }

    void dispatch_node(TreeNode* node)
    {
        switch (node->kind) {
            case TreeNode::RED:
                derived().handle_RED(node);
                break;
            case TreeNode::BLUE:
                derived().handle_BLUE(node);
                break;
            default:
                assert(0);
        }
    }
};
\end{lstlisting}

And a simple derived class:

\begin{lstlisting}
class SpecialVisitor : public GenericVisitor<SpecialVisitor>
{
public:
    void handle_RED(TreeNode* node) { cerr << "RED is special\n"; }
};
\end{lstlisting}

Now you can easily implement special handling of various kinds of nodes in subclasses, and use visiting services provided by the base class.

To reiterate - this is a simplified example, as there are only two kinds of nodes, but in reality there can be many more. 
Such code would be quite useful inside compilers, where the source is usually parsed into a tree with many different kinds of nodes. 
Multiple passes in the compiler then process the trees by implementing their own visitors. 
As a matter of fact, the Clang compiler frontend has such a class, named RecursiveASTVisitor, which implements a much more complete version of the visitor displayed above.

Without CRTP, there's no way to implement such functionality except resorting to dynamic polymorphism and virtual functions [2].

Another interesting example is the following:

\begin{lstlisting}
template <typename Derived>
struct Comparisons
{
};

template <typename Derived>
bool operator==(const Comparisons<Derived>& o1, const Comparisons<Derived>& o2)
{
    const Derived& d1 = static_cast<const Derived&>(o1);
    const Derived& d2 = static_cast<const Derived&>(o2);

    return !(d1 < d2) && !(d2 < d1);
}

template <typename Derived>
bool operator!=(const Comparisons<Derived>& o1, const Comparisons<Derived>& o2)
{
    return !(o1 == o2);
}
\end{lstlisting}

This is a generic base class with some external comparison functions that act on it. 
What this makes possible is to create a derived class that only defines the < operator, making other comparison operators (== and != here, but others are trivial to add) possible.
Here's a sample derived class:

\begin{lstlisting}
class Person : public Comparisons<Person>
{
public:
    Person(string name_, unsigned age_)
        : name(name_), age(age_)
    {}

    friend bool operator<(const Person& p1, const Person& p2);
private:
    string name;
    unsigned age;
};


bool operator<(const Person& p1, const Person& p2)
{
    return p1.age < p2.age;
}
\end{lstlisting}

Again, this is using CRTP to implement something that could only be possible with virtual functions had we wanted dynamic polymorphism. 
Sometimes a class like Comparisons above is called a mixin class:

    In object-oriented programming languages, a mixin is a class that provides a certain functionality to be inherited or just reused by a subclass, 
    while not meant for instantiation (the generation of objects of that class). 
    Inheriting from a mixin is not a form of specialization but is rather a means of collecting functionality. 
    A class may inherit most or all of its functionality from one or more mixins through multiple inheritance.

So how often is CRTP used in "real life"? I don't have any actual usage statistics, but it appears that this is a useful tool in a C++ programmer's toolbox. 
The RecursiveASTVisitor class from Clang I mentioned above is a very real use case. 
Clang's parent project LLVM uses CRTP in at least another place (the HeuristicBase class in the code generator module).

Boost also uses CRTP for its Iterator Facade:

    iterator\_facade is a base class template that implements the interface of standard iterators in terms of a few core functions and associated types, to be supplied by a derived iterator class.

And finally, Microsoft's Active Template Library (ATL) uses CRTP comprehensively. See, for example, the CWindowImpl template.
[1]	I have no intention of providing a comprehensive analysis of the cost here. 
    This is a well-defined topic and a lot of information can be learned by googling "c++ virtual call cost".
[2]	You may wonder why this is so. Can't GenericVisitor be a simple class, without the Derived templating? Absolutely not. 
    Had dispatch\_node just called handle\_RED for red nodes, this would always call GenericVisitor::handle\_RED, and never the handle\_RED of the derived class. 
    Keep in mind that the code of dispatch\_node is generated statically at compile-time, and the only handle\_RED the compiler is familiar with at that point is GenericVisitor's, 
    unless of course it's virtual, or CRTP is used.




\chapter{Dynamic instantiation}\label{DI}
\url{http://karthikpresumes.blogspot.com/2011/10/prototype-pattern-in-c-dynamic.html}

\url{http://www.cs.sjsu.edu/~pearce/modules/lectures/oop/types/reflection/prototype.htm}
Before starting the discussion of Prototype pattern~\ref{PrototypePattern}, We will understand the problem of Dynamic Instantiation (DI).

\textit{Given a typename ( a class name ) in C++ as a string, how an object can be created of that type?}

First off, there is no language level support for dynamic instantiation in C++ unlike Java and C\#.
Since in C++, there is no common base class for all classes, dynamic instantiation support is generally not possible.
MFC, a C++ framework provides support for Dynamic instantiation as all classed are derived from CObject.
Let us try in the same line, making use of common base and Prototype pattern to achieve Dynamic instantiation.

Prototype pattern imposes a class to have a method,\textbf{Clone}, whose sole purpose is to generate a new object of same type.
With a clone-able object, we could be able to generate a new object of same type.
In order to achieve this, all classes must be derived from a common base class. And in that common base class, we can have a pure virtual member function(interface), Clone.
So, all classes derived from that, would be clone-able.

Let us call that common base class ``Object'' as in Java. My minimalistic implementation of the ``Object'' is as given here,
\begin{verbatim}
class Object
{
  public:
     virtual ~Object() {}
     virtual Object* Clone() const = 0;
     static Object *MakeObject(std::string type);
     static void AddNewClassInfo(std::string type, Object* in);
     static std::map objectsTable;
};
\end{verbatim}

Clone is the key method of this abstract class. Implementation of the same could be like the one given below.

\begin{verbatim}
class Derived : public Object
{
    Object *Clone() { new Derived(); }
};
\end{verbatim}

So, all the classes derived from Object can be cloned using this method call.
In order to "Clone" an object, we should have one initial object, prototypical instance and we should be able to get that base prototypical instance from the type name.
If we could be able to do this, then Making an object using type-name alone is a cake-walk.
"objectsTable" map in Object class holds the aforesaid mapping; a map of type-name and a prototypical instance.

Adding a prototypical instance can be done through the method, "AddNewClassInfo", whose implementation can be like this.

\begin{verbatim}
// Populate map with type-name and its corresponding prototype.
void Object::AddNewClassInfo(std::string type, Object *in)
{
     objectsTable[type] = in;
}
\end{verbatim}

Now the implementation of "MakeObject" must be easily understandable.

\begin{verbatim}
Object* Object::MakeObject(std::string type)
{
 std::map::iterator itr;
 itr = objectsTable.find(type);
 if( itr != objectsTable.end())
 {
    return itr->second->Clone(); // Clone the prototypical instance.
 }
 else
    return NULL;
}
\end{verbatim}

All the essential implementations of "Object" is done. Since it has a static member, it should be defined in CPP file as given here,

\begin{verbatim}
std::map Object::objectsTable;
\end{verbatim}

OK. Now let us create a derived class from Object and test this implementation.

\begin{lstlisting}[caption={Prototype Pattern sample DI},language=C++]
#include "Object.h"

class DynamicInstantiable : public Object
{
  public:
     DynamicInstantiable() {}
     void SayHello()
     {
       std::cout << "Hello! " << std::endl;
     }
    
     Object* Clone() const
     {
       return new DynamicInstantiable();
     }
};
\end{lstlisting}

The above class has the implementation for Clone method and is derived from Object.
Now, this type must be added in Static Map in "Object" class using ``Object::AddNewClassInfo''.
We have several options here. But I would like to keep things simple.
So, I have added a new header file which has a global function ``InitializeDynamicObjects''.
And this method must be called in ``main()'' function in the very first line itself.

A sample implementation is given below.
\begin{verbatim}
void InitializeDynamicObjects()
{
 Object::AddNewClassInfo("DynamicInstantiable", new DynamicInstantiable());
}
\end{verbatim}

Here is the sample Main function, I have written to test the code.

\begin{lstlisting}[caption={Prototype Pattern sample DI},language=C++]
#include "DynamicInstantiable.h"
#include "ObjectInitializer.h"
using namespace std;

int main()
{
     InitializeDynamicObjects();

    DynamicInstantiable* newInst = dynamic_cast(Object::MakeObject("DynamicInstantiable"));

     if( newInst != NULL)
     {
           newInst->SayHello();
     }

     cout << "Hello World" << endl;
}
\end{lstlisting}


\part{Design patterns}
%\section{Design patterns}
Here we start our journey.
In the book of GOF, Design patterns are cataloged into ``Behavioral Patterns'', ``Creational Patterns'' and ``Structural Patterns''. 
This following contents are collected from online articles to ease headache.
\subpart{Behavioral Patterns}
In software engineering, behavioral design patterns are design patterns that identify common communication patterns between \textbf{objects} and realize these patterns.
By doing so, these patterns increase flexibility in carrying out this communication.
\chapter{Visitor Pattern}\label{VisitorPattern}

\paragraph{Intent}\mbox{}
Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.

    The classic technique for recovering lost type information.

    Do the right thing based on the type of two objects.

    Double dispatch~\ref{dd}

\paragraph{In plain words}
    Visitor pattern lets you add further operations to objects without having to modify them.
The visitor pattern is to solve ``double dispatch'' issue~\ref{dd}(or see "multiple dispatch"~\ref{multid}).
\paragraph{Wikipedia says}
  In object-oriented programming and software engineering, the visitor design pattern is a way of \textbf{separating an algorithm from an object structure on which it operates}. 
  A practical result of this separation is the ability to add new operations to existing object structures without modifying those structures. 
  It is one way to follow the open/closed principle~\ref{OCP}.
%https://segmentfault.com/a/1190000010706695#articleHeader25
%https://github.com/kamranahmedse/design-patterns-for-humans#-visitor

%https://lostechies.com/derekgreer/2010/04/19/double-dispatch-is-a-code-smell/
%\paragraph{Real world example 1}
    %Consider someone visiting Dubai. They just need a way (i.e., visa) to enter Dubai.
    %After arrival, they can visit any place in Dubai on their own without having to ask for permission.% or to do some leg work in order to visit any place here;
    %just let them know of a place and they can visit it. Visitor pattern lets you do just that, 
    %it helps you add places to visit so that they can visit as much as they can.% without having to do any legwork.
%\paragraph{Real world example 2}
%Consider customer visiting Banks, usually one Bank have multiple tellers (counters/officers) and customer can get help from any one of the tellers. 
%Tellers do not need to change, but customer can have any different business as Visitors.
%\paragraph{Real world example 3}
%Consider operations on ``elements (such as Node (leafnode, internalnode))'' of a tree structure. We don't have to implement functions inside of elements, instead we define the Visitor to 
%have this functions.
\paragraph{Real world example 1}
During the process of implementing compiler and parser, we need to travel the syntax tree structure to complete some operations, for example, to generate object code. All syntax classes inherited 
from the same base class, but each operation of every derived syntax class is different, such as the methods to generate ``if'' and ``while'', plus these operations require expansibility.
\paragraph{may discard this - Real world example 2 (from Wikipedia)}
%https://en.wikipedia.org/wiki/Visitor_pattern
Consider the design of a 2D computer-aided design (CAD) system.
At its core there are several types to represent basic geometric shapes like circles, lines, and arcs.
The entities are ordered into layers, and at the top of the type hierarchy is the drawing, which is simply a list of layers, plus some added properties.

A fundamental operation on this type hierarchy is saving a drawing to the system's native file format.
At first glance it may seem acceptable to add local save methods to all types in the hierarchy. 
But it is also useful to be able to save drawings to other file formats. 
Adding ever more methods for saving into many different file formats soon clutters the relatively pure original geometric data structure.

A naive way to solve this would be to maintain separate functions for each file format.
Such a save function would take a drawing as input, traverse it, and encode into that specific file format.
As this is done for each added different format, duplication between the functions accumulates. 
For example, saving a circle shape in a raster format requires very similar code no matter what specific raster form is used, and is different from other primitive shapes.
The case for other primitive shapes like lines and polygons is similar. 
Thus, the code becomes a large outer loop traversing through the objects, with a large decision tree inside the loop querying the type of the object.
Another problem with this approach is that it is very easy to miss a shape in one or more savers,
or a new primitive shape is introduced, but the save routine is implemented only for one file type and not others, leading to code extension and maintenance problems.

Instead, the Visitor pattern can be applied. 
It encodes a logical operation on the whole hierarchy into one class containing one method per type.
In the CAD example, each save function would be implemented as a separate Visitor subclass.
This would remove all duplication of type checks and traversal steps. It would also make the compiler complain if a shape is omitted.

Another motive is to reuse iteration code. 
For example, iterating over a directory structure could be implemented with a visitor pattern. 
This would allow creating file searches, file backups, directory removal, etc., by implementing a visitor for each function while reusing the iteration code.
\paragraph{Exmaple 3}
The Visitor pattern represents an operation to be performed on the elements of an object structure without changing the classes on which it operates.
This pattern can be observed in the operation of a taxi company. When a person calls a taxi company (accepting a visitor), the company dispatches a cab to the customer.
Upon entering the taxi the customer, or Visitor, is no longer in control of his or her own transportation, the taxi (driver) is.
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/visitorpexa6.PNG}}{\caption{Visitor}\label{visitorp}}
\end{floatrow}
\end{figure}
\paragraph{example code 1}
Let's take a look the example code :
\begin{lstlisting}[caption={visitor pattern sample code 1},label={lst:vps1},language=C++]
class AnimalOperation;

class Animal { // visitee
    public:
         virtual void Accept(AnimalOperation& operation) = 0;
};

class Monkey;
class Lion;
class Dolphin;

class AnimalOperation { // visitor
    public:
        virtual void visitMonkey(Monkey& monkey) = 0;
        virtual void visitLion(Lion& lion) = 0;
        virtual void visitDolphin(Dolphin& dolphin) = 0;
};

class Monkey : public Animal {
public:
    void Shout() { std::cout << "Ooh oo aa aa!" << std::endl; }
    void Accept(AnimalOperation& operation) { operation.visitMonkey(*this); }
};

class Lion : public Animal {
public:
    void Roar() { std::cout << "Roaaar!" << std::endl; }
    void Accept(AnimalOperation& operation) { operation.visitLion(*this); }
};

class Dolphin : public Animal {
public:
    void Speak() { std::cout << "Tuut tuttu tuutt!" << std::endl; }
    void Accept(AnimalOperation& operation) { operation.visitDolphin(*this); }
};

class Speak : public AnimalOperation {
public:
    void visitMonkey(Monkey& monkey) { monkey.Shout(); }
    void visitLion(Lion& lion) { lion.Roar(); }
    void visitDolphin(Dolphin& dolphin) { dolphin.Speak(); }
};

int main()
{
    Monkey monkey;
    Lion lion;
    Dolphin dolphin;

    Speak speak;
    monkey.Accept(speak);
    lion.Accept(speak);
    dolphin.Accept(speak);
}
\end{lstlisting}
\bclampe{We could have done this simply by having an inheritance hierarchy for the animals but then we would have to modify the animals whenever we would have to add new actions to animals.
But now we will not have to change them.} For example, let's say we are asked to add the jump behavior to the animals, we can simply add that by creating a new visitor i.e.
\paragraph{Discussion:}




\begin{lstlisting}[caption={visitor pattern sample code 1-2},label={lst:vps2},language=C++]
class Jump : public AnimalOperation
{
    public:
      void visitMonkey(Monkey &monkey) {echo 'Jumped 20 feet high! on to the tree!'; }
      void visitLion(Lion &lion) {echo 'Jumped 7 feet! Back on the ground!'; }
      void visitDolphin(Dolphin &dolphin) {echo 'Walked on water a little and disappeared'; }
};
\end{lstlisting}

And for the usage,

\begin{lstlisting}[caption={visitor pattern sample code 1-3},label={lst:vps1},language=C++]
jump = new Jump();

monkey->accept(speak);   // Ooh oo aa aa!
monkey->accept(jump);    // Jumped 20 feet high! on to the tree!

lion->accept(speak);     // Roaaar!
lion->accept(jump);      // Jumped 7 feet! Back on the ground!

dolphin->accept(speak);  // Tuut tutt tuutt!
dolphin->accept(jump);   // Walked on water a little and disappeared
\end{lstlisting}
\paragraph{More Discussion}

Visitor's primary purpose is to abstract functionality that can be applied to an aggregate hierarchy of ``element objects.
The approach encourages designing lightweight Element classes - because processing functionality is removed from their list of responsibilities.
New functionality can easily be added to the original inheritance hierarchy by creating a new Visitor subclass.

Visitor implements "double dispatch". OO messages routinely manifest "single dispatch" - the operation that is executed depends on: the name of the request, and the type of the receiver.
In "double dispatch", the operation executed depends on: the name of the request, and the type of TWO receivers (the type of the Visitor and the type of the element it visits).

The implementation proceeds as follows. 

Create a Visitor class hierarchy that defines a pure virtual visit() method in the abstract base class for each concrete derived class in the aggregate node hierarchy.
Each visit() method accepts a single argument - a pointer or reference to an original Element derived class.

Each operation to be supported is modelled with a concrete derived class of the Visitor hierarchy.
The visit() methods declared in the Visitor base class are now defined in each derived subclass by allocating the "type query and cast" code
in the original implementation to the appropriate overloaded visit() method.

Add a single pure virtual accept() method to the base class of the Element hierarchy.
accept() is defined to receive a single argument - a pointer or reference to the abstract base class of the Visitor hierarchy.

Each concrete derived class of the Element hierarchy implements the accept() method by simply calling the visit() method on the concrete 
derived instance of the Visitor hierarchy that it was passed, passing its "this" pointer as the sole argument.

Everything for "elements" and "visitors" is now set-up. When the client needs an operation to be performed, (s)he creates an instance of the Visitor object,
calls the accept() method on each Element object, and passes the Visitor object.

The accept() method causes flow of control to find the correct Element subclass.
Then when the visit() method is invoked, flow of control is vectored to the correct Visitor subclass.\textit{accept() dispatch plus visit() dispatch equals double dispatch.}

The Visitor pattern makes adding new operations (or utilities) easy - simply add a new Visitor derived class.
But, if the subclasses in the aggregate node hierarchy are not stable, keeping the Visitor subclasses in sync requires a prohibitive amount of effort.

An acknowledged objection to the Visitor pattern is that is represents a regression to functional decomposition - separate the algorithms from the data structures.
While this is a legitimate interpretation, perhaps a better perspective/rationale is the goal of promoting non-traditional behavior to full object status.

\paragraph{Structure}
The Element hierarchy is instrumented with a ``universal method adapter''.
The implementation of accept() in each Element derived class is always the same.
But – it cannot be moved to the Element base class and inherited by all derived classes because a reference to this in the Element class always maps to the base type Element.
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/visitorps1.PNG}}{\caption{Visitor structure 1}\label{visitorp2}}
\end{floatrow}
\end{figure}
When the polymorphic firstDispatch() method is called on an abstract First object, the concrete type of that object is "recovered".
When the polymorphic secondDispatch() method is called on an abstract Second object, its concrete type is "recovered".
The application functionality appropriate for this pair of types can now be exercised.
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/visitorps2.PNG}}{\caption{Visitor structure 2}\label{visitorp3}}
\end{floatrow}
\end{figure}
\paragraph{Exmaple}\mbox{}
1.    Add an accept(Visitor) method to the "element" hierarchy

2.    Create a "visitor" base class with a visit() method for every "element" type

3.    Create a "visitor" derived class for each "operation" to do on "elements"

4.    Client creates "visitor" objects and passes each to accept() calls
\begin{lstlisting}[caption={visitor pattern sample code},label={lst:vps23},language=C++]
#include <iostream>
#include <string>
using namespace std;

class Element // 1. Add an accept(Visitor) method to the "element" hierarchy
{
  public:
    virtual void accept(class Visitor &v) = 0;
};

class This: public Element
{
  public:
     /*virtual*/void accept(Visitor &v);
    string this() { return "This"; }
};

class That: public Element
{
  public:
     /*virtual*/void accept(Visitor &v);
    string that() { return "That"; }
};

class TheOther: public Element
{
  public:
     /*virtual*/void accept(Visitor &v);
    string theOther() { return "TheOther"; }
};

class Visitor//2.Create a "visitor" base class with a visit() method for every "element" type
{
  public:
    virtual void visit(This *e) = 0;
    virtual void visit(That *e) = 0;
    virtual void visit(TheOther *e) = 0;
};

 /*virtual*/void This::accept(Visitor &v) { v.visit(this); }
 /*virtual*/void That::accept(Visitor &v) { v.visit(this); }
 /*virtual*/void TheOther::accept(Visitor &v) { v.visit(this); }

// 3. Create a "visitor" derived class for each "operation" to do on "elements"
class UpVisitor: public Visitor
{
     /*virtual*/void visit(This *e) { cout << "do Up on " + e->thiss() << '\n'; }
     /*virtual*/void visit(That *e) { cout << "do Up on " + e->that() << '\n'; }
     /*virtual*/void visit(TheOther *e) { cout << "do Up on " + e->theOther() << '\n';}
};

class DownVisitor: public Visitor
{
     /*virtual*/void visit(This *e) { cout << "do Down on " + e->thiss() << '\n'; }
     /*virtual*/void visit(That *e) { cout << "do Down on " + e->that() << '\n'; }
     /*virtual*/void visit(TheOther *e) { cout << "do Down on " + e->theOther() << '\n'; }
};

int main()
{
  Element *list[] = { new This(), new That(), new TheOther() };
  UpVisitor up; // 4. Client creates
  DownVisitor down; //    "visitor" objects
  for (int i = 0; i < 3; i++)
    list[i]->accept(up); //    and passes each
  for (i = 0; i < 3; i++) //    to accept() calls
    list[i]->accept(down);
}
\end{lstlisting}
Output
\begin{verbatim}
do Up on This                do Down on This
do Up on That                do Down on That
do Up on TheOther            do Down on TheOther
\end{verbatim}
\paragraph{exmaple 2}\mbox{}
\begin{lstlisting}[caption={visitor pattern sample code 2},language=C++]
class LeafNode;
class InternalNode;

class Visitor
{
public:
    virtual ~Visitor(){}
    virtual void visit(const LeafNode&)  = 0;
    virtual void visit(const InternalNode&)  = 0;
};

class PrintVisitor:public Visitor
{
public:
    void visit(const LeafNode&) { cout << "visiting a leafnode " << endl; }
    void visit(const InternalNode&) { cout << "visiting an internal node" << endl; }
};

class Node
{
public:
    virtual ~Node(){}
    virtual void accept(Visitor& v) = 0;
};

class LeafNode:public Node
{
public:
    void accept(Visitor& v) { v.visit(*this); }
};

class InternalNode :public Node
{
public:
    void accept(Visitor& v)
    {
        v.visit(*this);
        for (const auto& elem : _data)
            elem->accept(v);
    }
    void add(Node* pn) { _data.push_back(pn); }
private:
    vector<Node*> _data;
};
\end{lstlisting}

\begin{CJK}{UTF8}{gbsn}
“双分派”：就是 Visit函数中以Element为参数，而Accept函数以Visitor为参数.

  本质是注入-回调模式. ``Visa''是一种注入, 允许你回调 visit; ``告诉地点''是一种注入, 允许去具体地点回调 visit.
  从示例代码看, 也能看出两层注入回调的意思: 首先是针对接口的注入回调, 通过 Accept 注入动物行为, 然后回调各个 visit 方法, 在回调的同时, 又将自身注入(此刻已经是针对具体对象了), 然后再回调具体的动物行为方法.

  为什么要这样绕来绕去, 来来回回的呢?
  那是因为访问者是一种维护模式. 试想, 既有代码已经存在 Animal 和其三个派生类了, 以及各自嚎叫的方法.
  现在我想用一个统一的接口, 去迭代的调用这些方法(假想三个对象都在一个 vector 中, 你迭代的时候无法用各自不同的接口). 那么就需要访问者上场了. 
  首先在 Animal 类中增加接口 Accept, 留出注入的口子. 然后派生类重写该接口, 并借此将自身注入. 
  最后将这些方法抽象成一个接口类, 并增加相应的 visit 方法. 派生该接口类, 将具体的方法一一绑定(就是在绑定回调). 然后我们一旦调用 Accept, 各自嚎叫的方法就会自然被回调到了.

  综上, 访问者模式, 是一种对调用的抽象, 依靠回调来实现.

双向分派:
双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别（Run time type），还要根据参数的运行时区别。
首先在客户程序中将具体访问者作为参数传递给具体元素,这便完成了一次分派。
进入具体元素后，具体元素调用作为参数的具体访问者中的visit方法，同时将自己（this）作为参数传递进去。
    具体访问者再根据参数的不同来选择方法来执行。这便完成了第二次分派。

\end{CJK}

\begin{CJK}{UTF8}{gbsn}
访问者模式有如下的缺点：

1，增加新的节点类变得很困难。每增加一个新的节点都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作。

2，破坏封装。访问者模式要求访问者对象访问并调用每一个节点对象的操作，这隐含了一个对所有节点对象的要求：它们必须暴露一些自己的操作和内部状态。
    不然，访问者的访问就变得没有意义。由于访问者对象自己会积累访问操作所需的状态，从而使这些状态不再存储在节点对象中，这也是破坏封装的。

1. 增加新的 ConcreteElement类很困难 
Visitor模式使得难以增加新的 Element的子类。每 添加一个新的 ConcreteElement都要在 Vistor中添加一个新的抽象操作,并在每一个 ConcretVisitor类中实现相应的操作。
    有时可以在 Visitor中提供一个缺省的实现,这一实现可 以被大多数的 ConcreteVisitor继承,但这与其说是一个规律还不如说是一种例外。 

所以在应用访问者模式时考虑关键的问题是系统的哪个部分会经常变化,是作用于对象结构上的算法呢还是构成该结构的各个对象的类。
    如果老是有新的 ConcretElement类加入进来的话, Vistor类层次将变得难以维护。在这种情况下,直接在构成该结构的类中定义这些操作可能更容易一些。
    如果 Element类层次是稳定的,而你不断地增加操作获修改算法,访问者模式可以帮助你管理这些改动。 

2. 破坏封装 
访问者方法假定ConcreteElement接口的功能足够强,足以让访问者进行它 们的工作。结果是,该模式常常迫使你提供访问元素内部状态的公共操作,这可能会破坏它 的封装性。 

\end{CJK}

\begin{CJK}{UTF8}{gbsn}
适用场景
0. 在这种地方你一定要考虑使用访问者模式：业务规则要求遍历多个不同的对象。这本身也是访问者模式出发点，
    迭代器模式只能访问同类或同接口的数据（当然了，如果你使用instanceof，那么能访问所有的数据，这没有争论），
    而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作，也就是针对访问的对象不同，执行不同的操作。
1. 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
2.假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。
3.当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。
4.定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。
    如果对象结构类经常改变，元素类数目不确定的情况下，应该慎用访问者模式。
\end{CJK}
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/visitorpex7.PNG}}{\caption{Visitor structure example}\label{visitorp7}}
\end{floatrow}
\end{figure}

\begin{CJK}{UTF8}{gbsn}
生活中的例子
一台电脑由很多部件组成，有显示屏、主机、键盘、鼠标等外设。不同身份的人对这台电脑的部件会有不同的操作。
    消费者可能就是简单地看看各个部件的价格、商标、参数。维修员则会对部件进行检查。
在这里，消费者和维修员就是具体访问者角色，显示屏、主机、键盘、鼠标等就是具体节点角色，电脑这一个整体就是结构对象角色。
此处用访问者模式，代码如下：
\end{CJK}
\begin{lstlisting}[caption={visitor pattern sample code},label={lst:vps22},language=C++]

// abstract interface Part.h
#ifndef VISITORDEMO_PART_H
#define VISITORDEMO_PART_H
class Visitor;
class Part{
public:
    virtual void accept(Visitor *visitor) = 0;
};
#endif //VISITORDEMO_PART_H

// concrete class, Monitor.h
#ifndef VISITORDEMO_MONITOR_H
#define VISITORDEMO_MONITOR_H
#include "Part.h"
#include "Visitor.h"
#include <iostream>
using namespace std;
class Monitor: public Part {
private:
    string brand;
    float price;
public:
    Monitor(string brand,float price);
    void accept(Visitor *visitor) override ;
    string getBrand();
    float getPrice();
};
#endif //VISITORDEMO_MONITOR_H

//Monitor.cpp
#include "../header/Monitor.h"
Monitor::Monitor(string brand, float price) {
    this->brand = brand;
    this->price = price;
}
void Monitor::accept(Visitor *visitor) {
    visitor->visit(this);
}
string Monitor::getBrand() {
    return brand;
}
float Monitor::getPrice() {
    return price;
}

// concrete class, Mainframe.h
#ifndef VISITORDEMO_MAINFRAME_H
#define VISITORDEMO_MAINFRAME_H
#include "Part.h"
#include "Visitor.h"
#include <iostream>
using namespace std;
class Mainframe: public Part {
private:
    string brand;
    float price;
public:
    Mainframe(string brand, float price);
    void accept(Visitor *visitor) override ;
    string getBrand();
    float getPrice();
};
#endif //VISITORDEMO_MAINFRAME_H

//Mainframe.cpp
#include "../header/Mainframe.h"
Mainframe::Mainframe(string brand, float price) {
    this->brand = brand;
    this->price = price;
}
void Mainframe::accept(Visitor *visitor) {
    visitor->visit(this);
}
string Mainframe::getBrand() {
    return brand;
}
float Mainframe::getPrice() {
    return price;
}

// abstract Visitor, Visitor.h
#ifndef VISITORDEMO_VISITOR_H
#define VISITORDEMO_VISITOR_H
class Monitor;
class Mainframe;
class Visitor{
public:
    virtual void visit(Monitor *monitor) {}
    virtual void visit(Mainframe *mainframe) {}
};
#endif //VISITORDEMO_VISITOR_H

// concrete visitor, Consumer.h
#ifndef VISITORDEMO_CONSUMER_H
#define VISITORDEMO_CONSUMER_H
#include "Visitor.h"
#include "Monitor.h"
#include "Mainframe.h"
class Consumer: public Visitor {
private:
    float sum;
public:
    void visit(Monitor *monitor) override ;
    void visit(Mainframe *mainframe) override ;
    float getSum();
};
#endif //VISITORDEMO_CONSUMER_H

//Consumer.cpp
#include "../header/Consumer.h"
void Consumer::visit(Monitor *monitor) {
    sum += monitor->getPrice();
    cout<<"Consumer visited monitor, brand is:"<<monitor->getBrand()<<",cost is:"<<monitor->getPrice()<<endl;
}
void Consumer::visit(Mainframe *mainframe) {
    sum += mainframe->getPrice();
    cout<<"Consumer visited mainframe, brand is :"<<mainframe->getBrand()<<",cost is:"<<mainframe->getPrice()<<endl;
}
float Consumer::getSum() {
    cout<<"consumer computed the cost of Computer is :"<<sum<<endl;
}
// concrete visitor, Repairman.h
#ifndef VISITORDEMO_REPAIRMAN_H
#define VISITORDEMO_REPAIRMAN_H
#include "Visitor.h"
#include "Monitor.h"
#include "Mainframe.h"
class Repairman: public Visitor {
public:
    void visit(Monitor *monitor) override ;
    void visit(Mainframe *mainframe) override ;
};
#endif //VISITORDEMO_REPAIRMAN_H

//Repairman.cpp
#include "../header/Repairman.h"
void Repairman::visit(Monitor *monitor) {
    cout<<"Repairman is fixing Monitor"<<endl;
}
void Repairman::visit(Mainframe *mainframe) {
    cout<<"Repairman is fixing Mainframe"<<endl;
}

// client class, Computer.h
#ifndef VISITORDEMO_COMPUTER_H
#define VISITORDEMO_COMPUTER_H
#include "Visitor.h"
#include "Part.h"
#include <iostream>
#include <list>
using namespace std;
class Monitor;
class Mainframe;
class Computer {
private:
    list<Part *> parts;//objectStructure will iterate all elements
public:
    void attach(Part *part);
    void detach(Part *part);
    void accept(Visitor *visitor);
};
#endif //VISITORDEMO_COMPUTER_H

//Computer.cpp
#include "../header/Computer.h"
using namespace std;
void Computer::attach(Part *part) {
    parts.push_back(part);
}
void Computer::detach(Part *part) {
    parts.remove(part);
}
void Computer::accept(Visitor *visitor) {
    for (list<Part*>::iterator it = parts.begin(); it != parts.end(); it++) {
        (*it)->accept(visitor);
    }
}

//main
#include <iostream>
#include "header/Monitor.h"
#include "header/Mainframe.h"
#include "header/Computer.h"
#include "header/Consumer.h"
#include "header/Repairman.h"
using namespace std;

int main() {
    Computer *computer = new Computer;
    computer->attach(new Monitor("ACER", 1699));
    computer->attach(new Mainframe("IBM", 4699));
    Consumer *consumer = new Consumer;
    Repairman *repairman = new Repairman;
    computer->accept(consumer);
    computer->accept(repairman);
    return 0;
}
\end{lstlisting}

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/visitorex8r.PNG}}{\caption{Visitor example ouput }\label{visitorpr}}
\end{floatrow}
\end{figure}



\paragraph{C++ code example 3}
Let's take a look at the exmaple 3:
\begin{lstlisting}[caption={visitor pattern sample code 3},label={lst:vps3},language=C++]
class TicketBusiness//virtual Visitor
{
public:
    virtual ~TicketBusiness();
    virtual void doBySpcl(SellWindow* sw) = 0;
    virtual void doByNml(SellWindow* sw) = 0;
};

class Buyticket : public TicketBusiness {//Concrete Visitor
    public:
        void doBySpcl(SellWindow* sw){ cout<<"Buy Special ticket "<<endl;}
        void doByNml(SellWindow* sw){ cout<<"Buy Normal ticket"<<endl; }
};

class Changeticket : public TicketBusiness {
    public:
        void doBySpcl(SellWindow* sw){ cout<<"Change Special ticket"<<endl; }
        void doByNml(SellWindow* sw){ cout<<"Change Normal ticket"<<endl; }
};

class SellWindow //virtual Element, visitee (part being visited)
{
    public:
         virtual ~SellWindow();
         virtual void doBusiness(TicketBusiness* bs) = 0;// Alias of accept()
};

class SpecialWindow : public SellWindow { //Element
    public:
         void doBusiness(TicketBusiness* bs){ bs->doBySpcl(this); }
};

class NormalWindow : public SellWindow {//Element
    public:
         void doBusiness(TicketBusiness* bs){ bs->doByNml(this); }
};

class SellHall{//object Structure
    public:
         void attach(SellWindow * sw){ mVec.push_back(sw); }
         void detach(SellWindow * sw){ mVec.remove(sw); }
         void doBusiness(TicketBusiness * bs){
          for (list<SellWindow *>::iterator it = mVec.begin(); it != mVec.end(); it++){
             (*it)->doBusiness(bs); }
         }
    private:
         list<SellWindow *> mVec;
};

void main(){
    SellHall * sh = new SellHall();
    sh->attach(new SpecialWindow());
    sh->attach(new NormalWindow());
    
    Buy * by = new Buy();
    Change * cg = new Change();
    
    sh->doBusiness(by);
    sh->doBusiness(cg);
}
\end{lstlisting}

\paragraph{C++ code example 4}\mbox{}
 %visitor.h,concreteVisitor.h,element.h,concreteElement.h,objectStructure.h

%client: visitorApp.cpp
\begin{lstlisting}[caption={visitor pattern sample code 4, Ivisitor},label={lst:vps4},language=C++]
//*** * file name: Ivisitor.h
#ifndef _IVISITOR_H_ 
#define _IVISITOR_H_ 
class concreteElementA; 
class concreteElementB; 

class Ivisitor //virtual visitor
{ 
  public: 
     Ivisitor(){}; 
     virtual ~Ivisitor(){}; 
     virtual void visitConcreteElementA(concreteElementA* pConcreteElementA) = 0; 
     virtual void visitConcreteElementB(concreteElementB* pConcreteElementB) = 0; 
}; 
#endif// _IVISITOR_H_ 

//**** * file name: concreteVisitor.h
#ifndef _CONCRETE_VISITOR_H_ 
#define _CONCRETE_VISITOR_H_ 
#include "visitor.h" 
#include <iostream> 
using namespace std; 

class concreteVisitor1 : public Ivisitor 
{ 
  public: 
     concreteVisitor1(){}; 
     ~concreteVisitor1(){}; 
     virtual void visitConcreteElementA(concreteElementA* pConcreteElementA) 
     { 
        cout << "concreteVisitor1 is visiting concreteElementA !" << endl;  
     } 
     virtual void visitConcreteElementB(concreteElementB* pConcreteElementB) 
     { 
        cout << "concreteVisitor1 is visiting concreteElementB !!" << endl;   
     } 
}; 
 
class concreteVisitor2 : public Ivisitor 
{ 
  public: 
     concreteVisitor2(){}; 
     ~concreteVisitor2(){}; 
     virtual void visitConcreteElementA(concreteElementA* pConcreteElementA) 
     { 
          cout << "concreteElementA is visited by concreteVisitor2" << endl;  
     } 
     virtual void visitConcreteElementB(concreteElementB* pConcreteElementB) 
     { 
        cout << "concreteElementB is visited by concreteVisitor2" << endl;   
     } 
}; 
#endif// _CONCRETE_VISITOR_H_ 

/************************************************************************ 
 * file name: Ielement.h
 * description: declaration of accept,parameter type is Ivisitor.
************************************************************************/ 
#ifndef _IELEMENT_H_ 
#define _IELEMENT_H_ 
class visitor; 

class Ielement 
{ 
   public: 
     Ielement(){}; 
     virtual ~Ielement(){}; 
     virtual void accept(Ivisitor* pVisitor) = 0; 
}; 
#endif// _ELEMENT_H_ 

//** * file name: concreteElement.h
#ifndef _CONCRETE_ELEMENT_H_ 
#define _CONCRETE_ELEMENT_H_ 
#include "element.h" 
#include <iostream> 
using namespace std; 

class concreteElementA : public Ielement 
{ 
  public: 
     concreteElementA(){}; 
     ~concreteElementA(){}; 
     // doubld dispatch to seperate object from data structure
     virtual void accept(Ivisitor* pVisitor) 
     { 
          if (NULL != pVisitor) 
          { 
               pVisitor->visitConcreteElementA(this); 
          } 
     } 
     // other actions
     void operationA() 
     { 
        cout << "concreteElementA other actions" << endl; 
     } 
}; 

class concreteElementB : public Ielement 
{ 
public: 
     concreteElementB(){}; 
     ~concreteElementB(){}; 
     virtual void accept(Ivisitor* pVisitor) { 
      if (NULL != pVisitor) { 
         pVisitor->visitConcreteElementB(this); 
      } 
     } 
     void operationB() { cout << "concreteElementB other actions" << endl; } 
}; 
#endif// _CONCRETE_ELEMENT_H_ 

//***** file name: objectStructure.h
#ifndef _OBJECT_STRUCTURE_H_ 
#define _OBJECT_STRUCTURE_H_ 
#include "element.h" 
#include "visitor.h" 
#include <list> 
using namespace std; 

class objectStructure 
{ 
public: 
     void attach(Ielement* pElement) { m_list.push_back(pElement); } 
     void detach(Ielement* pElement) { m_list.remove(pElement); } 
     void accept(Ivisitor* pVisitor) 
     { 
      list<element*>::iterator Iter; 
      for (Iter = m_list.begin(); Iter != m_list.end(); ++Iter) { 
           if (NULL != *Iter) { 
                (*Iter)->accept(pVisitor); 
           }    
      } 
     } 
private: 
     list<Ielement*> m_list; 
}; 
#endif// _OBJECT_STRUCTURE_H_ 

//** * file name: visitorApp.cpp
#include "stdafx.h" 
#include "objectStructure.h" 
#include "concreteElement.h" 
#include "concreteVisitor.h" 
void freePtr(void* vptr) 
{ 
 if (NULL != vptr) 
 { 
  delete vptr; 
  vptr = NULL; 
 } 
} 
int _tmain(int argc, _TCHAR* argv[]) 
{ 
     objectStructure* pObject = new objectStructure(); 
     if (NULL != pObject) 
     { 
          Ielement* pElementA = new concreteElementA(); 
          Ielement* pElementB = new concreteElementB(); 
          pObject->attach(pElementA); 
          pObject->attach(pElementB); 
          concreteVisitor1* pVisitor1 = NULL; 
          pVisitor1 = new concreteVisitor1(); 
          concreteVisitor2* pVisitor2 = NULL; 
          pVisitor2 = new concreteVisitor2(); 
          pObject->accept(pVisitor1); 
          pObject->accept(pVisitor2); 
          system("pause"); 
          freePtr(pVisitor2); 
          freePtr(pVisitor1); 
          freePtr(pElementB); 
          freePtr(pElementA); 
          freePtr(pObject); 
     } 
     return 0; 
} 
\end{lstlisting}
\paragraph{Details (Wikipedia)}
\begin{figure}[h]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.5]{./dppic/W3sDesign_Visitor_Design_Pattern_UML.jpg}}{\caption{Visitor Pattern}\label{Visitorpatternpng}}
\end{floatrow}
\end{figure}

The visitor pattern requires a programming language that supports single dispatch, as common object-oriented languages do.
Under this condition, consider two objects, each of some class type; one is termed the \textcolor{purple}{element}, and the other is \textcolor{blue}{visitor}.

The \textcolor{blue}{visitor} (interface) declares a \textcolor{blue}{visit method}, which takes the \textcolor{purple}{element} as an argument, for \textit{each class of element}.
Concrete visitors are derived from the visitor class and implement these visit methods, 
each of which implements part of the algorithm operating on the object structure. 
The state of the algorithm is maintained locally by the concrete visitor class.

The \textcolor{purple}{element} (interface) declares an \textcolor{purple}{accept method} to accept a visitor, taking the \textcolor{blue}{visitor} as an argument.
\textcolor{purple}{Concrete elements}, derived from the element class, implement the accept method. 
In its simplest form, this is no more than a call to the visitor’s visit method. 
\textbf{Composite elements}, which maintain a list of child objects, typically iterate over these, calling each child’s accept method.

The \textcolor{green}{client} creates the object structure, directly or indirectly, and instantiates the \textcolor{blue}{concrete visitors}.
When an operation is to be performed which is implemented using the Visitor pattern, it calls the accept method of the top-level element(s).

When the \textcolor{blue}{accept method} is called in the program, its implementation is chosen based on 
both the \textcolor{blue}{dynamic type of the element} and the \textcolor{blue}{static type of the visitor}.
When the \textcolor{blue}{associated visit method} is called, its implementation is chosen based on 
both the \textcolor{blue}{dynamic type of the visitor} and the \textcolor{blue}{static type of the element},
as known from within the implementation of the \textcolor{blue}{accept method},
which is the same as the dynamic type of the element. (As a bonus, if the visitor can't handle an argument of the given element's type, then the compiler will catch the error.)

Thus, the implementation of the visit method is chosen based on both the \textcolor{blue}{dynamic type of the element} and the \textcolor{blue}{dynamic type of the visitor}.
This effectively implements double dispatch(~\ref{dd}). For languages whose object systems support multiple dispatch,
not only single dispatch, such as Common Lisp or C\# via the Dynamic Language Runtime (DLR), 
implementation of the visitor pattern is greatly simplified (a.k.a. Dynamic Visitor) by allowing use of simple function overloading to cover all the cases being visited.
A dynamic visitor, provided it operates on public data only, conforms to the open/closed principle~\ref{OCP} (since it does not modify extant structures)
and to the single responsibility principle(~\ref{SRP}) (since it implements the Visitor pattern in a separate component).

In this way, one algorithm can be written to traverse a graph of elements, 
and many different kinds of operations can be performed during that traversal by supplying different kinds of visitors to 
interact with the elements based on the dynamic types of both the elements and the visitors.

\paragraph{What is the difference between Visitor Pattern and Double Dispatch(~\ref{dd})}%\mbox{}
The visitor pattern simulates double dispatch in a conventional single-dispatch object-oriented language such as Java, Smalltalk, and C++ [Wikipedia].

In short, they come from two different conceptualizations that, in some languages where double dispatch is not natively supported,
lead to the visitor pattern as a way to concatenate two (or more) single dispatch in order to have a multi-dispatch surrogate.
Visitor pattern is one solution which implements the behaviour of double dispatch.
There can be several other solutions as well.
The term double dispatch itself doesn't give any idea of solution, in fact it is a problem whose solution is provided by visitor pattern.

Dynamic Dispatch refers to the concept of dispatching to a method based on runtime information, in general.
Most OO systems (as in Java/C\#/C++) usually implement dynamic dispatch via virtual methods (whether or not all methods are virtual depend from the language);
this restricts them to dispatch according to a single method argument (the implicit object reference).

In general you could want to dispatch according to an arbitrary number of elements. Double Dispatch, for example, is the requirement/ability to dispatch according to two arguments of the method.
On the other hand, the Visitor Pattern is an implementation of Multi Dispatch in general and thus Double Dispatch in particular in such OO systems.

%all ``*.src'' files need to be flashed. After you finish flashing these ``*.src'' files, you may continue. \Laughey[][green!60!white!] \\

%\textbf{./fastboot.sh $-$$-$nobl}
%\textbf{./fastboot\_b.sh $-$$-$nobl}
\paragraph{Visitor pattern example 5}

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Square;
class Circle;

class visitor
{
  public:
    virtual double visit(Square *e) = 0;
    virtual double visit(Circle *e) = 0;
};

class Vistable_Item { public: virtual double accept(class visitor* v) = 0; };

class Square: public Vistable_Item
{
  private:
    int _value;
  public:
     /*virtual*/double accept(visitor* v) { return v->visit(this); }
    Square(int v) : _value(v) { }
    int value() { return _value; }
};

class Circle: public Vistable_Item
{
  private:
    int _value;
  public:
     /*virtual*/double accept(visitor* v) { return v->visit(this); }
    Circle(int v) : _value(v) { } 
    int value() { return _value; }
};

class get_area_vistor: public visitor
{
     /*virtual*/double visit(Square *e) {
        return e->value()*e->value(); //return 100;
    }
     /*virtual*/double visit(Circle *e) {
        return e->value()*e->value()*3.14; //return 78.5;
    }
};

class get_perimeter_vistor: public visitor
{
     /*virtual*/double visit(Square *e) {
        //cout << "do Up on " + e->thiss() << '\n';
        cout << "get_perimeter_vistor : Square \n";
        return 40;
    }
     /*virtual*/double visit(Circle *e) {
        //cout << "do Up on " + e->that() << '\n';
        cout << "get_perimeter_vistor : Circle \n";
        return 31.4;
    }
};

int main()
{
    std::vector<Vistable_Item*>  items;
    items.push_back (new Square(10));
    items.push_back(new Circle(5));
	visitor* v = new get_area_vistor;
	//EXPECTEQ(items[0].accept(v),100);
	cout << "items[0].accept(v): " << items[0]->accept(v); cout << "\n";
	//EXPECTEQ(items[1].accept(v), 78.5);
	cout << "items[1].accept(v): " << items[1]->accept(v);
	
/*	
	std::vector<Vistable_Item*> items;
	items.push_back (new Square(10));
	items.push_back(new Circle(5));
	visitor* v = new get_perimeter_vistor;
	//EXPECTEQ(items[0].accept(v),40);
	cout << "items[0].accept(v)" << items[0]->accept(v);
	//EXPECTEQ(items[0].accept(v), 31.4);	
	cout << "items[1].accept(v)" << items[1]->accept(v);
*/
}
\end{lstlisting}
\begin{verbatim}
items[0].accept(v): 100
items[1].accept(v): 78.5 
\end{verbatim}
\paragraph{Cooperative Visitor: A Template Technique for Visitor Creation}
\url{http://www.artima.com/cppsource/cooperative_visitor.html}
\paragraph{Summary}
This article presents a flexible and efficient variation of the Visitor design pattern in C++ that accommodates \textit{arbitrary argument and return types.}

The Visitor pattern provides a way to add new polymorphic behavior to a class hierarchy without changing the hierarchy.
Visitor has another advantage over virtual functions in that it localizes behavior to the visitor class rather than spreading it across the hierarchy.

As the need for Visitor is discovered, a programmer has two choices:

    Create visitors by hand or Use template libraries such as Loki [4] to automate visitor creation.

Irrespective of what option the programmer chooses, the problem inherent to visitor soon crops up—visitor commits to too much too early.

The standard visitor implementation requires implementing a "bouncing" function in every visitable class that calls the appropriate Visit method in the visitor.
This function is generally called Accept:

\begin{lstlisting}[caption={visitor pattern sample code 6-1},language=C++]
class Shape {
 public:
  virtual int Accept( ShapeVisitor& visitor ) // bouncing function
  {
    return visitor.Visit( *this ); // call ShapeVisitor::Visit( Shape& )
  }
};

class Circle : public Shape {
public:
  virtual int Accept( ShapeVisitor& visitor )
  {
    return visitor.Visit( *this ); // call ShapeVisitor::Visit( Circle& )
  }
};
\end{lstlisting}
\paragraph{Limitations}
The Accept function is virtual and it invokes the appropriate Visit method, which is also virtual. This implements a limited form of multiple dispatch called double-dispatch~\ref{dd}.

Since the Accept function \textit{must} be virtual, it cannot be a template — it must hard-code all the knowledge about visitation, the return type, and the number of arguments.

As a result, a print method implemented as a visitor for the Shape hierarchy above must return an int while it might be better to return void or the output stream itself.
Visitor often forces the programmer to write useless return statements and then store the return values as member variables. All arguments must also be marshaled as member variables.

\begin{lstlisting}[caption={visitor pattern sample code 6-2},language=C++]
class ShapePrinter : public ShapeVisitor {
  std::ostream& output_; // marshall stream as member
public:
  ShapePrinter( std::ostream& o ) : output_( o ) { }
  virtual int Visit( Shape& shape )  { /* print shape */ return 0; }
  virtual int Visit( Circle& circle )  { /* print circle */ return 0; }
};
\end{lstlisting}

The same operation expressed as a virtual function is cleaner:

\begin{lstlisting}[caption={visitor pattern sample code 6-3},language=C++]
class Shape {
public:
  virtual void print( std::ostream& output ) { // print shape }
};

class Circle : public Shape {
public:
  virtual void print( std::ostream& output ) { // print circle }
};
\end{lstlisting}

Once a hierarchy commits to a return type, it's pretty much stuck with it forever.

Another serious limitation is that while it is easy to const-qualify a virtual function, it is difficult to specify const/non-const visitors.
Expressing virtual functions as visitors requires implementing the visitor pattern twice for a hierarchy— once each for the non const and const versions.
It is impossible to implement const visitors and non-const visitors for the same hierarchy using the Loki library[2][4] .

The standard visitor also has a cyclic dependency problem: every class knows about the visitor which knows about all other classes in the hierarchy.
This often causes recompilation of modules when a new class is added.
There's a solution to this called Acyclic Visitor[1] that uses dynamic casts to overcome this problem but is slower than cyclic visitor.
\paragraph{Cooperative Visitor}

Cooperative Visitor is a template-based technique for finding reasonable solutions to the above- mentioned problems. It allows:

    Flexibility of acyclic visitor with performance closer to cyclic visitor

    Easier to use, maintain and modify

    Better semantic names rather than "visit"

    Easy creation of const/non-const visitors

    Flexible return and argument types

    Dynamic configuration of visitation behavior

    Implementing a default handler

    Developing template code upon visitor

The print example could be expressed using Cooperative Visitor as:


\begin{lstlisting}[caption={visitor pattern sample code 6-4},language=C++]
class ShapePrinter : public Visitor< const Shape, void > 
{
  std::ostream& output_;
public:
  ShapePrinter( std::ostream& o ) : output_( o )
  {
    Visits( *this, Seq< Shape, Circle >::Type(), PrintInvoker() );
  }

  void print( const Shape& shape ) { /* print shape */ }
  void print( const Circle& circle ) { /* print circle */ }

  typedef VISIT_INVOKER( print ) PrintInvoker;
};
\end{lstlisting}

ShapePrinter decides the return type as well as the const-ness through template arguments to Visitor.
The visit methods are not virtual and are called print. There is no cyclic dependency: Shape and Circle know nothing about ShapePrinter.
The stream could also be passed as an extra argument to print.
\paragraph{Internals}

The technique uses following approach:

    Generate a unique tag ( integer value) for every visitable class in a hierarchy

    Provide a way for every visitable object to return its tag

    Build a "virtual function table" where:
\begin{verbatim}
        Table [ Tag ] = &Visit( Class ), where:
\end{verbatim}

            Where Table is the virtual table

            Tag is a tag value

            Visit is the visit handler (a thunk: details follow)

            Class is the class that has integer value "tag"

    When a visit operation is requested on an object, the tag of the object is retrieved and used as index into the "vtable." Then the visit function is invoked with the object as the argument.

The remainder of this article takes an in-depth look at an implementation.
\paragraph{Generating tags}

C++'s enumeration types generate unique integer values but require knowledge of the number of tags (classes), a coupling similar to cyclic dependency. Templates provide a clean solution.

For every hierarchy we can generate a tag counter to keep track of next available tag:
\begin{verbatim}
template< typename Base >
struct TagCounter
{
  static size_t s_counter; // declaration
}

template< typename Base >
size_t TagCounter< Base >::s_counter; // definition: default 0
\end{verbatim}
For every visitable class, we can create a variable to store its tag:
\begin{verbatim}
template< typename Visitable, typename Base >
struct TagHolder {
  static size_t s_tag;
};
\end{verbatim}

A tag is initialized the first time It is requested:

\begin{lstlisting}[caption={visitor pattern sample code 6-5},language=C++]
template< typename Visitable, typename Base >
size_t GetTag()
{
  size_t& tag = TagHolder< const Visitable, const Base >::s_tag;
  if( tag == 0 ) {
    // first time : generate tag
    tag = ++TagCounter< const Base >::s_counter;
  }
  return tag;
}
\end{lstlisting}

The GetTag templates applies const qualifier to its arguments and so GetTag and GetTag both return the same tag value. This prevents unnecessary tag generation and treats const/non-const objects in the same way.

To ensure initialization at startup, we force a call to GetTag while defining the tag variable.

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
template< typename Visitable, typename Base >
size_t TagHolder< Visitable, Base >::
s_tag = GetTag< Visitable, Base >();
\end{lstlisting}

This tag generation technique doesn't require class definitions of Visitable and avoids cyclic dependencies.
We cannot use local static variables in header files since a compiler could generate local static variables in every compilation unit.

Multi-threaded use of the tag generation technique during startup should be avoided or otherwise would require the counter variable would need to be wrapped using a synchronization primitive.
\paragraph{Tag retrieval}

Curiously Recurring Template Pattern ( CRTP )[3] allows defining a helper function in Base that every Visitable class can use to retrieve its tag:

\begin{lstlisting}[caption={visitor pattern sample code 6-6},language=C++]
// Base class must inherit from BaseVisitable
template< typename Base >
struct VisitableBase {
  template< typename Visitable >
  size_t GetTagHelper( const Visitable* /* this */ ) const
  {
    return GetTag< Visitable, Base >();
  }
};
\end{lstlisting}

A macro helps defining a virtual function in every Visitable class to return its tag:

\begin{lstlisting}[caption={visitor pattern sample code 6-7},language=C++]
#define VIS_DEFINE_VISITABLE()        \
  virtual size_t Tag() const          \
  {                                   \
    return GetTagHelper( this );      \
  }
\end{lstlisting}

Visitable is an empty base class and the compiler could optimize it away. Here's how a client would look like (similar to Loki):


\begin{lstlisting}[caption={visitor pattern sample code 6-8},language=C++]
class Shape : public VisitableBase< Shape > {
public:
  VIS_DEFINE_VISITABLE()
};

class Circle : public Shape {
public:
  VIS_DEFINE_VISITABLE()
};
\end{lstlisting}

\paragraph{The VTable}

The VTable is parameterized over the type of function it holds as well as the Base class.

\begin{lstlisting}[caption={visitor pattern sample code 6-9},language=C++]
template< typename Base, typename Func >
class VTable {
  std::vector< Func > table_; // storage
\end{lstlisting}
A new function is added to the table by passing the Visitable to find out the slot.

\begin{lstlisting}[caption={visitor pattern sample code 6-9},language=C++]
  template< typename Visitable >
  void add( Func f )
  {
    size_t index = GetTag< Visitable, Base >(); // find the slot
  
    if( index >= table_.size() ) {
      // find function for Base if it exists

      const size_t base_tag = GetTag< Base, Base >();

      Func default_function = (base_tag >= table_.size()) ? 0 : table_[base_tag];
      // expand the table
      table_.resize( index + 1, default_function );
    }
  
    table_[ index ] = f;
  }
\end{lstlisting}
An indexing operation is also provided:

\begin{lstlisting}[caption={visitor pattern sample code 6-9},language=C++]
  Func operator[] ( size_t index ) const
  {
    if( index >= table_.size() )
      index = GetTag< Base, Base >();

    return table_[ index ];
  }

}; // VTable
\end{lstlisting}

The VTable defaults to function for Base during expansion and retrieval resulting in a behavior closer to cyclic than acyclic visitor.
\paragraph{The Cooperative Visitor}

Cooperative Visitor technique allows implementing visitors that take N arguments.
For this discussion we look at a library implementation that allows creating visitors that take just one argument: the object being visited.

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
template< typename Base, typename ReturnType >
class Visitor;
\end{lstlisting}

Clients derive from Visitor and implement necessary visit methods:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
class ShapeVisitor : public Visitor< Shape, double > {
public:

  double Visit( Shape& ) { /* implementation */ }      
  double Visit( Circle& ) { /* implementation */ }      
  double Visit( Polygon& ) { /* implementation */ }     

};
\end{lstlisting}

Due to complexities involved in implementing single, multiple, and virtual inheritance, member functions of one class cannot be safely casted to member functions of another class.

So member functions of ShapeVisitor must somehow be transformed into member functions of Visitor so that they can be stored in the VTable. This is accomplished using thunks.
Member function thunks

Thunks are small functions that map data from one form to another.
They are often used to cast the this pointer and arguments before calling another function.
Thunks are found in Loki Library (trampoline trick) and also used by compilers to implement virtual functions.
We use thunks to generate functions in Visitor that calls visit functions in its derived classes:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
template< typename Base, typename ReturnType >
class Visitor {

  template< typename VisitorImpl, typename Visitable >
  ReturnType thunk( Base& b )
  {
    // first dispatch: eg: cast to ShapeVisitor&
    VisitorImpl& visitor = static_cast< VisitorImpl& >( *this ); 

    // second dispatch: eg: cast to Circle&
    Visitable& visitable = static_cast< Visitable& >( b );

    // invoke visit method: eg: call ShapeVisitor::Visit( Circle& )
    return visitor.Visit( visitable );
  }
\end{lstlisting}

The thunk member template is a thunk generating engine and a thunk has the signature ReturnType (Visitor::*)( Base\& ).
Since a thunk transforms actual Visit methods defined in derived visitor implementation classes to member functions of the Visitor class, it is a form of adapter.
The thunks are stored in a statically created VTable and each Visitor instance holds a pointer to a vtable.

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
  typedef ReturnType (Visitor::*Func) ( Base& );

  const VTable< const Base, Func >* vtable_; // vtable pointer
\end{lstlisting}

The function call operator implements the visitation. It retrieves the tag from the object and uses it as index to fetch the thunk from the vtable. Then it calls the thunk to initiate visitation:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
  ReturnType operator() ( Base& b )
  {
    Func thunk = (*vtable_ )[ b.Tag() ]; // fetch thunk
    return ( this->*thunk ) ( b ); // pointer to member function syntax
  }

}; // Visitor
\end{lstlisting}

\paragraph{Policy-based design}

We can achieve name independence by using a policy class, Invoker, that calls the visit method.
This allows context based names for visit functions and is important in light of this excerpt:
"the Visitor Pattern has nothing to do with visitation—the name was a real stumbling block for me" (Scott Meyers, My Most Important C++ Aha! Moments ..Ever[8]

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
  template< typename VisitorImpl, typename Visitable, typename Invoker >
  ReturnType thunk( Base& b )
  {
    VisitorImpl& visitor = static_cast< VisitorImpl& >( *this ); 

    Visitable& visitable = static_cast< Visitable& >( b );

    return Invoker::Invoke( visitor, visitable );
  }
\end{lstlisting}
A Invoker that uses print functions can be written as follows:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
struct PrintInvoker {
 
  template< typename VisitorImpl, typename Visitable >
  static ReturnType Invoke(VisitorImpl& visitor, Visitable& visitable )
  {
    check_member_function< ReturnType, VisitorImpl, Visitable >
       ( &Visitor::print ); // compile time assertion

    return visitor.print( visitable );
  }
  
};
\end{lstlisting}

check\_member\_function is a compile-time assertion that would result in errors if the function VisitorImpl::print( Visitable\& ) was not found.
This prevents the compiler from silently choosing VisitorImpl::print( Base\& ). The print functions can return any type that is convertible to ReturnType.

A macro can ease creating invokers :

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
#define VISIT_INVOKER( name )                    \
  struct {                                       \
   same code as print invoker but uses name      \
  }
\end{lstlisting}

VISIT\_INVOKER creates an anonymous struct that clients could typedef within their Visitor implementations.

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
class ShapeRenderer : public Visitor< const Shape > { // const visitor
public:

  void render( const Shape& ) { /* degenerate case */}
  void render( const Circle& ) { /* draw a circle */ }
  typedef VISIT_INVOKER( render ) RenderInvoker;
};
\end{lstlisting}

\paragraph{Const-Visitors}

Const-Visitors have visit methods of form ReturnType Visit( const Visitable\& ). The following template code expresses the relationship between Base and Visitable:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
template< typename Visitable, typename Base >
struct GetVisitMethodArgumentType {
  typedef Visitable Type; // ReturnType Visit( Visitable& )
};

// specialize for const Base
template< typename Visitable, typename Base >
struct GetVisitMethodArgumentType< Visitable, const Base > {
  typedef const Visitable Type; // ReturnType Visit( const Visitable& )
};
\end{lstlisting}

The thunk engine makes use of the above class template to perform either const or non-const visitation.

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
  template< typename VisitorImpl, typename Visitable, typename Invoker >
  ReturnType thunk( Base& b )
  {
    typdef typename GetVisitMethodArgumentType< Visitable, Base >
          ::Type VisitableType;

    VisitorImpl& visitor = static_cast< VisitorImpl& >( *this ); 

    VisitableType & visitable = static_cast< VisitableType & >( b );

    return Invoker::Invoke( visitor, visitable );
  }
\end{lstlisting}
Visitor< Shape, int > and Visitor< const Shape, Shape* > are a non-const visitor returning int and a const visitor returning Shape* respectively.
\paragraph{Creating VTables}

Typelists are especially useful for automating table creation[2]. We use a minimalistic implementation borrowed from Loki library. The Seq template helps creating typelists:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
typedef Seq< Shape, Circle, Rect, Square >::Type VisitedList1;
typedef Seq< Note, GraceNote >::Type VisitedList2;
\end{lstlisting}
In order to execute some code for every type in a typelist, we need to implement an "action class" with operator():

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
struct Action {

  template< typename T >
  void operator() ( const T* /* type hint */ )
  {
    // do something for type T
  }
};
\end{lstlisting}

The action can be applied for every type in a typelist:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
apply( VisitedList1(), Action() ); // Shape, Circle, Rect, Square
apply( VisitedList2(), Action() ); // Note, GraceNote
\end{lstlisting}

That's all we need to know about typelists to create vtables. We implement a parameterized action class that creates vtables:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
template< typename Visitor, typename VisitedList, typename Invoker >
struct CreateVtable {
  typename Visitor::VTable vtable_; /* vtable object */
\end{lstlisting}

The list of classes that need to be visited is represented by VisitedList. For every class in the list, the appropriate thunk is instantiated and added to the vtable:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
  template< typename Visitable >
  void operator () ( const Visitable* /* hint */ )
  {
    vtable_.template add< Visitable > ( // add to vtable
      &Visitor::template thunk <    // instantiate thunk
         Visitor,
         Visitable,
         Invoker
       >
    );
  }
\end{lstlisting}

The constructor adds the function for Base first and then invokes apply to create the complete vtable with slots filled:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
  CreateVtable()
  {
    // add Base's visit function first
    ( *this ) ( static_cast< typename Visitor::Base* >( 0 ) );

    // add visit function for each type in VisitedList
    apply( VisitedList(), *this );
  }
}; // CreateVtable
\end{lstlisting}

Vtables can be shared between Visitor instances by creating static vtables. This can be achieved through static members of template classes:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
template< typename Visitor, typename VisitedList, typename Invoker >
struct GetStaticVtable {
  // declare static instanceof vtable
  static CreateVtable< Visitor, VisitedList, Invoker > s_table;

  // provide conversion operator
  operator const typename Visitor::VTable*() const
  {
    return &s_table.vtable_; 
  }
};
\end{lstlisting}

Type inference provided by functions is helpful for easing client usage:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
// global helper function
template< typename Visitor, typename VisitedList, typename Invoker >
void Visits( Visitor& visitor, const VisitedList&, const Invoker& )
{
  // instantiate the static vtable and set the vtable pointer
  visitor.vtable_ = GetStaticVtable< Visitor, VisitedList, Invoker >();
}
\end{lstlisting}

A separate vtable is created for a combination of Visitor, VisitedList, Invoker types.

The client needs to call Visits in the constructors of the Visitors being implemented. This allows minimizing recompilation by moving the constructor body into cpp files.
The alternative of passing the list of visited classes as another template parameter to Visitor wouldn't allow this flexibility.
Also for every list of passed as a template argument, a new Visitor class would be generated, preventing Visitors that return the same type from having a common base class.
Putting it all together: examples

Here's how a client might implement a cloning const visitor for a shape hierarchy:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
class Cloner : public Visitor< const Shape, Shape* > {
public:

  Cloner()
  {
    // set the vtable pointer
    Visits( *this, Seq< Circle, Square, Rect >::Type(), 
CloneInvoker() );
  }

private:

  template< typename SomeShape >
  SomeShape * clone( const SomeShape& s) { return new SomeShape( s ); }

  typedef VISIT_INVOKER( clone ) CloneInvoker;

}; 

void func( const Shape& s )
{
  Cloner clone;
  Shape* copy = clone( s ); // invoke () operator
  // do some stuff
}
\end{lstlisting}

There's also ability to change behavior by choosing a different vtable during runtime:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
class Renderer : public Visitor< const Shape, void > {
public:

  Renderer( bool curved )
  {
    if(curved )
      Visits( *this, Seq< Circle, Bezier >::Type(), DrawInvoker() );
    else
      Visits( *this, Seq< Square, Rect >::Type(),  DrawInvoker() );
  }

  void draw( const Shape& );
  void draw( const Bezier& );

  // other draw implementations

  typedef VISIT_INVOKER( draw ) DrawInvoker;

};
\end{lstlisting}

The Visitor pattern is especially useful in compilers for manipulating syntax tree representations of a source program. Consider a syntax tree hierarchy:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
class ASTree : public VisitableBase< ASTree > {
  VIS_DEFINE_VISITABLE()
};

class Expression : public ASTree { 
  VIS_DEFINE_VISITABLE()
};

class UnaryExpression : public Expression {
  // expression formed by operators unary +, -, & etc
  VIS_DEFINE_VISITABLE()
};

class BinaryExpression : public Expression {
  // expressions formed by binary arithmetic operators +, -, *, / etc
  // shift operators, assignment operators etc
  VIS_DEFINE_VISITABLE()
};

class Statement : public ASTree {
  VIS_DEFINE_VISITABLE()
};

class IfStatement : public Statement{
  VIS_DEFINE_VISITABLE()
};

class ForStatement : public Statement{
  VIS_DEFINE_VISITABLE()
};
\end{lstlisting}

A visitor is ideal for type checking syntax trees, pretty-printing, transforming etc.
Cooperative Visitor is especially useful since some operation on trees are non modifying, others modifying; each operation has different return type, etc.

Here's how a type-checking visitor may be written in stages.
A type checker also annotates the syntax tree with the type for each node in the tree and also returns the type of the node being processed:

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
// type check expressions
class ExpressionChecker : public Visitor< ASTree, Type* > {
public:

  typedef Seq< UnaryExpression, BinaryExpression >::Type VisitedList;

  ExpressionChecker()
  {
    Visits( *this, VisitedList(),  TypeCheckInvoker () );
  }

  Type* type_check( ASTree& );
  Type* type_check( UnaryExpression& );
  Type* type_check( BinaryExpression& );

  typedef VISIT_INVOKER( type_check ) TypeCheckInvoker;

};

// type check statements
class StatementChecker : public ExpressionChecker {
public:

  // list of typechecked statements
  typedef Seq< IfStatement, ForStatement >::Type List;

  // merge the lists
  typedef Append< List, ExpressionChecker::VisitedList >::Type VisitedList;


  StatementChecker()
  {
    Visits( *this, VisitedList(),  TypeCheckInvoker () );
  }

  Type* type_check( IfStatement& );
  Type* type_check( ForStatement& );

  // make Expressionchecker's methods visible
  using ExpressionChecker::type_check;

};
\end{lstlisting}
It should be possible to automate building visitors in stages mimicking C++'s virtual table mechanism without the user having specifying the merged list of types being visited as above.
\paragraph{Future directions}
\subparagraph{Default vtable}

When a visitor is constructed, unless Visits is invoked, the vtable\_ pointer is null. Compile time techniques could be used to ensure that a visitor always has a valid vtable.
\subparagraph{Casting}

static\_cast won't work with virtual inheritance. Hence the thunk needs to handle casting to Visitable as a policy as well.
This allows choice on a per class basis.
Another alternative would be for the Tag virtual function to return the tag as well as the this pointer (as void* to prevent any implicit casting).
A thunk would then take a void* as argument and reinterpret\_cast it to appropriate Visitable type.

\begin{lstlisting}[caption={visitor pattern sample code 5, commandexample.cpp},language=C++]
  template< typename VisitorImpl, typename Visitable, typename Invoker >
  ReturnType thunk( void* b ) // or const-void *
  {

    VisitorImpl& visitor = static_cast< VisitorImpl& >( *this ); 

    VisitableType * visitable = reinterpret_cast< VisitableType* >( b 
);

    return Invoker::Invoke( visitor, *visitable );
  }

  ReturnType operator() ( Base& b )
  {
    // fetch tag and this pointer
    std::pair< size_t, void* > tag_ptr = b.TagAndPtr();
    Func thunk = (*vtable_ )[ tag_ptr.first ]; 
    return ( this->*thunk ) ( tag_ptr.second );
  }
\end{lstlisting}
\paragraph{Fast Visitor}

Cooperative Visitor technique avoids the dynamic\_cast required by acyclic visitor yet provides a similar amount of flexibility.
It's performance should be closer to that of cyclic visitor.
A virtual function call could be eliminated if visitable classes stored the tags as a member rather than returning them from a virtual function (Tag).
\paragraph{DLLs}

Windows DLLs present a problem: every DLL gets its own copy of static variables.
This would result in the same class being associated with different tags in different DLLs.
This problem can be solved by exporting tag generation functions from a single DLL and ensuring that each copy of tag variable for a class is initialized with the same tag value.
This can be achieved without any change to the client usage model presented in the article. A complete discussion is beyond the scope of this article.
\paragraph{Ad-Hoc Visitor}

All forms of visitor pattern require modifying the class hierarchy: the Accept method or the Tag method.
In a hierarchy where such a change is not possible, typeid could be used to provide a form of ad-hoc visitation[5].
The vtable would then be a map with type\_info objects as keys and thunks as values.
Ad-hoc visitation could be specified as a template argument to the visitor and much of other client usage should remain unchanged.
\paragraph{Custom Signature for Visit Methods}

Variadic templates (C++0x) would be of great help in defining visitors that take N arguments.
Having ability to pass extra arguments avoids having to implement such state as members of the Visitor.
\paragraph{Static Visit Methods}

Static functions can be defined easily whereas once a class is defined one cannot add new member functions to it. Static visit methods would provide even more flexibility.
\paragraph{Instance vtables}

Certain visitor instances could create and own their own vtables rather than using shared static vtables. This allows per object level dynamism but increases visitor construction cost.

\paragraph{Conclusions}

Cooperative Visitor technique provides the flexibility of Acyclic visitor with performance that approaches the Cyclic visitor.
Cooperative Visitor provides advantages over standard visitor implementations by allowing configuration: the name of visit methods,
the return type, the const-ness, the number of arguments. The ease of use approaches that of other Visitor implementations and libraries. The technique is standard C++ and is portable.
Talk back!

Have an opinion about the Cooperative Visitor? Discuss this article in the Articles Forum topic, Cooperative Visitor: A Template Technique for Visitor Creation.
\paragraph{End notes}

1. Robert Martin, Acylic Visitor presents a technique discussion of the Acyclic Visitor Pattern
\url{http://www.objectmentor.com/resources/articles/acv.pdf}

2. Andrei Alexandrescu. Modern C++ Design (Addison-Wesley Longman, 2001) is a good reference for generic programming, typelists, policy-based design, visitor pattern and the Loki Library.

3. James Coplien, Curiously Recurring Template Patterns. February 1995

4. Loki Library
\url{http://loki-lib.sourceforge.net}

5. Andrei Alexandrescu, Generic Programming: Typelists and Applications, Dr Dobbs Journal, 2003
\url{http://www.ddj.com/dept/cpp/184403813;jsessionid=2AAAVOCJBEGSYQSNDLRCKH0 CJUNN2JVN?_requestid=1305388}

6. Walter Bright. Backyard Hotrodding C++:, May 23, 2006, is another article which inspired the Cooperative Visitor technique
\url{http://www.artima.com/cppsource/backyard.html}

7. E.Gamma et al. Design Patterns ( Addison-Wesley Longman, 1995)

8. Scott Meyers, My Most Important C++ Aha! Moments, Ever September, 2006, discusses among other things, the counter intuitiveness of the Visitor pattern.
\url{http://www.artima.com/cppsource/top_cpp_aha_moments.html}



\paragraph{visitor : before and anfter}\mbox{}
%https://sourcemaking.com/design_patterns/visitor/cpp/1
Before -- The interface for "operations" are specified in the Color base class and implemented in the Color derived classes.

\begin{lstlisting}[caption={Before},label={lst:be},language=C++]
class Color
{
  public:
    virtual void count() = 0;
    virtual void call() = 0;
    static void report_num() {cout<<"Reds "<<s_num_red<<", Blus "<<s_num_blu<<'\n';}
  protected:
    static int s_num_red, s_num_blu;
};
int Color::s_num_red = 0;
int Color::s_num_blu = 0;

class Red: public Color
{
  public:
    void count() { ++s_num_red; }
    void call() { eye(); }
    void eye() { cout << "Red::eye\n"; }
};

class Blu: public Color
{
  public:
    void count() { ++s_num_blu; }
    void call() { sky(); }
    void sky() { cout << "Blu::sky\n"; }
};

int main()
{
  Color *set[] = { new Red, new Blu, new Blu, new Red, new Red, 0 };
  for (int i = 0; set[i]; ++i)
  {
    set[i]->count();
    set[i]->call();
  }
  Color::report_num();
}
\end{lstlisting}
Output

\begin{verbatim}
Red::eye
Blu::sky
Blu::sky
Red::eye
Red::eye
Reds 3, Blus 2
\end{verbatim}


After

The Color hierarchy specifies a single "accept()" method, and then the previous "count()" and "call()" methods are implemented as Visitor derived classes. 
When accept() is called on a Color object, that is the first dispatch. 
When visit() is called on a Visitor object, that is the second dispatch; and the "right thing" can be done based on the type of both objects.

\begin{lstlisting}[caption={After},label={lst:af},language=C++]
class Color
{
  public:
    virtual void accept(class Visitor*) = 0;
};

class Red: public Color
{
  public:
     /*virtual*/void accept(Visitor*);
    void eye() { cout << "Red::eye\n"; }
};
class Blu: public Color
{
  public:
     /*virtual*/void accept(Visitor*);
    void sky() { cout << "Blu::sky\n"; }
};

class Visitor
{
  public:
    virtual void visit(Red*) = 0;
    virtual void visit(Blu*) = 0;
};

class CountVisitor: public Visitor
{
  public:
    CountVisitor() { m_num_red = m_num_blu = 0; }
     /*virtual*/void visit(Red*) { ++m_num_red; }
     /*virtual*/void visit(Blu*) { ++m_num_blu; }
    void report_num() { cout << "Reds " << m_num_red << ", Blus " << m_num_blu << '\n'; }
  private:
    int m_num_red, m_num_blu;
};

class CallVisitor: public Visitor
{
  public:
     /*virtual*/void visit(Red *r) { r->eye(); }
     /*virtual*/void visit(Blu *b) { b->sky(); }
};

void Red::accept(Visitor *v) { v->visit(this); }
void Blu::accept(Visitor *v) { v->visit(this); }

int main()
{
  Color *set[] = { new Red, new Blu, new Blu, new Red, new Red, 0 };
  CountVisitor count_operation;
  CallVisitor call_operation;
  for (int i = 0; set[i]; i++)
  {
    set[i]->accept(&count_operation);
    set[i]->accept(&call_operation);
  }
  count_operation.report_num();
}
\end{lstlisting}
Output
\begin{verbatim}
Red::eye
Blu::sky
Blu::sky
Red::eye
Red::eye
Reds 3, Blus 2
\end{verbatim}

\paragraph{Visitor: Recovering lost type information}

Motivation. "My Component classes do not know that Composites exist. 
They provide no help for navigating Composites, nor any help for altering the contents of a Composite.
This is because I would like the base class (and all its derivatives) to be reusable in contexts that do not require Composites.
When given a base class pointer, if I absolutely need to know whether or not it is a Composite, I will use dynamic\_cast() to figure this out.
In those cases where dynamic\_cast() is too expensive, I will use a Visitor."

\begin{lstlisting}[caption={example code},label={lst:rl},language=C++]
#include <iostream>
#include <vector>
using namespace std;

class Visitor
{
  public:
    virtual void visit(class Primitive *, class Component*) = 0;// class equals forward declares
    virtual void visit(class Composite *, Component*) = 0;//so Component needs no class in front of it
};

class Component
{
    int value;
  public:
    Component(int val) { value = val; }
    virtual void traverse() { cout << value << " "; }
    // Having add() here sacrifices safety, but it supports transparency
    // virtual void add( Component* ) { }
    virtual void accept(Visitor &, Component*) = 0;
};

class Primitive: public Component
{
  public:
    Primitive(int val): Component(val){}
     /*virtual*/void accept(Visitor &v, Component *c) { v.visit(this, c); }
};

class Composite: public Component
{
    vector < Component * > children;
  public:
    Composite(int val): Component(val){}
    void add(Component *ele) { children.push_back(ele); }
     /*virtual*/void accept(Visitor &v, Component *c) { v.visit(this, c); }
     /*virtual*/void traverse()
    {
        Component::traverse();
        for (int i = 0; i < children.size(); i++)
          children[i]->traverse();
    }
};

class AddVisitor: public Visitor
{
  public:
     /*virtual*/void visit(Primitive *, Component*) { /* does not make sense */ }
     /*virtual*/void visit(Composite *node, Component *c) { node->add(c); }
};

int main()
{
  Component *nodes[3];
  // The type of Composite* is "lost" when the object is assigned to a
  // Component*
  nodes[0] = new Composite(1);
  nodes[1] = new Composite(2);
  nodes[2] = new Composite(3);

  // If add() were in class Component, this would work
  //    nodes[0]->add( nodes[1] );
  // If it is NOT in Component, and only in Composite,  you get the error -
  //    no member function `Component::add(Component *)' defined

  // Instead of sacrificing safety, we use a Visitor to support add()
  AddVisitor addVisitor;
  nodes[0]->accept(addVisitor, nodes[1]);
  nodes[0]->accept(addVisitor, nodes[2]);
  nodes[0]->accept(addVisitor, new Primitive(4));
  nodes[1]->accept(addVisitor, new Primitive(5));
  nodes[1]->accept(addVisitor, new Primitive(6));
  nodes[2]->accept(addVisitor, new Primitive(7));

  for (int i = 0; i < 3; i++)
  {
    nodes[i]->traverse();
    cout << endl;
  }
}

\end{lstlisting}
Output
\begin{Verbatim}
1 2 5 6 3 7 4 
2 5 6 
3 7 
\end{Verbatim}
\chapter{Command Pattern}\label{CommandPattern}
\paragraph{Intent}
    Encapsulate a request as an object, thereby letting you parametrize clients with different requests, queue or log requests, and support undoable operations.

    Promote "invocation of a method on an object" to full object status.

    An object-oriented callback.
\paragraph{details}
    Create a class that encapsulates some number of the following:

        a "receiver" object. 

        the method to invoke.

        the arguments to pass.

    Instantiate an object for each "callback".

    Pass each object to its future "sender".

    When the sender is ready to callback to the receiver, it calls execute().
\paragraph{Real world example}\mbox{}
1. A generic example would be you ordering food at a restaurant. 
You (i.e. Client) ask (i.e. Command) the waiter (i.e. Invoker) % to bring some food (i.e. Command)
and waiter (i.e.Invoker) simply forwards the request (i.e. Command) to Chef (i.e. Receiver) who has the knowledge of what and how to cook.

2. Another example would be you (i.e. Client) switching on (i.e. Command) the television (i.e. Receiver) using a remote control (Invoker).
\paragraph{Structure}
The client that creates a command and receiver executes it. This separation provides flexibility in the timing and sequencing of commands.
Materializing commands as objects means they can be passed, staged, shared, loaded in a table, and otherwise instrumented or manipulated like any other object.

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/commands.PNG}}{\caption{Command structure}\label{Commandp}}
\end{floatrow}
\end{figure}

Command objects can be thought of as "tokens" that are created by one client that knows what need to be done, and passed to receiver that has the resources for doing it.
\paragraph{Discussion}
Problem: Need to issue requests to objects without knowing anything about the operation being requested or the receiver of the request.

Command Pattern decouples the object that invokes the operation (by sending commands) from the one that knows how to perform/execute it.
To achieve this separation, the designer creates an abstract base class (i.e.,command) that maps a receiver (an object) with an action (a pointer to a member function).
The base class contains an execute() method that simply calls the action on the receiver.

All clients of Command objects treat each object as a "black box" by simply invoking the object's virtual execute() method whenever the client requires the object's "service".

A Command class holds some subset of the following: an object, a method to be applied to the object, and the arguments to be passed when the method is applied.
The Command's execute() method then causes the pieces to come together.

Sequences of Command objects can be assembled into composite (or macro) commands.
\begin{lstlisting}[caption={Command pattern sample code 1, commandexample.cpp},label={lst:cm},language=C++]
#include <iostream>
#include <string>
using namespace std;

class Person;

class Command
{
  private:
    // 1. Create a class that encapsulates an object and a member function
    // a pointer to a member function (the attribute's name is "method")
    Person *object; //    
    void (Person:: *method)();
  public:
    Command(Person *obj = 0, void(Person:: *meth)() = 0)
    {
        object = obj; // the argument's name is "meth"
        method = meth;
    }
    void execute()
    {
        (object->*method)(); // invoke the method on the object
    }
};

class Person
{
  private:
    string name;
    Command cmd;//cmd is a "black box",it is a method invocation promoted to "full object status"
  public:
    Person(string n, Command c): cmd(c) { name = n; }
    void talk() {
        // "this" is the sender, cmd has the receiver
        cout << name << " is talking" << endl;
        cmd.execute(); // ask the "black box" to callback the receiver
    }
    void passOn() {
        cout << name << " is passing on" << endl;
        // 4. When the sender is ready to callback to the receiver, it calls execute()
        cmd.execute(); 
    }
    void gossip() {
        cout << name << " is gossiping" << endl;
        cmd.execute();
    }
    void listen() { cout << name << " is listening" << endl; }
};

int main()
{
  // Fred will "execute" Barney which will result in a call to passOn()
  // Barney will "execute" Betty which will result in a call to gossip()
  // Betty will "execute" Wilma which will result in a call to listen()
  Person wilma("Wilma", Command());
  // 2. Instantiate an object for each "callback"
  // 3. Pass each object to its future "sender"
  Person betty("Betty", Command(&wilma, &Person::listen));
  Person barney("Barney", Command(&betty, &Person::gossip));
  Person fred("Fred", Command(&barney, &Person::passOn));
  fred.talk();
}
\end{lstlisting}
Output:
\begin{verbatim}
Fred is talking
Barney is passing on
Betty is gossiping
Wilma is listening
\end{verbatim}

\paragraph{Example 2}\mbox{}

\begin{lstlisting}[caption={Command pattern sample code 2, commandexample.cpp},label={lst:cm},language=C++]
class Receiver  //to Execute Command
{  
    public :  //defind all kinds of actions when receive commands 
         virtual void Action()  {  std::cout <<"do something..." <<endl;  }  
};  
class Command  
{  
    public :  
         virtual void Execute( ) = 0;
};  
  
class ConcreteCommand : public  Command  
{  
    public :  
        ConcreteCommand(Receiver *receiver)  {  this->receiver = receiver; }  
        void Execute()  {  receiver->Action();  }  
    protected:  
        Receiver *receiver; // !  
};  

class Invoker  //to send command
{  
    public :  
        void SetCommand(Command *command)  {  this->command = command;  }  
        void RunCommand()  {  command->Execute();  }  
    protected:  
        Command *command;  // !
};  

int main( )  
{  
    Receiver *receiver = new Receiver;  
    Command *command = new ConcreteCommand(receiver);  
  
    Invoker *invoker = new Invoker;  
    invoker->SetCommand(command);
    invoker->RunCommand( );     
}  
\end{lstlisting}

\paragraph{command pattern Example 3}
Television is the ``Receiver'' and which executes commands.  
Remote is the ``Invoker'' which is the sender of the commands. 
The all kinds of buttons(keys) of Remote are difference ``commands''.
\begin{lstlisting}[caption={Command pattern sample code 3, commandexample.cpp},label={lst:cm3},language=C++]
class Television  //receiver
{  
    public :  
         void TurnOn() {cout <<"Turn On TV" <<std::endl;  }  
         void TurnOff() {cout <<"Turn Off TV" <<std::endl;  }  
         void ChangeChannel() {cout <<"Change channel" <<std::endl;  }  
};  
  
class Command // virtual Command 
{  
public :  
    virtual void Execute( ) = 0;   
};  
  
class TurnOnCommand : public Command  // ConcreteCommands  
{  
    public :  
        TurnOnCommand(Television *tv)  {  m_tv = tv;  }  
        void Execute()       {  m_tv->TurnOn( );  }  
    protected :  
        Television *m_tv;  
};  
  
class TurnOffCommand : public Command  
{  
    public :  
        TurnOffCommand(Television *tv)  {  m_tv = tv;  }  
        void Execute( )   {  m_tv->Close( );  }  
    protected :  
        Television *m_tv;  
};  
  
class ChangeChannelCommand : public Command  
{  
    public :  
        ChangeChannelCommand(Television *tv)  {  m_tv = tv;  }  
        void Execute( )     {  m_tv->Change( );  }  
    protected :  
        Television *m_tv;  
};  
  
class Remote  
{  
    public :  
        void SetCommand(Command *command)  {  this->m_command = command;  }  
        void RunCommand( )  {  m_command->Execute();  }  
    protected:  
        Command *m_command;  
};  
  
int main( )  
{  
    Remote *remote = new Remote;  
    Television *tv = new Television;  
  
    Command *turnonCommand = new TurnOnCommand(tv);  
    remote->SetCommand(turnonCommand);  
    remote->RunCommand( );  
    delete turnonCommand;  
  
  
    Command *changechannelCommand = new ChangeChannelCommand(tv);  
    remote->SetCommand(changechannelCommand);  
    remote->RunCommand( );  
    delete changechannelCommand;  
  
    Command *turnoffCommand = new TurnOffCommand(tv);  
    remote->SetCommand(turnoffCommand);  
    remote->RunCommand( );  
    delete turnoffCommand;  
  
    delete tv;  
    delete remote;  
    return 0;  
}  
\end{lstlisting}

\paragraph{Example 4}\mbox{}
\begin{lstlisting}[caption={Command pattern sample code 4, commandexample.cpp},label={lst:cm4},language=C++]
#include <iostream>
using namespace std;

class Command // Command Interface
{
public:
	virtual void execute() = 0;
};
 
class Light // Receiver Class, define actions after recived commands
{
    public:
    	void on() { cout << "The light is on\n"; }
    	void off() { cout << "The light is off\n"; }
}; 

class LightOnCommand : public Command // Command for turning on the light
{
public:
    LightOnCommand(Light *light) : mLight(light) {}
	void execute(){ mLight->on(); }
private:
	Light *mLight;
};
 
class LightOffCommand : public Command // Command for turning off the light
{
public:
    LightOffCommand(Light *light) : mLight(light) {}
	void execute(){ mLight->off(); }
private:
	Light *mLight;
};

// Invoker, and it Stores the ConcreteCommand object 
class RemoteControl 
{
public:
	void setCommand(Command *cmd) { mCmd = cmd; }
	void buttonPressed() { mCmd->execute(); } 
private:
	Command *mCmd;
};
 
// The client
int main() 
{
	// Receiver 
	Light *light = new Light;

	// concrete Command objects 
	LightOnCommand *lightOn = new LightOnCommand(light);
	LightOffCommand *lightOff = new LightOffCommand(light);

	// invoker objects
	RemoteControl *control = new RemoteControl;

	// execute
	control->setCommand(lightOn);
	control->buttonPressed();
	control->setCommand(lightOff);
	control->buttonPressed();

	delete light, lightOn, lightOff, control;

	return 0;
}
\end{lstlisting}
Output from the run:
\begin{verbatim}
The light is on
The light is off
\end{verbatim}

We are not there yet, but let's summarize what's been done.

We know that a command object encapsulates a request by binding together
a set of actions on a specific receiver (Light).

So, a command object packages the actions (on/off) and the receiver (Light) up into an object (LightOn/OffCommand) that exposes just one method, execute().

The\textbf{key} to this pattern is an abstract Command class, which declares an interface for executing operations. In the simplest form this interface includes an abstract Execution operation:

\begin{verbatim}
class Command { // Command Interface
    public:
    	virtual void execute()=0;
};
\end{verbatim}
Concrete Command subclasses (LightOnCommand/LightOffCommand) specify a receiver-action pair by storing the receiver (Light) as an instance variable (mLight) and by 
by implementing execute() to invoke the request. The receiver has the knowledge required to carry out the request.
\begin{verbatim}
class LightOnCommand : public Command 
{
public:
        LightOnCommand(Light *light) : mLight(light) {}
	    void execute(){ mLight->on(); }
private:
	Light *mLight;
};
\end{verbatim}
When called, execute() causes the actions to be invoked on the receiver.
\begin{verbatim}
(a) control->setCommand(lightOn)
(b) control->buttonPressed()
(c) RemoteControl::mCmd->execute() 
(d) LightOnCommand::execute()
(e) mLight->on()
\end{verbatim}
Here, note that mCmd is a pointer to the Concrete-Command object:

\begin{verbatim}
Command* mCmd;
\end{verbatim}

From the outside, no other objects really know what actions get performed on what receiver. They just know that if they call the execute() method, their request will be served.
The simple example of the previous section has been extended so that we can handle several receivers. The commands bounded for each receivers are stored in vector form:
\begin{verbatim}
	vector<Command*> mOnCommand, mOffCommand;
\end{verbatim}
Also, so-called Null Object pattern~\ref{NullObjectPattern} has been added.
\paragraph{command pattern Example 5}\mbox{}
\begin{lstlisting}[caption={Command pattern sample code 5, commandexample.cpp},label={lst:cm6},language=C++]
#include <iostream>
#include <vector>
using namespace std;

const int MaxCommand = 5;

enum Receiver { LIGHT = 0, FAN, DOOR, OVEN, NONE }; 

class Command // Command Interface
{
public:
	virtual void execute() = 0;
};
 
class Light // Receiver Class
{
public:
	void on() { cout << "The light is on\n"; }
	void off() { cout << "The light is off\n"; }
}; 

class Fan // Receiver Class
{
public:
	void on() { cout << "The fan is on\n"; }
	void off() { cout << "The fan is off\n"; }
}; 

// Command for doing nothing on the light
class NullCommand : public Command 
{
public:
	void execute(){ cout << "Null command: does nothing\n"; }
};

// Command for turning on the light
class LightOnCommand : public Command 
{
public:
    LightOnCommand(Light *light) : mLight(light) {}
	void execute(){ mLight->on(); }
private:
	Light *mLight;
};
 
// Command for turning off the light
class LightOffCommand : public Command 
{
public:
        LightOffCommand(Light *light) : mLight(light) {}
	void execute(){ mLight->off(); }
private:
	Light *mLight;
};

// Command for turning on the fan
class FanOnCommand : public Command 
{
public:
        FanOnCommand(Fan *fan) : mFan(fan) {}
	void execute(){ mFan->on(); }
private:
	Fan *mFan;
};

// Command for turning off the fan
class FanOffCommand : public Command 
{
public:
        FanOffCommand(Fan *fan) : mFan(fan) {}
	void execute(){ mFan->off(); }
private:
	Fan *mFan;
};

// Invoker 
// Stores the ConcreteCommand object 
class RemoteControl 
{
public:
	RemoteControl() : mOnCommand(MaxCommand), mOffCommand(MaxCommand) {
		Command *nullCmd = new NullCommand;
		for(int i = 0; i < MaxCommand; i++) {
			mOffCommand[i] = nullCmd;
			mOnCommand[i] = nullCmd;
		}
	}
	void setCommand(Receiver id, Command *onCmd, Command *offCmd) {
		mOnCommand[id] = onCmd;
		mOffCommand[id] = offCmd;
	}

	void onButtonPressed(Receiver id) { mOnCommand[id]->execute(); } 
	void offButtonPressed(Receiver id) { mOffCommand[id]->execute(); } 

private:
	vector<Command*> mOnCommand, mOffCommand;
};
 
// The client
int main() 
{
	// Receiver 
	Light *light = new Light;
	Fan *fan = new Fan;

	// concrete Command objects 
	LightOnCommand *lightOn = new LightOnCommand(light);
	LightOffCommand *lightOff = new LightOffCommand(light);
	FanOnCommand *fanOn = new FanOnCommand(fan);
	FanOffCommand *fanOff = new FanOffCommand(fan);
	NullCommand *nullOn = new NullCommand();
	NullCommand *nullOff = new NullCommand();

	// invoker objects
	RemoteControl *control = new RemoteControl;

	// execute on/off on light
	control->setCommand(LIGHT, lightOn, lightOff);
	control->onButtonPressed(LIGHT);
	control->offButtonPressed(LIGHT);

	// execute on/off on Fan 
	control->setCommand(FAN, fanOn, fanOff);
	control->onButtonPressed(FAN);
	control->offButtonPressed(FAN);
    // doing nothing
	control->setCommand(NONE, nullOn, nullOff);
	control->onButtonPressed(NONE);

	delete light, lightOn, lightOff;
	delete fan, fanOn, fanOff;
	delete control;

	return 0;
}
\end{lstlisting}

Output:
\begin{verbatim}
The light is on
The light is off
The fan is on
The fan is off
Doing nothing
\end{verbatim}

\paragraph{Command : Simple and 'macro' commands}
Discussion. Encapsulate a request as an object. SimpleCommand maintains a binding between a receiver object and an action stored as a pointer to a member function.
MacroCommand maintains a sequence of Commands. No explicit receiver is required because the sub-commands already define their receiver. MacroCommand may contain MacroCommands.

\begin{lstlisting}[caption={Command Pattern example:macro }, language=C++]
#include <iostream>
#include <vector>
using namespace std;

class Number
{
  public:
    void dubble(int &value) { value *= 2; }
};

class Command
{
  public:
    virtual void execute(int &) = 0;
};

class SimpleCommand: public Command
{
  private:
    typedef void(Number:: *Action)(int &);
    Number *receiver;
    Action action;
  public:
    SimpleCommand(Number *rec, Action act)
    {
        receiver = rec;
        action = act;
    }
     /*virtual*/void execute(int &num) { (receiver-> *action)(num); }
};

class MacroCommand: public Command
{
  private:
    vector < Command * > list;
  public:
    void add(Command *cmd) { list.push_back(cmd); }
     /*virtual*/void execute(int &num)
    {
        for (int i = 0; i < list.size(); i++)
          list[i]->execute(num);
    }
};

int main()
{
  Number object;
  Command *commands[3];
  commands[0] = &SimpleCommand(&object, &Number::dubble);

  MacroCommand two;
  two.add(commands[0]);
  two.add(commands[0]);
  commands[1] = &two;

  MacroCommand four;
  four.add(&two);
  four.add(&two);
  commands[2] = &four;

  int num, index;
  while (true)
  {
    cout << "Enter number selection (0=2x 1=4x 2=16x): ";
    cin >> num >> index;
    commands[index]->execute(num);
    cout << "   " << num << '\n';
  }
}
\end{lstlisting}

Output
\begin{Verbatim}
Enter number selection (0=2x 1=4x 2=16x): 3 0
   6
Enter number selection (0=2x 1=4x 2=16x): 3 1
   12
Enter number selection (0=2x 1=4x 2=16x): 3 2
   48
Enter number selection (0=2x 1=4x 2=16x): 4 0
   8
Enter number selection (0=2x 1=4x 2=16x): 4 1
   16
Enter number selection (0=2x 1=4x 2=16x): 4 2
   64
\end{Verbatim}


\paragraph{check list}
    Define a Command interface with a method signature like execute().

    Create one or more derived classes that encapsulate some subset of the following: a "receiver" object, the method to invoke, the arguments to pass.

    Instantiate a Command object for each deferred execution request.

    Pass the Command object from the creator (aka sender) to the invoker (aka receiver).

    The invoker decides when to execute().
%\begin{Verbatim}
%%\leftpointright{\emph{\textbf{ After system reboot, Android serial output --> the red highlight shows current partition is "B"}}}
%\end{Verbatim}
\paragraph{Rules of thumb}\mbox{}
    Chain of Responsibility, Command, Mediator, and Observer, address how you can decouple senders and receivers, but with different trade-offs.
    Command normally specifies a sender-receiver connection with a subclass.

    Chain of Responsibility can use Command to represent requests as objects.

    Command and Memento act as magic tokens to be passed around and invoked at a later time.
    In Command, the token represents a request; in Memento, it represents the internal state of an object at a particular time.
    Polymorphism is important to Command, but not to Memento because its interface is so narrow that a memento can only be passed as a value.

    Command can use Memento to maintain the state required for an undo operation.

    MacroCommands can be implemented with Composite.

    A Command that must be copied before being placed on a history list acts as a Prototype.

    Two important aspects of the Command pattern: interface separation (the invoker is isolated from the receiver), time separation (stores a ready-to-go processing request that's to be stated later).

\chapter{Memento Pattern}\label{MementoPattern}
\paragraph{Intent}
    Without violating encapsulation, capture and externalize an object's internal state so that the object can be returned to this state later.

    A magic cookie that encapsulates a "check point" capability.

    Promote undo or rollback to full object status.

\textbf{Problem:} Need to restore an object back to its previous state (e.g. "undo" or "rollback" operations).
\paragraph{Discussion}
The client requests a Memento from the source object when it needs to checkpoint the source object's state.
The source object initializes the Memento with a characterization of its state.
The client is the "care-taker" of the Memento, but only the source object can store and retrieve information from the Memento (the Memento is "opaque" to the client and all other objects).
If the client subsequently needs to "rollback" the source object's state, it hands the Memento back to the source object for reinstatement.

An unlimited "undo" and "redo" capability can be readily implemented with a stack of Command objects and a stack of Memento objects.

The Memento design pattern defines three distinct roles:

1)    Originator - the object that knows how to save itself.
2)    Caretaker - the object that knows why and when the Originator needs to save and restore itself.
3)    Memento - the lock box that is written and read by the Originator, and shepherded by the Caretaker.

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/mementod.PNG}}{\caption{Memento pattern}\label{mementod}}
\end{floatrow}
\end{figure}

\paragraph{Exmaple 1}
A memento is an object that stores a snapshot of the internal state of \colorbox{gray!30}{another object}.
It can be leveraged to support multi-level undo of the Command pattern~\ref{CommandPattern}. 
In this example, before a command is run against the Number object, Number's current state is saved in Command's static memento history list,
and the command itself is saved in the static command history list.
Undo() simply "pops" the memento history list and reinstates Number's state from the memento.
Redo() "pops" the command history list.
Note that Number's encapsulation is preserved, and Memento is wide open to Number.
\begin{lstlisting}[caption={Memento Pattern example 1}, language=C++]
#include <iostream.h>
class Number;

class Memento
{
  public:
    Memento(int val) { _state = val; }
  private:
    friend class Number; // not essential, but p287 suggests this
    int _state;
};

class Number
{
  public:
    Number(int value) { _value = value; }
    void double() { _value = 2 * _value; }
    void half() { _value = _value / 2; }
    int getValue() { return _value; }
    Memento *createMemento() { return new Memento(_value); }
    void reinstateMemento(Memento *mem) { _value = mem->_state; }
  private:
    int _value;
};

class Command
{
  public:
    typedef void(Number:: *Action)();
    Command(Number *receiver, Action action)
    {
        _receiver = receiver;
        _action = action;
    }
    virtual void execute()
    {
        _mementoList[_numCommands] = _receiver->createMemento();
        _commandList[_numCommands] = this;
        if (_numCommands > _highWater)
          _highWater = _numCommands;
        _numCommands++;
        (_receiver-> *_action)();
    }
    static void undo()
    {
        if (_numCommands == 0)
        {
            cout << "*** Attempt to run off the end!! ***" << endl;
            return ;
        }
        _commandList[_numCommands - 1]->_receiver->reinstateMemento(_mementoList[_numCommands - 1]);
        _numCommands--;
    }
    void static redo()
    {
        if (_numCommands > _highWater)
        {
            cout << "*** Attempt to run off the end!! ***" << endl;
            return ;
        }
        (_commandList[_numCommands]->_receiver->*(_commandList[_numCommands] ->_action))();
        _numCommands++;
    }
  protected:
    Number *_receiver;
    Action _action;
    static Command *_commandList[20];
    static Memento *_mementoList[20];
    static int _numCommands;
    static int _highWater;
};

Command *Command::_commandList[];
Memento *Command::_mementoList[];
int Command::_numCommands = 0;
int Command::_highWater = 0;

int main()
{
  int i;
  cout << "Integer: ";
  cin >> i;
  Number *object = new Number(i);

  Command *commands[3];
  commands[1] = new Command(object, &Number::double);
  commands[2] = new Command(object, &Number::half);

  cout << "Exit[0], Double[1], Half[2], Undo[3], Redo[4]: ";
  cin >> i;

  while (i)
  {
    if (i == 3) Command::undo();
    else if (i == 4) Command::redo();
    else commands[i]->execute();
    cout << "   " << object->getValue() << endl;
    cout << "Exit[0], Double[1], Half[2], Undo[3], Redo[4]: ";
    cin >> i;
  }
}
\end{lstlisting}
\begin{verbatim}
Output

Integer: 11
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 2
   5
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 1
   10
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 2
   5
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 3
   10
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 3
   5
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 3
   11
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 3
*** Attempt to run off the end!! ***
   11
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 4
   5
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 4
   10
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 4
   5
Exit[0], Double[1], Half[2], Undo[3], Redo[4]: 4
*** Attempt to run off the end!! ***
   5
\end{verbatim}
\paragraph{Example 2}
In this example, Memento is used to define internal states, Caretake is a manager to save the game progress, GameRole is a player.
As you can see, GameRole depends on Memento object but not Caretake object.

\begin{lstlisting}[caption={Memento Pattern example 2}, language=C++]
class Memento    
{  
    private:  
        int m_vitality; // blood 
        int m_attack;   //  
        int m_defense;  //  
    public:  
        Memento(int vitality, int attack, int defense):   
                  m_vitality(vitality),m_attack(attack),m_defense(defense){}  
    
        Memento& operator=(const Memento &memento)   
        {  
            m_vitality = memento.m_vitality;  
            m_attack = memento.m_attack;  
            m_defense = memento.m_defense;  
            return *this;  
        }  
};  

class GameRole    
{  
    private:  
        int m_vitality;  
        int m_attack;  
        int m_defense;  
    public:  
        GameRole(): m_vitality(100),m_attack(100),m_defense(100) {}  
    
        Memento Save()  //save progress
        {   
            Memento memento(m_vitality, m_attack, m_defense);  
            return memento;  
        }  
        void Load(Memento memento)  // load progress
        {  
            m_vitality = memento.m_vitality;  
            m_attack = memento.m_attack;   
            m_defense = memento.m_defense;  
        }  
        void Show() { cout<<"vitality : "<< m_vitality<<", attack : "<< m_attack<<", defense : "<< m_defense<<endl; }  
        void Attack() { m_vitality -= 10; m_attack -= 10;  m_defense -= 10; }  
};  

class Caretake   //manage the Memento 
{  
    public:  
        Caretake() {}  
        void Save(Memento menento) { m_vecMemento.push_back(menento); }  
        Memento Load(int state) { return m_vecMemento[state]; }  
    private:  
        vector<Memento> m_vecMemento;  
};  

//client  
int main()  
{     
    Caretake caretake;  
    GameRole role;   
    role.Show();   //initialization value
    caretake.Save(role.Save()); //save  
    role.Attack();     
    role.Show();  //after attack  
    role.Load(caretake.Load(0)); //load to 0
    role.Show();  //  
    return 0;  
}  
\end{lstlisting}

\begin{lstlisting}[caption={Memento Pattern example 3}, language=C++]
#include <iostream>
using namespace std;

class RoleStateMemento
{
    public:
         RoleStateMemento(unsigned iBlood, unsigned iAttack, unsigned iDefense) :
            m_iBlood(iBlood), m_iAttack(iAttack), m_iDefense(iDefense){}
    
    private:
         friend class GameRole;// not essential, but p287 suggests this, to do so, only
         // GameRole can visit and update memento.
    
         unsigned GetBloodValue() { return m_iBlood; }
         unsigned GetAttackValue() { return m_iAttack; }
         unsigned GetDefenseValue() { return m_iDefense; }
    
         unsigned m_iBlood;   // 
         unsigned m_iAttack;  // 
         unsigned m_iDefense; // 
};

class GameRole//originator creates memento object to save its state
{
    public:
         GameRole() : m_iBlood(100), m_iAttack(100), m_iDefense(100){}
         RoleStateMemento *SaveState() { return new RoleStateMemento(m_iBlood, m_iAttack, m_iDefense); }
         void RecoveryState(RoleStateMemento *pRoleState)
         {
              m_iBlood = pRoleState->GetBloodValue();
              m_iAttack = pRoleState->GetAttackValue();
              m_iDefense = pRoleState->GetDefenseValue();
              cout<<"Recovery..."<<endl;
         }
         void ShowState()
         {
              cout<<"show Blood:"<<m_iBlood<<endl;
              cout<<"show Attack:"<<m_iAttack<<endl;
              cout<<"show Defense:"<<m_iDefense<<endl;
         }
         void Fight()
         {
              m_iBlood -= 100;
              m_iAttack -= 10;
              m_iDefense -= 20;
    
              if (m_iBlood == 0) { cout<<"Game Over"<<endl; }
         }
    private:
         unsigned m_iBlood;   //
         unsigned m_iAttack;  // 
         unsigned m_iDefense; //
};

class RoleStateCaretaker//manager but cannot visit memento object
{
    public:
        //Caretaker request a Memento from/through originator
         void SetRoleStateMemento(RoleStateMemento *pRoleStateMemento) { m_pRoleStateMemento = pRoleStateMemento; }
         RoleStateMemento *GetRoleStateMemento() { return m_pRoleStateMemento; }
    
    private:
         RoleStateMemento *m_pRoleStateMemento;
};

int main()
{
     GameRole *pSuperman = new GameRole(); //create a game role 
     pSuperman->ShowState(); // show beginning state

     //save progress before start fighting against Boss
     RoleStateCaretaker *pRoleStateCaretaker = new RoleStateCaretaker();
     pRoleStateCaretaker->SetRoleStateMemento(pSuperman->SaveState());

     // start to attack biggest-BOSS
     pSuperman->Fight();
     pSuperman->ShowState();

     // fail to win the biggest-Boss, load saved progress to start over
     pSuperman->RecoveryState(pRoleStateCaretaker->GetRoleStateMemento());
     pSuperman->ShowState();

     return 0;
}
\end{lstlisting}

\paragraph{Rules of thumb}
    Command and Memento act as magic tokens to be passed around and invoked at a later time.
    In Command, the token represents a request; in Memento, it represents the internal state of an object at a particular time.
    Polymorphism is important to Command, but not to Memento because its interface is so narrow that a memento can only be passed as a value.

    Command can use Memento to maintain the state required for an undo operation.

    Memento is often used in conjunction with Iterator. An Iterator can use a Memento to capture the state of an iteration. The Iterator stores the Memento internally.

\chapter{Observer Pattern}\label{ObserverPattern}
Observer Pattern's intent is to define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

The subject and observers define the one-to-many relationship.
The observers are dependent on the subject such that when the subject's state changes, the observers get notified.
Depending on the notification, the observers may also be updated with new values.

Here is the example from the book "Design Patterns" by Gamma.

\begin{lstlisting}[caption={Observer Pattern - sample 1, GOF}, language=c++]
#include <iostream>
#include <vector>
#include <time.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <string.h>

using namespace std ; 

class Subject; 

class Observer //interface
{ 
  public: 
     Observer() {}; 
     ~Observer() {}; 
     virtual void Update(Subject* theChangeSubject) = 0; 
}; 

class Subject 
{ 
  public: 
     Subject() {}; 
     virtual ~Subject() {}; 
     virtual void Attach(Observer*); 
     virtual void Detach(Observer*); 
     virtual void Notify();  
  private: 
     vector<Observer*> _observers; 
}; 

void Subject::Attach (Observer* o) 
{ 
     _observers.push_back(o); 
} 

void Subject::Detach (Observer* o) 
{ 
     int count = _observers.size(); 
     int i; 
    
     for (i = 0; i < count; i++) { 
       if(_observers[i] == o) 
       break; 
     } 
     if(i < count) 
      _observers.erase(_observers.begin() + i); 
} 

void Subject::Notify () 
{ 
     int count = _observers.size(); 
    
     for (int i = 0; i < count; i++) 
       (_observers[i])->Update(this); 
}

class ClockTimer : public Subject 
{ 
  public: 
     ClockTimer() { _strtime( tmpbuf ); }; 
     int GetHour(); 
     int GetMinute();
     int GetSecond(); 
     void Tick();   
  private: 
    char tmpbuf[128]; 
}; 

 /* Set time zone from TZ environment variable. If TZ is not set, 
  * the operating system is queried to obtain the default value for the variable. 
 */ 
void ClockTimer::Tick() 
{ 
    _tzset(); 

// Obtain operating system-style time. 
    _strtime( tmpbuf ); 
    Notify(); 
} 

int ClockTimer::GetHour() 
{ 
 char timebuf[128]; 
 strncpy(timebuf, tmpbuf, 2); 
 timebuf[2] = NULL; 
  
 return atoi(timebuf); 
} 

int ClockTimer::GetMinute() 
{ 
 char timebuf[128]; 
 strncpy(timebuf, tmpbuf+3, 2); 
 timebuf[2] = NULL; 

 return atoi(timebuf); 
} 

int ClockTimer::GetSecond() 
{ 
 char timebuf[128];
 strncpy(timebuf, tmpbuf+6, 2); 
 timebuf[2] = NULL; 

 return atoi(timebuf); 
}

class DigitalClock: public Observer 
{ 
  public: 
     DigitalClock(ClockTimer *);  
     ~DigitalClock();   
      void Update(Subject *);   
      void Draw();     
  private: 
     ClockTimer *_subject;  
}; 

DigitalClock::DigitalClock (ClockTimer *s) 
{ 
 _subject = s; 
 _subject->Attach(this); 
} 

DigitalClock::~DigitalClock () 
{ 
 _subject->Detach(this); 
} 

void DigitalClock::Update (Subject *theChangedSubject) 
{ 
 if(theChangedSubject == _subject) 
  Draw(); 
} 

void DigitalClock::Draw () 
{ 
 int hour = _subject->GetHour(); 
 int minute = _subject->GetMinute(); 
 int second = _subject->GetSecond(); 

 cout << "Digital time is " << hour << ":" << minute << ":" << second << endl;           
}

class AnalogClock: public Observer 
{ 
public: 
 AnalogClock(ClockTimer *);  
 ~AnalogClock();    
  void Update(Subject *);  
  void Draw();     
private: 
 ClockTimer *_subject;   
}; 

AnalogClock::AnalogClock (ClockTimer *s) 
{ 
 _subject = s; 
 _subject->Attach(this); 
} 

AnalogClock::~AnalogClock () 
{ 
 _subject->Detach(this); 
} 

void AnalogClock::Update (Subject *theChangedSubject) 
{ 
 if(theChangedSubject == _subject) 
  Draw(); 
} 

void AnalogClock::Draw () 
{ 
 int hour = _subject->GetHour(); 
 int minute = _subject->GetMinute(); 
 int second = _subject->GetSecond(); 

 cout << "Analog time is " << hour << ":" << minute << ":" << second << endl; 
}

int main(void) 
{ 
 ClockTimer timer; 

 DigitalClock digitalClock(&timer;); 
 AnalogClock analogClock(&timer;); 
  
 timer.Tick();  
  
 return 0; 
}
\end{lstlisting}
Output:
\begin{verbatim}
Digital time is 14:41:36
Analog time is 14:41:36
\end{verbatim}

\paragraph{Here are the summary of the pattern:}
    Objects (DigitalClock or AnalogClock object) use the Subject interfaces (Attach() or Detach()) either to subscribe (register) as observers or
    unsubscribe (remove) themselves from being observers.
\begin{verbatim}
    DigitalClock::DigitalClock (ClockTimer *s) 
    { 
      _subject = s; 
      _subject->Attach(this); 
    } 

    DigitalClock::~DigitalClock () 
    { 
        _subject->Detach(this); 
    } 
\end{verbatim}
    Each subject can have many observers.
\begin{verbatim}
 class Subject 
 { 
   public: 
     Subject() {}; 
     ~Subject() {}; 
     void Attach(Observer*); 
     void Detach(Observer*); 
     void Notify(); 
   private: 
     vector<Observer*> _observers; 
 }; 
\end{verbatim}
    All observers need to implement the Observer interface. This interface just has one method, Update(), that gets called when the Subject's state changes.
\begin{verbatim}
 class AnalogClock: public Observer 
 { 
   public: 
     AnalogClock(ClockTimer *);  
     ~AnalogClock();    
      void Update(Subject *);  
      void Draw();     
   private: 
     ClockTimer *_subject;   
 };
\end{verbatim}
    In addition to the attach() and detach() methods, the concrete subject implements a Notify() method that is used to update all the current observers whenever state changes.
    But in this case, all of them are done in the parent class, Subject.
\begin{verbatim}
    void Subject::Attach (Observer* o) 
    { 
        _observers.push_back(o); 
    } 

    void Subject::Detach(Observer* o) 
    { 
     int count = _observers.size(); 
     int i; 

     for (i = 0; i < count; i++) { 
       if(_observers[i] == o) 
       break; 
     } 
     if(i < count) 
      _observers.erase(_observers.begin() + i); 

    } 

    void Subject::Notify() 
    { 
     int count = _observers.size(); 

     for (int i = 0; i < count; i++) 
       (_observers[i])->Update(this); 
    }
\end{verbatim}
    The Concrete object may also have methods for setting and getting its state.
\begin{verbatim}
    class ClockTimer : public Subject 
    { 
    public: 
     ClockTimer() { _strtime( tmpbuf ); }; 
     int GetHour(); 
     int GetMinute();
     int GetSecond(); 
     void Tick();   
    private: 
     char tmpbuf[128]; 
    }; 
\end{verbatim}
    Concrete observers can be any class that implements the Observer interface. Each observer subscribe (register) with a concrete subject to receive update.
\begin{verbatim}
    DigitalClock::DigitalClock (ClockTimer *s) 
    { 
     _subject = s; 
     _subject->Attach(this); 
    } 
\end{verbatim}
    The two objects of Observer Pattern are loosely coupled, they can interact but with little knowledge of each other.

\paragraph{2nd Example of Observer Pattern}

The following example is not much different from the previous one.
The important point to notice is that the MySubject class has not compile-time dependency on the MyObserver class.
The relationship between the two classes is dynamically created at run time.
\begin{lstlisting}[caption={Observer Pattern - sample 2}, language=c++]
#include <iostream>
#include <vector>
#include <string>

class ObserverInterface
{
    public:
    	virtual ~ObserverInterface() {}
    	virtual void update(int message) = 0;
};

class SubjectInterface
{
    public:
    	virtual ~SubjectInterface();
    	virtual void subscribe(ObserverInterface *);
    	virtual void unsubscribe (ObserverInterface *);
    	virtual void notify(int message);
    private:
    	std::vector<ObserverInterface *> mObservers;
};

SubjectInterface::~SubjectInterface() {}

void SubjectInterface::subscribe(ObserverInterface *observer)
{
	mObservers.push_back(observer);
}

void SubjectInterface::unsubscribe(ObserverInterface *observer)
{
	int count = mObservers.size(); 
	int i; 

	for (i = 0; i < count; i++) { 
		if(mObservers[i] == 0) 
		break; 
	} 
	if(i < count) 
		mObservers.erase(mObservers.begin() + i);
}

void SubjectInterface::notify(int msg)
{
	int count = mObservers.size(); 

	for (int i = 0; i < count; i++) 
		(mObservers[i])->update(msg); 
}

class MySubject : public SubjectInterface
{
public:
	enum Message {ADD, REMOVE};
};

class MyObserver : public ObserverInterface
{
    public:
    	explicit MyObserver(const std::string &str;) : name(str) {}
    	void update(int message) { std::cout<<name<<"Got message"<<message<< std::endl; }
    private:
    	std::string name;
};

int main() 
{
	MyObserver observerA("observerA");
	MyObserver observerB("observerB");
	MyObserver observerC("observerC");

	MySubject subject;
	subject.subscribe(&observerA;);
	subject.subscribe(&observerB;);
	subject.unsubscribe(&observerB;);
	subject.subscribe(&observerC;);

	subject.notify(MySubject::ADD);
	subject.notify(MySubject::REMOVE);

	return 0;
}
\end{lstlisting}
Output:
\begin{verbatim}
observerA Got message 0
observerB Got message 0
observerC Got message 0
observerA Got message 1
observerB Got message 1
observerC Got message 1
\end{verbatim}

The calls to subject.notify() cause the subject to traverse its list of observers that have been subscribed and the call to ``(mObservers[i])-$>$update(msg)'' method for each of them.

There may be a small performance hit due to iterating through a list of observers before making the virtual function call.
However, the cost is minimal when compared to the benefits of reduced coupling and increased code reuse.

\paragraph{Observer Pattern example 3}
%\url{https://www.codeguru.com/cpp/cpp/cpp_mfc/patterns/article.php/c837/Applying-Observer-Pattern-in-C-Applications.htm}
This article uses Stair-Master as an example to explain the concept of the Observer Pattern. Stair-Master is a fitness equipment mainly intended for Cardiovascular exercises.
It simulates the effect of climbing stairs and offers different kinds of fitness programs including Fatburn, Cardio, Random and Hill.
The person using the Stair-Master must specify the workout duration, age, effort level and the workout program.
It contains a set of monitors that are used to control and visually indicate the progress of the workout.
Time monitor keeps track of the elapsed workout time and is responsible for stopping the workout after the specified duration.
Heart rate monitor reads the current heart rate and indicates it with respect to low and high values for the current workout program.
Program controller can be used to change the workout program and effort level at any time during the workout.
Calorie monitor displays total calories burned and average caloric burn per minute.

Target heart rate for a person is calculated based on the age and the workout program selected.
Normally, Fatburn programs have lower heart rates when compared with Cardio programs.
Time monitor interacts with the Heart rate monitor to read heart rate every second and with the Calorie monitor to update the total calories burnt.
When the workout program changes, the Program controller informs the Heart rate monitor to recompute the target heart rate.

Time monitor, Heart rate monitor, Program controller and Calorie monitor can be modelled as independent objects, so that they can be used in the design of any Cardio equipment.
Some Stair-Masters can have Distance monitors to show the total floors climbed and the total distance covered in meters.
Also, advanced machines can use a Heart rate variation monitor instead of a Heart rate monitor to indicate the variation in the heart rate over a period of time. 
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/obs1.PNG}}{\caption{Observer Pattern Sample }\label{obs1}}
\end{floatrow}
\end{figure}

\paragraph{Direct Object Interaction}

First, let us see what the problems are in having direct interactions between independent objects.
If the objects are directly interacting with each other, they have to hold a pointer or the reference to the dependent object. This makes it difficult to 

\textit{i)Adding a new dependent object}

In the next version, if the Distance monitor is added to the Stair-Master, the dependency is further increased and the Time monitor should be changed to maintain a reference to the Distance monitor.
The refined dependency graph is shown below
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/obs2.PNG}}{\caption{Observer Pattern Sample }\label{obs2}}
\end{floatrow}
\end{figure}

\textit{ii) Replacing an existing dependent object with a new object}

When a Heart rate variation monitor replaces the Heart rate monitor, the Time monitor and the Program controller needs to be changed (See above diagram for object dependencies).

\textit{iii)Removing an existing dependent object}

It is not necessary for a Cardiovascular equipment to have all the above mentioned monitors. Some Elliptical cross trainers don't have a Heart rate monitor.
Since Time monitor and Program controller maintains direct references to Heart rate monitor, they cannot work without Heart rate monitor.
This makes it impossible to remove Heart rate monitor, even if it is not needed.

\paragraph{Using Observer Pattern}

Observer Pattern can be used to address all the above mentioned problems.
Time monitor, Heart rate monitor, Calorie monitor and Program controller can be treated as Observers and a new object \textbf{Cardio Subject} can be introduced to act as a Subject.
These monitors will not know the existence of each other and they always communicate through the Cardio Subject.
When one of the monitors changes its state (say Time Monitor), it updates the Cardio Subject, which in turn notifies all the monitors.
In response to the notification, the monitors query the Cardio Subject to update their states.
Since the monitors are independent of each other, a new monitor can be easily added, an existing monitor can be removed or replaced with a new one.
Observer Pattern is demonstrated using a complete Visual C++ Stair-Master application.

\paragraph{Change propagation mechanisms}

When the state of the Subject is changed, the Observers must have their states changed.
This section contains two change propagation mechanisms, \textbf{Notification} and \textbf{Polling}, which can be used to maintain state consistency between the Subject and Observers.

\paragraph{1. Notification}

When there is change in Subjects state, its Observers are notified by calling the Notify method.
In response to the notification, the Observers query the required data from the Subject to maintain state consistency.
Observers can even register for specific events of interest and in the occurrence of such an event, the Subject can send notifications only to the interested Observers.

Maintaining self-consistency of the Subject and avoiding redundant notifications are two important issues that should be considered in the Notification process.

\subparagraph{1.1 Maintaining self-consistency of the Subject}

Self-consistency is all about retaining state of the Subject after notifying the Observers.
It is important to make sure that the Subjects state is self-consistent before and after calling Notify method to keep the state of Observers in sync with the Subject.
It is difficult to maintain self-consistency in inherited operations, that too, when Notify method is called in the base class.
A simple example is shown in example of self consistency violation in the Subject is shown in Listing 1.
\begin{lstlisting}[caption={Observer Pattern example, Listing 1 - Self consistency violation in the Subject},language=C++]
INT CDervSubject::Calculate( int nVal )
{
	// Call the base class method, which implements a complicated calculation algorithm
	// and sets the data member m_nResult
	CBaseSubject::Calculate( nVal );	// Calling this method sends a notification to the Observers
	// Specific implementation for the derived class
	if( m_nResult > 1000 )
	{
		m_nResult %= 1000;
	}
	return 0;
}
\end{lstlisting}
In this example, CDervSubject overrides the operation Calculate and calls the base class method, which sends the notification to all the Observers.
The derived class implementation can change the value of the data member m\_nResult, bringing in the problem of self-inconsistency.
To avoid this, GoF suggests the use of Template methods.
Primitive operations can be defined as protected virtual methods that can be overridden by the derived classes and
call the Notify method as the last operation in the template method to maintain self-consistency.
Listing 2 illustrates using template method to maintaining self-consistency of the Subject illustrates this.

\begin{lstlisting}[caption={Listing 2 - Using Template method to maintaining self consistency of the Subject},language=C++]
INT CBaseSubject::Calculate( int nVal )
{
	// Call DoCalculate that can be redefined in derived classes.
	// DoCalculate is a protected virtual method
	DoCalculate( nVal );
	// Notify the Observers about the change
	Notify();
	return 0;
}

INT CBaseSubject::DoCalculate( int nVal )
{
	// Do calculation and set m_nResult
	return 0;
}

INT CDervSubject::DoCalculate( int nVal )
{
	// Call base class method
	CBaseSubject::DoCalculate( nVal );
	// Specific implementation for the derived class
	if( m_nResult > 1000 )
	{
		m_nResult %= 1000;
	}
	return 0;
}
\end{lstlisting}


\subparagraph{1.2 Avoiding redundant notifications}

Sometimes, calling Notify method in each and every state changing method is not necessary.
A single Notify call after all the state changes will avoid redundant notification calls.
In Listing 3, the Observer receives three notification calls instead of one.

\begin{lstlisting}[caption={Listing 2 - Redundant notifications},language=C++]
void CMySubject::SetFont( Font & rFont )
{
	...
	...
	// Update member
	m_Font = rFont;
	...
	...
	Notify(); // Notify the Observers
}

void CMySubject::SetTextColor( Color & rTextColor )
{
	...
	...
	// Update member
	m_TextColor = rTextColor;
	...
	...
	Notify(); // Notify the Observers
}

void CMySubject::SetBkColor( Color & rBkColor )
{
	...
	...
	// Update member
	m_BkColor = rBkColor;
	...
	...
	Notify(); // Notify the Observers
}

void CMySubject::SetAttributes( Font & rFont, Color & rTextColor, Color & rBkColor )
{
   	SetFont( rFont ); // Call SetFont method
   	SetTextColor( rTextColor ); // Call SetTextColor method
   	SetBkColor( rTextColor ); // Call SetBkColor method
}

// Observer code
void CMyObserver::SetAttributes()
{
	...
	...
	m_MySubject.SetAttributes( Font, TextColor, BkColor );
	...
	...
}
\end{lstlisting}

This can be achieved by using a Change Tracker class that has a set of \textbf{Change Tracking methods} (see Listing 4).
To ensure a single notification call at the end of all state changes, CMySubject should inherit from CChangeTracker and implement the methods.
Instead of calling Notify method in all state changing methods, CMySubject calls StartChange before making the change and FinishChange after making the change.
A \textit{change reference count} is incremented during StartChange and decremented during FinishChange and Notify method is called only when the reference count reaches 0.
The advantage of this approach is any number of state changing methods can be called in any sequence and the Observers will be notified only once at the end of all the state changes.
Listing 4 for an example of notification using Change Tracker illustrates this.
\begin{lstlisting}[caption={Listing 4 -Notification using Change Tracker},language=C++]
class CChangeTracker
{
	protected :
		virtual void StartChange() = 0 ;
		virtual void FinishChange() = 0;
};

class CMySubject : public CSubject, protected CChangeTracker
{
	protected :
		virtual void StartChange();
		virtual void FinishChange();
	private :
		INT m_nChangeCount;
};

void CMySubject::StartChange()
{
	m_nChangeCount++;
}

void CMySubject::FinishChange()
{
	m_nChangeCount--;
	if( m_nChangeCount == 0 )
	{
		Notify();
	}
}

// State change operations
void CMySubject::SetFont( Font & rFont )
{
	StartChange();
	...
	...
	m_Font = rFont;
	...
	...
	EndChange();
}

void CMySubject::SetTextColor( Color & rTextColor )
{
	StartChange();
	...
	...
	m_TextColor = rTextColor;
	...
	...
	EndChange();
}

void CMySubject::SetBkColor( Color & rBkColor )
{
	StartChange(); // call StartChange
	...
	...
	m_BkColor = rBkColor; // Update member
	...
	...
	EndChange(); // call EndChange
}

void CMySubject::SetAttributes( Font & rFont, Color & rTextColor, Color & rBkColor )
{
	StartChange();
   	SetFont( rFont );
   	SetTextColor( rTextColor );
   	SetBkColor( rTextColor );
	EndChange();
}
\end{lstlisting}

\subparagraph{Advantages}

    Simple and straightforward implementation in most cases.
    Change in the state of the Subject is immediately propagated to all the Observers.

\subparagraph{Disadvantages}

    Subject can be reused only with the Observer abstraction. This reduces the reusability of the Subject in a totally different context.

    Subject should maintain a list of Observers. In some cases, the Observers may request only for specific events for which the Subject has to notify them.
    Subject should also maintain this information along with the list of Observers, which increases the overhead.

    Since Observers are independent of each other, changing Subjects state in the Update method of an Observer without a well-defined dependency criterion should not be encouraged.
    Doing so may result in 

i) Recursive notification calls.

ii) Inconsistent Observer states, that is each Observer will be in different states at the same time.

\paragraph{2. Polling the subject for state changes}

In this approach, the Observer polls the Subject for state changes.
When the Subject changes, the Observer is not notified with the change, but the Observer uses a polling algorithm to read the state change from the Subject.
Polling is widely used in popular class libraries. MFC uses the polling technique to update user-interface objects. See Polling in MFC for more details.

\paragraph{Advantages}

    The Subject is totally unaware of Observers. It need not maintain the list of Observers and notify them about the state changes.
    Observers take the responsibility of maintaining the state consistency. This increases the reusability of the Subject.

\paragraph{Disadvantages}


    When to poll the Subject. Subject should be polled at the right time, if the Subject is polled too early,
    the Observers will have old state and if the poll is too late, they lose the intermittent states.
    Performance overhead is introduced when polling a Subject, which has not changed.
    Somebody should ask the Observers to poll the Subject. Who notifies the Observer do this can be very big question?

\paragraph{Object Interaction Models}

The Subject and the Observers can interact using a Push Model or a Pull Model.

\subparagraph{Push Model}

In this model, the Subject pushes the state changes to the Observers. Push model can be used when all the Observers are interested in common state changes.
Observers have no choice other than receiving the pushed data. Push model cannot be used with large amount of data, as an Observer may not be interested in all the data that is being pushed.
Also, the Subject must know something about the Observer to which it is pushing the data.
Therefore, the Observers have to comply with a standard interface required by the Subject and the Subjects reusability is limited to these Observers.

\subparagraph{Pull Model}

In this model, the Subject notifies the state change to the Observers and the Observers pull only the required data from the Subject.
Pull model is more flexible and the Observers can pull only the required data. But, more than one method call is required to implement the pull model.
The first method call is for change notification from the Subject to all its Observers and an interested Observer must call at least one more method to pull the data.
In a very dynamic environment, the state of the Subject can change between these two calls, that is before the Observer pulls the data.
Therefore, the Subject and the Observers may not be in sync.
Above all, the Observers call specific methods to pull the required data and it is up to them to figure out what is changed without getting much help from the Subject.
Sample application presented with this article uses the Pull Model.

\paragraph{Benefits}

    The Observer Pattern avoids direct object interactions and can be used when one or more objects are interested in the state changes of a given object.

    It can be used to develop loosely coupled applications maintaining object state dependencies.

    It can be used when the number of state dependent objects is not known in advance or even when the number may even change over time.

    Subject and the Observer objects can be reused separately and they can vary independently.

    The Observer Pattern can be used to develop application in layers.

    For example, a user interface application can contain spreadsheet, graph, and chart objects (Observers, at a higher level) that are dependent on the data from
    a database object (Subject, at a lower level). When the data in the database object changes all the Observers are
    automatically notified through the abstract operation defined in the Observer base class.
    Since the abstract operation is defined in the base class, the Subject need not know the concrete Observer classes and hence they are loosely coupled.

    Since all the Observers are notified through the same abstract operation, it is easy to add or remove Observers on demand.

\paragraph{Liabilities}

    In most situations, Observers will simply be only notified about a state change. It is up to the Observer to find out what exactly has changed.
    However, this can be avoided by including additional information (or the Aspect of change) along with the notification. This will give some clue about the change to the Observer.

    Observer objects are totally independent and they have no knowledge on the existence of the fellow Observers.
    Therefore, an Observer object can change the state of the Subject (in the Update method) before even all the Observers are notified.
    This may result in state inconsistencies and the state change notifications will be lost.

    Whenever an Observer changes the Subjects state, all the dependent Observers are notified. If the dependency criteria is not well defined, recursive updates can easily happen.
    Usually, in Stair-Masters the workout program and the heart rate are mutually dependent.
    That is, when the program changes (say from Fat Burn to Cardio) the heart rate changes and when the heart rate range falls below or goes above a threshold limit the program automatically changes.
    For the sake of simplicity, this dependency criterion is not enforced in the example.
    Assuming that the dependency criterion is not well defined in the example,
    Program controller will update the Cardio Subject when the program changes and Heart rate monitor will recompute the heart rate.
    If the heart rate falls below or goes above the threshold level, the heart rate monitor will update the Cardio Subject to change the program,
    which in turn will update the Program controller and this cycle repeats. Therefore, Heart rate monitor and Program controller blindly updates the Cardio Subject,
    which notifies both these monitors to update themselves resulting in recursive update calls.

    Observer Pattern introduces an additional level of indirection to maintain state consistency. This increases the flexibility in the application design, but has a sure performance impact.
    Also, too many indirections decrease the understandability of the code.

    When the Subject is deleted, the Observers dont have a direct way to know about the deletion. Therefore, the Observers will have dangling reference to the deleted Subjects.

\paragraph{Known Uses}

This section presents known uses of the Observer Pattern. Some of the known uses presented in this section are taken from the GoF book on Design Patterns.

\subparagraph{Polling in MFC}

Observers should poll the Subject at the right time to get its state. In a MFC application, the user-interface objects such as menu items and toolbar buttons are Observers and the document,
view, window or application object is the Subject. MFC uses the polling technique to update these user-interface objects (Observers).
Before a menu drops down or during the idle loop in the case of toolbar buttons, MFC routes an update command.
The handler for the update command (defined using ON\_UPDATE\_COMMAND\_UI) is called in the right object to enable/disable the menu item or the toolbar button.
Using polling in this case is advantageous because of the following reasons:

    MFC can defer updating the user-interface objects till the occurrence of a specific event.
    Therefore, toolbar states can be updated when the application is idle and menu items can be updated when the menu drops down.
    Menu item or the toolbar button state purely depends on the current state of the Subject (state contained in document, view, window or application) and not its old state.
    Therefore, the user-interface objects need not update their states for every state change in the Subject.

\subparagraph{MFC's Document/View Architecture}

MFC's Document/View architecture uses the Observer Pattern. A document contains the data object and acts as a Subject.
A view is a window object through which the user updates the document and it acts as an Observer.
A document can have multiple views. Whenever the data in the document is changed by one of the views,
it updates the document by calling UpdateAllViews method, with optional hint about the modification. To inform about the change to other views,
the document object calls OnUpdate method for each view attached to it (except the view that called UpdateAllViews).
Derived view classes can override the OnUpdate method and update themselves by querying the data from the document.

\subparagraph{Model/View/Controller in Smalltalk}

The first and perhaps the best-known example of the Observer Pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment.
MVC's model class plays the role of Subject, while View is the base class for Observers.

\subparagraph{Observer and Publish/Subscribe}

Due to the object interaction, the Observer Pattern is also referred as Publish/Subscribe.
Observers subscribe to the Subject for change notifications and in-turn the Subject publishes the state changes to the subscribed Observers.
Publish/Subscribe (also called as Publisher/Subscriber) can be viewed as a variant of the Observer Pattern.
Even though, the intent of both these Patterns is same, Publisher/Subscriber tries to address some of the implementation limitations of the Observer Pattern.
In my next article, I will be talking about Publisher/Subscriber Pattern in detail.

\paragraph{Summary}

Many objects work in unison behind a complex object oriented application. Handling the state dependencies between these objects is a major task.
This article showed how the Observer Pattern could be used to maintain state consistencies.
It started with a common programming problem, then it explained what, when and why the Observer Pattern is needed with a simple example.
Benefits, liabilities, and known uses of the Pattern is also presented.
The Observer Pattern can help to maintain the state consistencies between objects, and enhance the correctness and the quality of the system.
However, it is not the silver bullet for solving all object interaction problems.

\paragraph{Observer pattern variations}

There are some variation of the Observer pattern.

\subparagraph{Signal and Slots}

    Signals and slots is a language construct introduced in Qt, which makes it easy to implement the Observer pattern while avoiding boilerplate code.
    The concept is that controls (also known as widgets) can send signals containing event information which can be received by other controls using special functions known as slots.
    The slot in Qt must be a class member declared as such.

    The signal/slot system fits well with the way Graphical User Interfaces are designed.
    Similarly, the signal/slot system can be used for asynchronous I/O (including sockets, pipes, serial devices, etc.) event notification or
    to associate timeout events with appropriate object instances and methods or functions.
    No registration/deregistration/invocation code need be written, because Qt's Meta Object Compiler (MOC) automatically generates the needed infrastructure.
 \subparagraph{C\# Events and Delegates}

The C\# language also supports a similar construct although with a different terminology and syntax: events play the role of signals, and delegates are the slots.
Additionally, a delegate can be a local variable, much like a function pointer, while a slot in Qt must be a class member declared as such.
\chapter{Template Method Pattern}\label{TemplateMethodPattern}

\paragraph{Intent}
Define the skeleton of an algorithm in an operation, deferring some steps to subclasses.

Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure. 

\paragraph{This pattern is all about creating a template for an algorithm.} So, what's a template?
It's just a method; it's a method that defines an algorithm as a set of steps.
One or more of these steps is defined to be abstract and implemented by a subclass.
This ensures the algorithm's structure stays unchanged while subclasses provide some part of the implementations.

\paragraph{Let's look at the diagram.}

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/templatem.PNG}}{\caption{Template Method Pattern}\label{templatemp}}
\end{floatrow}
\end{figure}


    The AbstractClass contains the template method. The abstract versions of the operations used in the template method.

    There may be many ConcreteClasses, each implementing the full set of operations required by the template method.

    The ConcreteClasses implements the abstract operations, which are called when the templateMethod() needs them.

    The template method makes use of the primativeOperations to implement an algorithm. It is decoupled from the actual implementation of these operations.


\begin{lstlisting}[caption={Template Method Pattern Sample 1}, language=C++]
#include <iostream>
using namespace std;
 
class AbstractClass //interface
{
public:
	void templateMethod()// this function define the method invoke sequence
    {
		primitiveOperation1();
		primitiveOperation2();
		concreteOperation();
		hook();
	}
	virtual void primitiveOperation1() = 0;
	virtual void primitiveOperation2() = 0;
	void concreteOperation() {cout<<"Mandatory Operations for all ConcreteClasses"<<endl;}
	virtual void hook() {}
};
 
class ConcreteClassA : public AbstractClass 
{
public:
  void primitiveOperation1() { cout << "primitiveOp1 A" << endl; }
  void primitiveOperation2() { cout << "primitiveOp2 A" << endl; }
};

class ConcreteClassB : public AbstractClass 
{
    public:
      void primitiveOperation1() { cout << "primitiveOp1 B" << endl; }
      void primitiveOperation2() { cout << "primitiveOp2 B" << endl; }
      void hook() { cout << "hook() B" << endl; }
};
 
int main()
{
  ConcreteClassA ca;
  ConcreteClassB cb;
  ca.templateMethod();
  cb.templateMethod();
  return 0;
}
\end{lstlisting}

Output:
\begin{verbatim}
primitiveOp1 A
primitiveOp2 A
Mandatory Operations for all ConcreteClasses
primitiveOp1 B
primitiveOp2 B
Mandatory Operations for all ConcreteClasses
hook() B
\end{verbatim}


\paragraph{Let's summarize what's done.}

    Note that the templateMethod() defines the sequence of steps, each represented by a method.
    Two of the primitive operations must be implemented by concrete subclasses.

\begin{verbatim}
    virtual void primitiveOperation1() = 0;
    virtual void primitiveOperation2() = 0;
\end{verbatim}

    A concrete operation is defined in the abstract class.
    This one is not declared as virtual so that subclasses can't override it. It may be used in the template method directly, or used by subclasses.

\begin{verbatim}
    void concreteOperation() {cout<<"Mandatory Operations for all ConcreteClasses"<<endl;}
\end{verbatim}
    We can also have concrete methods that do nothing by default we call these hooks. Subclasses are free to override these but don't have to.

\begin{verbatim}
    virtual void hook() {}
\end{verbatim}


\paragraph{Sample B}
This example has two concrete classes derived from OperationTemplate class which provides 3 interfaces: read\_input(), write\_output, and operate().
The two derived classes perform different operations while sharing the same interfaces that template design pattern provides.

\begin{lstlisting}[caption={Template Method Pattern Sample 2}, language=C++]
#include <iostream>
#include <algorithm>
#include <cassert>
#include <iterator>
#include <list>
#include <map>
#include <sstream>
#include <string>
#include <utility>
using namespace std;

class OperationTemplate
{
public:
    typedef std::map<std::string, std::string> Arguments;

public:
    bool solve(const Arguments &input, Arguments &output)
    {
        assert(output.empty());

        if (!read_input(input)) { return false; }
        if (!operate()) { return false; }
        write_output(output);

        return true;
    }

protected:
    virtual bool read_input(const Arguments &input;) = 0;
    virtual bool operate() = 0;
    virtual void write_output(Arguments &output;) const = 0;

public:
    virtual ~OperationTemplate() { }
};

class MathOperation : public OperationTemplate
{
public:
    MathOperation(): mx(0), my(0), mOperation(0), mResult(0) { }

private:
    bool read_input(const Arguments &input;)
    {
        Arguments::const_iterator i = input.find("x");
        if (input.end() == i) { return false; }
        std::istringstream in(i->second);
        in >> mx;
        if (in.fail()) { return false; }

        i = input.find("y");
        if (input.end() == i) { return false; }
        in.clear();
        in.str(i->second);
        in >> my;
        if (in.fail()) { return false; }

        i = input.find("operation");
        if (input.end() == i || i->second.size() != 1) { return false; }
        mOperation = i->second[0];

        return true;
    }

    bool operate()
    {
        switch (mOperation)
        {
            case '+':
                mResult = mx + my;
                break;
            case '-':
                mResult = mx - my;
                break;
            case '*':
                mResult = mx * my;
                break;
            case '/':
                if (0 == my) { return false; }
                mResult = mx / my;
                break;
            default:
                return false;
        }

        return true;
    }

    void write_output(Arguments &output;) const
    {
        std::ostringstream out;
        out << mResult;
        output.insert(std::make_pair(std::string("result"), out.str()));
    }

private:
    int mx, my, mResult;
	char mOperation;
};

class ListOperation : public OperationTemplate
{
private:
    bool read_input(const Arguments &input;)
    {
        mList.clear();

        Arguments::const_iterator i = input.find("array");
        if (input.end() == i) { return false; }
        std::istringstream in(i->second);
        typedef std::istream_iterator<int> T;
        std::copy(T(in), T(), std::back_inserter(mList));
        if (!in.eof()) return false;
        return true;
    }

    bool operate()
    {
        mList.reverse();
        return true;
    }

    void write_output(Arguments &output;) const
    {
        std::ostringstream out;
        std::copy(mList.begin(), mList.end(), std::ostream_iterator<int>(out, " "));
        output.insert(std::make_pair(std::string("result"), out.str()));
    }

private:
    std::list<int> mList;
};

int main()
{
  map<string, string> myInput, myOutput;

  // 10 + 20 = 30
  myInput.insert(make_pair("x", "10"));
  myInput.insert(make_pair("y", "20"));
  myInput.insert(make_pair("operation", "+"));
  MathOperation a;
  a.solve(myInput, myOutput);
  cout << myOutput["result"] << endl;

  myInput.clear();
  myOutput.clear();

  // 1 2 3 4 5 -> 5 4 3 2 1
  myInput["array"] = "1 2 3 4 5";
  ListOperation b;
  b.solve(myInput, myOutput);
  cout << myOutput["result"] << endl;

  return 0;
}
\end{lstlisting}


\chapter{Strategy Pattern}\label{StrategyPattern}

\paragraph{Intent}
The strategy pattern is intended to provide a means to define a family of algorithms, encapsulate each one as an object, and make them interchangeable.

The strategy pattern lets the algorithms vary independently from clients that use them.

\paragraph{Diagram}\mbox{}
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/strategy1.PNG}}{\caption{Strategy Pattern}\label{strategyp}}
\end{floatrow}
\end{figure}
\paragraph{Strategy Pattern Exmaple 1}\mbox{}

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/strategy2.PNG}}{\caption{Exmaple 1}\label{strategyp2}}
\end{floatrow}
\end{figure}

\begin{lstlisting}[caption={Strategy Pattern Sample 1}, language=C++]
class SortBehavior //sort algorithm interface
{
    public:
        virtual void sort() const = 0;
};
 
class Merge: public SortBehavior //concrete algorithm
{
    public:
        virtual void sort() const { cout << "Merge sort()\n"; }
};
 
class Quick: public SortBehavior {
    public:
        virtual void sort() const { cout << "Quick sort()\n"; }
};
 
class Heap: public SortBehavior
{
    public:
        virtual void sort() const { cout << "Heap sort()\n"; }
};
 
class SearchBehavior//search algorithm interface 
{
    public:
        virtual void search() const = 0;
};
 
class Sequential: public SearchBehavior 
{
    public:
        virtual void search() const { cout << "Sequential search()\n"; }
};

class BinaryTree: public SearchBehavior 
{
    public:
        virtual void search() const { cout << "BinaryTree search()\n"; }
};

class HashTable: public SearchBehavior 
{
    public:
        virtual void search() const { cout << "HashTable search()\n"; }
};

// Context
class Collection 
{
    public:
        Collection(){}
        void set_sort(SortBehavior* s){ m_sortBhv = s; }
        void set_search(SearchBehavior* s){ m_searchBhv = s; }
        void sort() const { m_sortBhv->sort(); }
        void search() const { m_searchBhv->search(); }
    private:
        SortBehavior* m_sortBhv;
        SearchBehavior* m_searchBhv;
};
 
int main(int argc, char *argv[])
{
    Merge merge;//sort objects
    Quick quick;
    Heap heap;

    Sequential sequential;//search objects
    BinaryTree binaryTree;
    HashTable hashTable;
 
    Collection colA;
    colA.set_sort(&merge;);
    colA.sort();

    Collection colB;
    colB.set_search(&binaryTree;);
    colB.search();

    return 0;
}
\end{lstlisting}
Output from the run:
\begin{verbatim}
Merge sort()
BinaryTree search()
\end{verbatim}

\paragraph{Explanation}
We have two interfaces: ``SortBehavior'' and ``SearchBehavior'' along with corresponding classes that implement each concrete behavior.
With the design, other types of objects can reuse our search and sort behaviors because these behaviors are no longer hidden away in our Collection classes.
And we can \textbf{add new behaviors without modifying any of our existing behavior classes}.
We put instance variables hold a pointer to a specific behavior at runtime.

\begin{verbatim}
class Collection {
    private:
        SortBehavior* m_sortBhv;//pointer to base class
        SearchBehavior* m_searchBhv;//pointer to base class
\end{verbatim}

    Using the pointers, we can implement each behavior,

\begin{verbatim}
          void sort() const { m_sortBhv->sort(); }
    	  void search() const { m_searchBhv->search(); }
\end{verbatim}
    Rather than handling the sort behavior itself, the Collection object \textit{delegates} that behavior to the object pointed by ``m\_sortBhv''.

\begin{verbatim}
    colA.set_sort(&merge;);
    colA.sort();
    =>
    Collection::m_sortBhv->sort();
    ==>
    virtual void sort() const{ cout << "Merge sort()\n"; }
\end{verbatim}
    We do not care what kind of collection object it is, all we care about is that it knows how to sort().
    Actually, we've created system using composition giving us a lot more flexibility.
    Not only does it let us encapsulate a family of algorithm into their own set of classes,
    but it also let us change behavior at runtime as long as the object we're composing with implements the correct behavior interface.

\paragraph{Strategy Pattern Exmaple 2}
In this sample, we have two ways of recording contact information: stream \& database.
The two classes (StreamRecord and DatabaseRecord) share the same interface for their own implementation of recording data via base class member functionality
store() which has all the shared implementation methods (actually, API).


\begin{lstlisting}[caption={Strategy Pattern Sample 2}, language=C++]
class Record
{
public:
    virtual void start_record() = 0;
    virtual void store_field(const string &name, const string &value) = 0;
    virtual void finish_record() = 0;
    virtual ~Record() { }
};

struct ContactData { string first_name, last_name, phone, email; };

class ContactRecorder
{
public:
    ContactRecorder(Record *a) : m_Record(a) { assert(a != 0); }
    void store(const ContactData &data)
    {
        assert(m_Record != 0);

        m_Record->start_record();
        m_Record->store_field("first name", data.first_name);
        m_Record->store_field("last name", data.last_name);
        m_Record->store_field("phone", data.phone);
        m_Record->store_field("email", data.email);
        m_Record->finish_record();
    }
private:
    Record *m_Record;//pointer to base class
};

class StreamRecord : public Record
{
public:
    StreamRecord(ostream &s, const string &record_name = string())
        : m_ostream(s), m_record_name(record_name) { } 
    void start_record() { m_ostream << m_record_name << "( "; }
    void store_field(const string &name, const string &value)
    {
        m_ostream << name << ": " << value << "; ";
    }
    void finish_record() { m_ostream << ")" << endl; }
    void set_record_name(const string &name;) { m_record_name = name; }
private:
    ostream &m_ostream;
    string m_record_name;
};

class MySql {};

class DatabaseRecord : public Record
{
public:
    DatabaseRecord() : m_dbConnection(new MySql) {}
    void start_record() { cout << "start transaction\n"; }
    void store_field(const string &name, const string &value;)
                { cout << "insert into table\n"; }
    void finish_record() { cout << "finish transaction\n"; }
private:
    MySql *m_dbConnection;
};

int main()
{
	ContactData data = {"Black", "Smith", "415-675-1874", "adams@email.com"};
	StreamRecord sRecord(std::cout);
	ContactRecorder contact(&sRecord;);
	contact.store(data);

	DatabaseRecord dbRecord;
	ContactRecorder contact2(&dbRecord;);
	contact2.store(data);
	return 0;
}
\end{lstlisting}


\paragraph{Strategy Pattern Exmaple 3}
A Strategy defines a set of algorithms that can be used interchangeably.
Modes of transportation to an airport is an example of a Strategy.
Several options exist such as driving one's own car, taking a taxi, an airport shuttle, a city bus, or a limousine service.
For some airports, subways and helicopters are also available as a mode of transportation to the airport.
Any of these modes of transportation will get a traveler to the airport, and they can be used interchangeably.
The traveler must chose the Strategy based on trade-offs between cost, convenience, and time.

\textbf{Discussion.} The Strategy pattern suggests: encapsulating an algorithm in a class hierarchy, having clients of that algorithm hold a pointer to the base class of that hierarchy, 
and delegating all requests for the algorithm to that "anonymous" contained object.

In this example, the Strategy base class knows how to collect a paragraph of input and implement the skeleton of the "format" algorithm.
It defers some details of each individual algorithm to the "justify" member which is supplied by each concrete derived class of Strategy.
The TestBed class models an application class that would like to leverage the services of a run-time-specified derived "Strategy" object.

\begin{lstlisting}[caption={Strategy Pattern Sample 3}, language=C++]
#include <iostream.h>
#include <fstream.h>
#include <string.h>

class Strategy;

class TestBed
{
  public:
    enum StrategyType { Dummy, Left, Right, Center };
    TestBed() { strategy_ = NULL; }
    void setStrategy(int type, int width);
    void doIt();
  private:
    Strategy *strategy_;
};

class Strategy
{
  public:
    Strategy(int width): width_(width){}
    void format()
    {
        char line[80], word[30];
        ifstream inFile("quote.txt", ios::in);
        line[0] = '\0';

        inFile >> word;
        strcat(line, word);
        while (inFile >> word)
        {
            if (strlen(line) + strlen(word) + 1 > width_)
              justify(line);
            else
              strcat(line, " ");
            strcat(line, word);
        }
        justify(line);
    }
  protected:
    int width_;
  private:
  /*private virtual functions can be overridden in the derived classes,
  allows for better "separation of the specification of interface from 
  the specification of the implementation's customizable behavior".
  */
    virtual void justify(char *line) = 0;
};

class LeftStrategy: public Strategy
{
  public:
    LeftStrategy(int width): Strategy(width){}
  private:
     /* virtual */void justify(char *line)
    {
        cout << line << endl;
        line[0] = '\0';
    }
};

class RightStrategy: public Strategy
{
  public:
    RightStrategy(int width): Strategy(width){}
  private:
     /* virtual */void justify(char *line)
    {
        char buf[80];
        int offset = width_ - strlen(line);
        memset(buf, ' ', 80);
        strcpy(&(buf[offset]), line);
        cout << buf << endl;
        line[0] = '\0';
    }
};

class CenterStrategy: public Strategy
{
  public:
    CenterStrategy(int width): Strategy(width){}
  private:
     /* virtual */void justify(char *line)
    {
        char buf[80];
        int offset = (width_ - strlen(line)) / 2;
        memset(buf, ' ', 80);
        strcpy(&(buf[offset]), line);
        cout << buf << endl;
        line[0] = '\0';
    }
};

void TestBed::setStrategy(int type, int width)
{
  delete strategy_;
  if (type == Left)
    strategy_ = new LeftStrategy(width);
  else if (type == Right)
    strategy_ = new RightStrategy(width);
  else if (type == Center)
    strategy_ = new CenterStrategy(width);
}

void TestBed::doIt()
{
  strategy_->format();
}

int main()
{
  TestBed test;
  int answer, width;
  cout << "Exit(0) Left(1) Right(2) Center(3): ";
  cin >> answer;
  while (answer)
  {
    cout << "Width: ";
    cin >> width;
    test.setStrategy(answer, width);
    test.doIt();
    cout << "Exit(0) Left(1) Right(2) Center(3): ";
    cin >> answer;
  }
  return 0;
}
\end{lstlisting}
Output:
\begin{verbatim}
Exit(0) Left(1) Right(2) Center(3): 2
Width: 75
Exit(0) Left(1) Right(2) Center(3): 3
Width: 75
\end{verbatim}

The important lesson we have learned is that development for reuse is complex.
If making a good design is difficult, then making a good reusable design is even harder, and any amount of process description cannot substitute for the skill,
imagination, and experience of a good designer. A process can only support the creative work, and ensure that things are done and recorded properly.
\paragraph{Strategy Pattern Exmaple 4}
%\url{https://www.codeguru.com/cpp/cpp/cpp_mfc/patterns/article.php/c845/Applying-Strategy-Pattern-in-C-Applications.htm}
\textbf{Software consulting companies} do projects for their customers on a "Fixed Price basis" or on a "Time and Material basis".
Also, the projects can be either onsite or offsite. Usually, the customers specify how they want the project to be done (Fixed price or Time and Material basis, onsite or offsite).
The ultimate aim of the consulting company is to complete the project in the scheduled time, however the Strategy (or the policy) they adapt in doing the project may differ,
depending on how they do the project. This is a real life example, where a Strategy Pattern is applied. 

\textbf{A progress indicator} is a window that an application can use to indicate the progress of a lengthy operation (for example, an Installation Process).
It is usually a rectangular window that is gradually filled, from left to right, with the highlight color as the operation progresses.
It has a range and a current position. The range represents the entire duration of the operation,
and the current position represents the progress the application has made towards completing the operation.
The range and the current position are used to determine the percentage of the progress indicator to fill with the highlight color.

Even though left to right direction is commonly used for filling in most progress indicators, other directions like right to left, top to bottom and bottom to top can also be used for filling.
I have seen some progress indicators using a bottom to top filling. Also, different types of fills like continuous fill, broken fill or pattern based fills can be used with a given filling direction.

In short, the purpose of the progress indicator remains unchanged; however, the filling direction or the filling algorithm can change.
Therefore, the family of algorithms used for filling can be encapsulated in a separate filler class hierarchy and the application can configure the progress indicator with a concrete filler class.
An algorithm that is encapsulated in this way is called a Strategy.

So, what is a Strategy Pattern? The Strategy Pattern is a design pattern to encapsulate the variants (algorithms) and swap them strategically to alter system behavior without changing its architecture.
According to GoF, Strategy Pattern is intended to, Define a family of algorithms, encapsulate each one, and make them interchangeable.
Strategy lets the algorithm vary independently from clients that use it.

Strategy Pattern has three participants that include \textit{Strategy, Concrete Strategy and Context}.
In this example, the abstract filler class \textit{CFiller}, is referred as the Strategy,
the concrete filler classes \textit{CLToRFiller} (for providing Left to Right fill) and \textit{CRToLFiller} (for providing Right to Left fill) are referred as Concrete Strategies and
the progress indicator \textit{CProgressIndicator}, is referred as the Context using Strategy.
The application using the progress indicator is the client for the Context.
Depending on the situation, the client specifies the progress indicator (Context) with a concrete filler class object (Concrete Strategy). 

Push and Pull methods can be used to provide a means of safe data exchange and reduce the coupling between the Context and Strategy objects.
In the Push method, the Context pushes the data to the Strategy object and the Strategy uses the data to implement the algorithm. 
In this method, Context might pass some unwanted data to the Strategy object, as all Concrete Strategy objects might not require all the data.
On the other hand, in the Pull method, the Context, registers itself with the Strategy which in-turn maintains a reference to the Context object and pulls the required data from it.
In this method, the Context must define an elaborate set of Get methods for the Strategy objects to pull the required data.
Since, the Strategy maintains a reference to the Context, both the classes are tightly coupled. The choice of Push or Pull method purely depends on the requirement.

This article discusses three different approaches for implementing the Strategy Pattern in C++. The approaches described below can use either a Push or Pull method.
\paragraph{Approach 1: trategy object as a \textcolor{red}{required} parameter to the context}

In this approach, the progress indicator (Context) takes a filler (Strategy) object as a parameter in its constructor and maintains a reference to it.
The progress indicator delegates the request to the filler object when ``SetPos()'' method is called. 
Listing 1 shows this approach. Also, Layout Manager in Java uses this approach, see Java and Strategy Pattern for explanation.

\textbf{Advantage}

    The progress indicator depends only on the interface of the filler class and does not interact directly with the concrete subclasses of the filler class.

    Application can select the required filler class object at run-time. SetFiller() method can be used to change the filler class object after creating the progress indicator.

\textbf{Disadvantage}

    Application using the progress indicator must be aware of all the filler classes and must supply the progress indicator with the required filler class object.

    Progress indicator is not having any control on the scope or the lifetime of the filler class object. 
\begin{lstlisting}[caption={Strategy Pattern Sample 4: Approach 1 - Strategy object as a \textcolor{red}{required} parameter to the Context}, language=C++]
class CFiller; // Forward declaration for CFiller class
 
class CProgressIndicator//Context
{
	public:
		CProgressIndicator(CFiller *);
		INT SetPos(INT);
		INT SetFiller(CFiller *);
	protected:
		CFiller * m_pFiller;
};
 
CProgressIndicator::CProgressIndicator(CFiller * pFiller)
{
	ASSERT(pFiller != NULL); // Validate pFiller 
	m_pFiller = pFiller;
}
 
INT CProgressIndicator::SetPos(INT nPos)
{
	// Some initialization code before forwarding the request to filler object
		
	INT nStatus = m_pFiller->DoFill(); // Request forwarding to filler object
		
	return nStatus;
}
 
INT * CProgressIndicator::SetFiller(CFiller * pFiller)
{
	ASSERT(pFiller != NULL); // Validate pFiller
	m_pFiller = pFiller; // Set new filler object
	return 0;
}
\end{lstlisting}
\paragraph{Approach 2: Strategy object as an \textcolor{red}{optional} parameter to the Context}

This approach is similar to the first approach, but the filler object (Strategy) is taken as an optional parameter when progress indicator (Context) is created.
The progress indicator creates a default filler object (Left to Right filler), if the application did not specify the filler object during construction.
Listing 2 contains C++ sample showing this approach. Demo application provided with this article uses this technique.

\textbf{Advantage}

    Application can specify the filler object only when it needs to change the default filler object.

    Application can select the required filler class object at run-time. SetFiller method can be used to change the filler class object after creating the progress indicator.

\textbf{Disadvantage}

    Progress indicator must be aware of the concrete filler class CLToRFiller, for providing the default behavior. This increases the coupling between the CProgressIndiator and CLToRFiller classes.

    Progress indicator has control only on the lifetime of the default filler object, which is CLToRFiller object in this case.
    But, it is not having any control on the scope or the lifetime of other filler class objects. 
\begin{lstlisting}[caption={Strategy Pattern Sample 4: 2 - Strategy object as an \textcolor{red}{optional} parameter to the Context}, language=C++]
class CFiller;
 
class CProgressIndicator
{
	public:
		CProgressIndicator(CFiller * = NULL);
		virtual ~CProgressIndicator();
		INT SetPos(INT);
		INT SetFiller(CFiller *);
	protected:
		CFiller * m_pFiller;
		BOOL	 m_bCreated;
};
 
CProgressIndicator ::CProgressIndicator(CFiller * pFiller)
 {
	if(pFiller == NULL)
	{
		// Create a default Left to Right filler object
		m_pFiller = new CLToRFiller;
		m_bCreated = TRUE;
	}
	else
	{
		m_pFiller = pFiller;
		m_bCreated = FALSE;
	}
}
 
CProgressIndicator::~CProgressIndicator()
{
	if(m_bCreated == TRUE) // Delete filler object, only if it is created by the progress indicator
	{
		delete m_pFiller;
	}
}
 
INT CProgressIndicator::SetPos(INT nPos)
{
	// Some initialization code before forwarding the request to CFiller object
	ASSERT(m_pFiller != NULL);
	// Request forwarding to CFiller object
	INT nStatus = m_pFiller->DoFill();
			
	return nStatus;
}
 
INT * CProgressIndicator::SetFiller(CFiller * pFiller)
{
	ASSERT(pFiller != NULL);
	// Delete filler object, only if it is created by the progress indicator
	if(m_bCreated == TRUE)
	{
		delete m_pFiller;
		m_bCreated = FALSE;
	}
	m_pFiller = pFiller;
	return 0;
}
\end{lstlisting}
\paragraph{Approach 3: Strategy as a template class parameter to the Context}

If there is no need to change the filler class (Strategy) at run time, it can be passed as a template parameter to the progress indicator (Context) class at compile time.
Listing 3 shows this approach.
Active Template Library (ATL) uses a variation of this approach to select the required CCOMObjectxxx<> in which the Context is passed as a parameter to the Strategy class (Pull method).
See ATL and Strategy Pattern for explanation.

\textbf{Advantage}

    Progress indicator template class is instantiated only with concrete filler classes, so there is no need for the abstract CFiller class.

    Passing filler class as a template parameter provides an early binding between the progress indicator and the filler classes. This avoids runtime overhead and increases the efficiency.

    Progress indicator is responsible for the creation of the filler class object. Therefore, it has full control on the lifetime of the object.

\textbf{Disadvantage}

    Selecting filler class at compile time provides no room for changing the object at runtime. 
\begin{lstlisting}[caption={Strategy Pattern Sample 4: 3 - Strategy as a template class parameter}, language=C++]
template <class TFiller> class CProgressIndicator
{
	public:
		INT SetPos(INT);
	protected:
		TFiller m_theFiller;
};
 
// CProgressIndicator - Implementation
INT CProgressIndicator ::SetPos(INT nPos)
{
	// Some initialization code before forwarding the request to CFiller object
			
	INT nStatus = m_theFiller.DoFill();
			
	return nStatus;
}
 
CProgressIndicator LtoRFillerObj; // Application code using CProgressIndicator
\end{lstlisting}
\paragraph{Rules of thumb}

    Strategy is like Template Method~\ref{TemplateMethodPattern} except in its granularity.

    State~\ref{StatePattern} is like Strategy except in its intent.

    Strategy lets you change the guts of an object. Decorator~\ref{DecoratorPattern} lets you change the skin.

    State, Strategy, Bridge~\ref{BridgePattern} (and to some degree Adapter~\ref{AdapterPattern}) have similar solution structures.
    They all share elements of the ``handle-body'' idiom. They differ in intent - that is, they solve different problems.
    Strategy is mainly concerned in encapsulating algorithms, whereas Bridge decouples the abstraction from the implementation, to provide different implementation for the same abstraction. 

    Strategy has 2 different implementations, the first is similar to State. The difference is in binding times (Strategy is a bind-once pattern, whereas State is more dynamic).

    Strategy objects often make good Flyweights~\ref{FlyweightPattern}.

\paragraph{Benefits in using Strategy Pattern}

    A family of algorithms can be defined as a class hierarchy and can be used interchangeably to alter application behavior without changing its architecture.

    By encapsulating the algorithm separately, new algorithms complying with the same interface can be easily introduced.

    The application can switch strategies at run-time.

    Strategy enables the clients to choose the required algorithm, without using a "switch" statement or a series of "if-else" statements.

    Data structures used for implementing the algorithm is completely encapsulated in Strategy classes. Therefore, the implementation of an algorithm can be changed without affecting the Context class.

    Strategy Pattern can be used instead of sub-classing the Context class. Inheritance hardwires the behavior with the Context and the behavior cannot be changed dynamically.

    The same Strategy object can be strategically shared between different Context objects. However, the shared Strategy object should not maintain states across invocations.

\paragraph{Drawbacks in using Strategy Pattern}

    The application must be aware of all the strategies to select the right one for the right situation.

    Strategy and Context classes may be tightly coupled. The Context must supply the relevant data to the Strategy for implementing the algorithm and sometimes,
    all the data passed by the Context may not be relevant to all the Concrete Strategies.

    Context and the Strategy classes normally communicate through the interface specified by the abstract Strategy base class.
    Strategy base class must expose interface for all the required behaviors, which some concrete Strategy classes might not implement.

    In most cases, the application configures the Context with the required Strategy object. Therefore, the application needs to create and maintain two objects in place of one.

    Since, the Strategy object is created by the application in most cases; the Context has no control on lifetime of the Strategy object.
    However, the Context can make a local copy of the Strategy object. But, this increases the memory requirement and has a sure performance impact.
\chapter{Chain of Responsibility}\label{ChainofResponsibilityPattern}

\paragraph{Intent}

    Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.
    Chain the receiving objects and pass the request along the chain until an object handles it.

    Launch-and-leave requests with a single processing pipeline that contains many possible handlers.

    An \textbf{object-oriented linked list} with recursive traversal.
\paragraph{Structure}
The derived classes know how to satisfy Client requests. If the "current" object is not available or sufficient, then it delegates to the base class,
which delegates to the "next" object, and the circle of life continues.

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.5]{./dppic/corstructure.PNG}}{\caption{Chain of Responsibility structure}\label{corstructure}}
\end{floatrow}
\end{figure}

Multiple handlers could contribute to the handling of each request. The request can be passed down the entire length of the chain, with the last link being careful not to delegate to a "null next".

\paragraph{Exmaple }
    Put a "next" pointer in the base class

    The "chain" method in the base class always delegates to the next object

    If the derived classes cannot handle, they delegate to the base class

\begin{lstlisting}[caption={sample code 1}, language=C++]
#include <iostream>
#include <vector>
#include <ctime>
using namespace std;

class Base
{
    Base *next; // 1. "next" pointer in the base class
  public:
    Base() { next = 0; }
    void setNext(Base *n) { next = n; }
    void add(Base *n)
    {
        if (next)
          next->add(n);
        else
          next = n;
    }
    // 2. The "chain" method in the base class always delegates to the next obj
    virtual void handle(int i) { next->handle(i); }
};

class Handler1: public Base
{
  public:
     /*virtual*/void handle(int i)
    {
        if (rand() % 3)
        {
            // 3. Don't handle requests 3 times out of 4
            cout << "H1 passed " << i << "  ";
            Base::handle(i); // 3. Delegate to the base class
        }
        else
          cout << "H1 handled " << i << "  ";
    }
};

class Handler2: public Base
{
  public:
     /*virtual*/void handle(int i)
    {
        if (rand() % 3)
        {
            cout << "H2 passed " << i << "  ";
            Base::handle(i);
        }
        else
          cout << "H2 handled " << i << "  ";
    }
};

class Handler3: public Base
{
  public:
     /*virtual*/void handle(int i)
    {
        if (rand() % 3)
        {
            cout << "H3 passed " << i << "  ";
            Base::handle(i);
        }
        else
          cout << "H3 handled " << i << "  ";
    }
};

int main()
{
  srand(time(0));
  Handler1 root;
  Handler2 two;
  Handler3 thr;
  root.add(&two);
  root.add(&thr);
  thr.setNext(&root);
  for (int i = 1; i < 10; i++)
  {
    root.handle(i);
    cout << '\n';
  }
}
\end{lstlisting}
Output
\begin{verbatim}
H1 passed 1  H2 passed 1  H3 passed 1  H1 passed 1  H2 handled 1
H1 handled 2
H1 handled 3
H1 passed 4  H2 passed 4  H3 handled 4
H1 passed 5  H2 handled 5
H1 passed 6  H2 passed 6  H3 passed 6  H1 handled 6
H1 passed 7  H2 passed 7  H3 passed 7  H1 passed 7  H2 handled 7
H1 handled 8
H1 passed 9  H2 passed 9  H3 handled 9
\begin{verbatim}

\paragraph{Exmaple 2}

\begin{lstlisting}[caption={sample code 2}, language=C++]
#include <iostream>
#include <string>
using namespace std;

class Photo 
{
public:
    Photo(string s):mTitle(s) {cout<<"Processing"<<mTitle<< " ...\n";}
private:
    string mTitle;
};

class PhotoProcessor
{
public:
    PhotoProcessor() : mNextProcessor(0){ }

    void process(Photo &p) 
    {
        processImplementation(p);
        if (mNextProcessor != 0) 
            mNextProcessor->process(p);
    }

    virtual ~PhotoProcessor() { }
    void setNextProcessor(PhotoProcessor *p) { mNextProcessor = p; }

protected:
    virtual void processImplementation(Photo &a) = 0;

private:
    PhotoProcessor *mNextProcessor;
};

class Scale : public PhotoProcessor
{
public:
    enum SCALE { S50, S100, S200, S300, S500 };
    Scale(SCALE s) : mSCALE(s) { }

private:
    void processImplementation(Photo &a) { cout << "Scaling photo\n"; }
    SCALE mSCALE;
};

class RedEye : public PhotoProcessor
{
private:
    void processImplementation(Photo &a) { cout << "Removing red eye\n"; }
};

class Filter : public PhotoProcessor
{
private:
    void processImplementation(Photo &a) { cout << "Applying filters\n"; }
};

class ColorMatch : public PhotoProcessor
{
private:
    void processImplementation(Photo &a) { cout << "Matching colors\n"; }
};

void processPhoto(Photo &photo)
{   
    ColorMatch match;
    RedEye eye;
    Filter filter;
    Scale scale(Scale::S200);
    scale.setNextProcessor(&eye);
    eye.setNextProcessor(&match);
    match.setNextProcessor(&filter);
    scale.process(photo);
}

int main()
{
    Photo *p = new Photo("Y2013 Photo");
    processPhoto(*p);
    return 0;
}
\end{lstlisting}
Output:

\begin{verbatim}
Processing Y2013 Photo ...
Scaling photo
Removing red eye
Matching colors
Applying filters
\end{verbatim}



\paragraph{exmaple 2: The C++ Chain of Responsibility Pattern and Network Events}
As network errors can occur at any point in a widely distributed system, it often makes sense to distribute your network event management intelligence handling over multiple classes.
One good way to do this is to employ the "Chain of Responsibility" pattern. 

I often think that a good metric for the degree of technological advancement is the number of networks we use: Internet, landline phone, mobile phone, digital TV, etc.
Other networks include: electricity, gas, water, and so on. Each such network has its own infrastructure and management requirements.
A key management requirement is that of handling events, i.e., asynchronous messages emitted by elements in the network.
Given the growing trend for self-managing software (e.g., database administrators now typically manage up to 20 different databases because the latter provide greater automation),
it's important to be able to close the administration loop wherever possible. Network events provide an ever-present opportunity for such self-management.

In this article, I'll look at a method by which the chain of responsibility pattern can be used to facilitate network event management.
The language of choice is C++, but the same considerations apply to any other language.


\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/cornetwork.PNG}}{\caption{A Service Provider Network linking two enterprise sites.}\label{networkp}}
\end{floatrow}
\end{figure}

\paragraph{A Typical Network}

Fig~\ref{networkp} illustrates a network that I'll use to describe the concept of chain of responsibility. 
As it's a complex diagram, let's start with the part in the center: the Service Provider Network (SPN).
The SPN is where most of the action happens. On the left and right hand edges of the SPN are two IP routers called provider edge routers (PEs).
PEs are typically powerful devices that have links to one or more enterprise networks. Enterprise customers use the provider network for data transport, e.g., voice-over-IP,
or more traditional data streams. 

A simple way to think about Fig~\ref{networkp} is that the SPN is a kind of pipe through which the enterprise data passes.
The pipe exists to provide transit bandwidth and geographical reachability.
At the bottom center of Fig~\ref{networkp} is a network management system, which is the entity that will contain our chain of responsibility code.

One other item in Fig~\ref{networkp} is the entity LSP123 (and its backup path at the bottom of Fig~\ref{networkp}). This is nothing more than a pre-defined path through the network.
In the case of Fig~\ref{networkp}, LSP123 represents a forwarding path between routers R2, R3, R4, and R5 and this path is employed to carry data traffic from R2 to R5.
The backup LSP (between R2, R7, R6, \& R5) provides an alternative route for traffic if LSP123 becomes non-operational.

LSP is an acronym for Label Switched Path — a pre-configured path that the network operator can create with specific attributes such as route, bandwidth, etc.
The incoming traffic can then be automatically directed into one or other of the LSPs in the network. Clearly, LSPs are important entities—for more on this topic, see [1].

Let's now look briefly at how such a network can generate an event and then we'll introduce some C++ handling code. 

\paragraph{A Link Failure in The Service Provider Network}

Let's assume that the network has been operating with no problems when suddenly Link 1 (in Fig~\ref{networkp}) 1 fails.
Such a failure could be due to an errant digger cutting a fiber optic cable in two. 
The result of such a link failure is that our LSP123 has to now find another path, such as R2, R7, R6, \& R5.
Fortunately, all the traffic can now be moved onto the backup LSP. So, the enterprise end users should see no immediate service interruption.
However, notice that the backup LSP has only 8Mbps bandwidth, whereas the main LSP has 10Mbps. So, there is a possibility of congestion on the backup LSP.

One or both of R2 and R3 will pick up the failure of Link 1 with the result that an event message will be sent to the Network Management System (NMS).
So, we've lost the link and the notification message has been passed into the NMS. Let's now take a quick look inside the NMS.

\paragraph{An NMS Under The Hood}

A generic NMS consists of numerous interacting applications.
One such application handles the thousands of different events that can occur.
Let's see what a generic C++-based event handler might look like in Listing~\ref{Listing1}.
	
\begin{lstlisting}[caption={A generic network event handler class},label={Listing1},language=C++ ]
typedef int Event;
const Event No_Event_Support = -1;
 
class EventHandler {
public:
  EventHandler(EventHandler* = 0, Event = No_Event_Support);
  virtual bool HasEventSupport();
  virtual void SetHandler(EventHandler*, Event);
  virtual void HandleEvent();
private:
  EventHandler* _successor;
  Event _event; 
};
\end{lstlisting}

When is the handler in Listing~\ref{Listing1} used? Well, it's used when an entity (such as an LSP) manages a network event, such as the link failure we saw in Fig~\ref{networkp}.
Each managed entity in our fictitious NMS models a real world entity and is a subclass of EventHandler.
This means that each such entity has the ability to handle and (hopefully) respond in a meaningful fashion to events.

Getting back to Listing~\ref{Listing1}, the constructor for EventHandler initializes (to zero) a linked list of event handlers.
This is the key to the event management scheme—the handlers pass the event along until an appropriate handler is found. 
In this way, the NMS plays a kind of pass-the-parcel game with events.
This key design decision has the effect of distributing the event management intelligence among the NMS classes rather than focusing it in one central class.

Often, NMS products don't use this approach—instead, many commercial products use a centralized event handler.
The centralized approach requires a big event server that tries to field all incoming events from the network.
Event messages are received, parsed and then the event server has to decide what to do. This monolithic approach is unnatural and potentially brittle.

Thanks to the chain of responsibility pattern, I use a devolved model—equipping each managed object to do some specific event handling.
So, if object X can't process the event, it passes that event onto object Y, etc. I'll review the design tradeoffs later. 

\paragraph{More Details of the EventHandler Class}

The member function HasEventSupport() in Listing ~\ref{Listing1} indicates if a given object of this class provides event support.
As mentioned above, the chain of responsibility pattern allows objects to either provide support or to pass the event along via the \_successor pointer.
If the object of this class wants to provide a specific event handler it calls SetHandler(EventHandler*, Event).
The last member function HandleEvent() is used to implement the event handler itself.

Two member properties are provided in the EventHandler base class: \_successor and \_event.
As mentioned earlier, the \_successor is a pointer to the next handler in the chain or responsibility,
i.e., if I don't handle the event then I pass it on to the \_successor. The event in question is stored in the \_event variable.

Let's now finally see how this base class is used to provide the chain of responsibility.

\paragraph{A Connection Subclass Of EventHandler}

Given that we're using a devolved model for event management, we can now define a Connection class in Listing~\ref{Listing1}. Remember that LSP (LSP123 and its backup) in Fig~\ref{Listing1}?
Well, this is an EventHandler subclass to represent such logical connections. As you can see in Listing~\ref{Listing2},
the Connection class is derived from EventHandler in with the devolved model we're using.
	
\begin{lstlisting}[caption={Connection—A derived class of EventHandler},label={Listing2},language=C++ ]
class Connection : public EventHandler {
public:
    Connection(Event t) : EventHandler(0, t) { }
    virtual void HandleEvent(); 
};

void Connection ::HandleEvent() { }
 
class Path : public Connection {
public:
  Path::Path(Connection* w, Event t) : Connection(0)
  {
    cout << "Now in the Path constructor\n";
    SetHandler(w, t);  
  }
}
\end{lstlisting}

So, Connection is a generic subclass of EventHandler. I say generic because Connection can be used (via inheritance) to model other types of
logical network connections (e.g., IP tunnels) depending on the deployed network technology. 
We can think of Connection as a placeholder for more specialized subclasses in the same way as "Human" is a generic placeholder type for "Male" and "Female".

Listing~\ref{Listing2} also defines another class called Path derived from Connection.
Path is a means of storing a route for an LSP (such as LSP123, which follows the path R2-R3-R4-R5 in Fig~\ref{networkp}). Listing~\ref{Listing3} illustrates the last class of 
interest to us: the Lsp class also derived from Connection.
	
\begin{lstlisting}[caption={The Lsp Class—A specific Connection subclass},label={Listing3},language=C++ ]
class Lsp : public Connection {
public:
  Lsp::Lsp(char* lspID, Connection* w, Event t) : Connection(0) {
    lspName = lspID;
    SetHandler(w, t);   
    }
 
  void HandleEvent() {
    if (HasEventSupport()) {
      cout << "\nAt last, here's some LSP Event support:\n";
      cout << "Lost the path for LSP: " << lspName << "\n\n";
      cout << "Rerouting to backup LSP R2R7R6R5\n\n";
      cout << "We need more bandwidth on backup LSP" << "\n\n";
    }
    else
      EventHandler::HandleEvent(); 
  }
private:
  char* lspName; 
};
\end{lstlisting}

The Lsp class acquires (via inheritance) all the capabilities of EventHandler as well as adding a few wrinkles of its own.
As you can see, Lsp implements the HandleEvent() member function.
This member function is defined as virtual in the EventHandler base class, so subclasses are free to redefine it as required.
In the case of the Lsp class, the event support provided is to print out an informative message.

Now, let's put it all together and build the chain of responsibility, as illustrated in Listing~\ref{Listing4}.

\begin{lstlisting}[caption={The Chain of Responsibility},label={Listing4},language=C++ ]
Connection* connection = new Connection(No_Event_Support);
Lsp* lsp = new Lsp("LSP123", connection, LINK_1_BROKEN);
Path* path = new Path(lsp, No_Event_Support);
path->HandleEvent();
\end{lstlisting}

At the top of the chain is a Connection* object. The next level in the chain is an Lsp* object. 
Finally, at the bottom of the chain is a Path* object. As you can see from Listing~\ref{Listing1}, to start the event processing, we simply call path-$>$HandleEvent().
This simulates the link failure from Fig~\ref{Listing1}. Listing~\ref{Listing5} illustrates part of the program output (excluding initialization in the constructors).
	
\begin{lstlisting}[caption={The program output},label={Listing5}]
No support from Path - Sorry!
Calling the base class event handler
HandleEvent () calling into successor
 
At last, here's some LSP Event support:
Lost the path for LSP: LSP123
Rerouting to backup LSP R2R7R6R5
We need more bandwidth on backup LSP
\end{lstlisting}

The first line of Listing~\ref{Listing5} shows us that the path object can't offer any help. This is because the Path class implements a very thin HandleEvent() method.
Because the path object can't process the event, it calls the base class HandleEvent() method. This then results in a call to the Lsp HandleEvent() method.
As the second last line in Listing~\ref{Listing5} illustrates, we finally get some help from this object in the form of a message indicating that the LSP is rerouted to a new path.
Note that the event handler also gives us a hint that the backup LSP may have inadequate bandwidth.
The latter could then initiate a call to a network modeling application to try to find an optimal path.

So, that's it! That's our chain of responsibility passing the event around like a hot potato until an appropriate handler is found. 

\paragraph{Conclusion}

The chain of responsibility pattern provides an interesting technique for equipping related objects with more intelligence.
This allows for a concomitant reduction in the intelligence of a central event handler.
This avoids heavy-duty monolithic servers that process all event messages and call remote objects.
Instead, the remote objects themselves (such as LSPs) can provide their own handlers for messages.
The overhead for doing this is pretty light—a successor variable is required along with an event holder.
In addition to this, we would need a message dispatcher to get the chain going.

Some of the tradeoffs for the chain of responsibility pattern include:

    The need to explicitly define event types in the objects risks cluttering our class definitions. However, events have to be defined anyway even if we use a central event handler.
    Placing event definitions in the classes is often more meaningful than putting them in a central location

    Chain of responsibility may lose messages if no handler is found, so it's important to have a default event handler

An advantage is that objects are equipped with event handlers for only those events that matter to them.
This allows for a more real world lightly coupled object model. To find out more about the chain of responsibility pattern, please see [2].

In keeping with the magic of design patterns, the main point I'd like you to take away is that the chain of 
responsibility provides a lot of power with very little code—in this case just two source code files: EventHandler.cpp and EventHandler.h! 

\begin{lstlisting}[caption={EventHandler.h}, language=C++]
#ifndef EHANDLER
#define EHANDLER

typedef int Event;
const Event No_Event_Support = -1;

class EventHandler {
public:
	explicit EventHandler(EventHandler* = 0, Event = No_Event_Support);
	virtual const bool HasEventSupport();
	virtual void SetHandler(EventHandler*, Event);
	virtual void HandleEvent();
	~EventHandler() { };
private:
	EventHandler* _successor;
	Event _event;
};
#endif //EHANDLER
\end{lstlisting}

\begin{lstlisting}[caption={EventHandler.cpp}, language=C++]
#include <iostream>
#include "EventHandler.h"
using namespace std;

const Event LINK_1_BROKEN = 1;

//Set up a chain of event handlers
EventHandler::EventHandler ( EventHandler* h, Event t): _successor(h), _event(t) { }

const bool EventHandler::HasEventSupport() { return _event != No_Event_Support; }

void EventHandler::SetHandler(EventHandler* h, Event t) {
	_successor = h;
	_event = t;
}

void EventHandler::HandleEvent () {
	if (_successor != 0) {
		cout << "HandleEvent () calling into successor\n";
		_successor->HandleEvent();
	}
}

class Connection : public EventHandler {
public:
	Connection(Event t) : EventHandler(0, t) { }
	virtual void HandleEvent();
};

void Connection ::HandleEvent() { }

class Path : public Connection {
public:
	Path::Path(Connection* w, Event t) : Connection(0) {
		cout << "In the Path constructor\n";
		SetHandler(w, t);
	}

	void HandleEvent()
	{
		if (HasEventSupport()) {
			// Offer event support
			cout << "Here's some Path Event support";
		}
		else
		{
			cout << "No support from Path - Sorry!\n";
			cout << "Calling the base class event handler\n";
			EventHandler::HandleEvent();
		}
	}
};

class Lsp : public Connection {
public:
	Lsp::Lsp(char* lspID, Connection* w, Event t) : Connection(0) {
		cout << "Constructing Lsp: " << lspID << "\n";
		lspName = lspID;
		SetHandler(w, t);
	}

	void HandleEvent() {
		if (HasEventSupport()) {
			// Offer event support
			cout << "\nAt last, here's some LSP Event support:\n";
			cout << "Lost the path for LSP: " << lspName << "\n";
			cout << "Rerouting to backup LSP R2R7R6R5" << "\n";
			cout << "We need more bandwidth on backup LSP" << "\n\n";
		}
		else
			EventHandler::HandleEvent();
	}

private:
	char* lspName;
};

void main()
{
	Connection* connection = new Connection(No_Event_Support);
	Lsp* lsp = new Lsp("LSP123", connection, LINK_1_BROKEN);
	Path* path = new Path(lsp, No_Event_Support);

	path->HandleEvent();
}
\end{lstlisting}

\chapter{Iterator Pattern}\label{IteratorPattern}
\paragraph{Intent}

    Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

    The C++ and Java standard library abstraction that makes it possible to decouple collection classes and algorithms.

    Promote to "full object status" the traversal of a collection.

    Polymorphic traversal
\paragraph{Discussion}
Take traversal-of-a-collection functionality out of the collection and promote it to "full object status".
This simplifies the collection, allows many traversals to be active simultaneously, and decouples collection algorithms from collection data structures.

"Every 'container-like' class must have an iterator." It may seem like a violation of encapsulation for a Stack class 
to allow its users to access its contents directly, but John Lakos' argument is that the designer of a class inevitably leaves something out.
Later, when users need additional functionality, if an iterator was originally provided, they can add functionality with "open for extension, closed for modification".
Without an iterator, their only recourse is to invasively customize production code.
Below, the original Stack class did not include an equality operator, but it did include an iterator.
As a result, the equality operator could be readily retrofitted.

\paragraph{Real world example}
An old radio set will be a good example of iterator, where user could start at some channel and then use next or previous buttons to go through the respective channels.
Or take an example of MP3 player or a TV set where you could press the next and previous buttons to go through the consecutive channels or in other words they all
provide an interface to iterate through the respective channels, songs or radio stations.
\textbf{In plain words}
It presents a way to access the elements of an object without exposing the underlying presentation.
\textbf{Wikipedia says}
In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements.
The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.
\paragraph{Example 1}
    Design an ``iterator'' class for the ``container'' class
    Add a createIterator() member to the container class
    Clients ask the container object to create an iterator object
    Clients use the first(), isDone(), next(), and currentItem() protocol
\begin{lstlisting}[caption={Iterator Pattern Example 1},language=C++]
class Stack//container class
{
  public:
    friend class StackIter;// iterator class is container class's friend
    Stack() { sp =  - 1; }
    void push(int in) { items[++sp] = in; }
    int pop() { return items[sp--]; }
    bool isEmpty() { return (sp ==  - 1); }
    StackIter *createIterator() const; // 2. Add a createIterator() member
  private:
    int items[10];
    int sp;
};

    // 1. Design an "iterator" class
class StackIter
{
  public:
    StackIter(const Stack *s) { stk = s; }
    void first() { index = 0; }
    void next() { index++; }
    bool isDone() { return index == stk->sp + 1; }
    int currentItem() { return stk->items[index]; }
  private:
    const Stack *stk;
    int index;
};

StackIter *Stack::createIterator() const
{
  return new StackIter(this);
}

bool operator== (const Stack &l, const Stack &r)
{
  // 3. Clients ask the container object to create an iterator object
  StackIter *itl = l.createIterator();
  StackIter *itr = r.createIterator();

  // 4. Clients use the first(), isDone(), next(), and currentItem() protocol
  for (itl->first(), itr->first(); !itl->isDone(); itl->next(), itr->next())
    if (itl->currentItem() != itr->currentItem())
      break;
  bool ans = itl->isDone() && itr->isDone();
  delete itl;
  delete itr;
  return ans;
}

int main()
{
  Stack s1;
  for (int i = 1; i < 5; i++)
    s1.push(i);
  Stack s2(s1), s3(s1), s4(s1), s5(s1);
  s3.pop();
  s5.pop();
  s4.push(2);
  s5.push(9);
  cout << "1 == 2 is " << (s1 == s2) << endl;
  cout << "1 == 3 is " << (s1 == s3) << endl;
  cout << "1 == 4 is " << (s1 == s4) << endl;
  cout << "1 == 5 is " << (s1 == s5) << endl;
}
\end{lstlisting}
Output:
\begin{verbatim}
1 == 2 is 1
1 == 3 is 0
1 == 4 is 0
1 == 5 is 0
\end{verbatim}
\paragraph{Exmaple 2} Imagine that people sing in KTV, they need to select,delete,insert or switch songs but they don't have to know how these songs are stored in the computer system.
So ``Iterator'' defines the interface to visit traversally elements (songs). ``concrete Iterator'' implements ``Iterator'' and saves positions of elements.
``Aggregate'' and ``concrete aggregate''.

\begin{lstlisting}[caption={Iterator Pattern Example 2 (VC)},language=C++]
// Iterator interface
template <typename Item>  
class Iterator  
{  
public:  
    virtual Item* first() = 0;  
    virtual Item* next() = 0;  
    //virtual void toTop(Item* ) = 0;  
    virtual Item* currentItem() = 0;  
    virtual bool isDone() = 0;  
    virtual ~Iterator() {};  
};  

//concrete Iterator
template <typename Item>  
class KtvCrlor : public Iterator<Item>  
{  
public:  
    KtvCrlor(SongsBook<Item>* songsbook) : songsbook(songsbook), index(0) { }  
    virtual Item* first();  
    virtual Item* next();  
    virtual Item* currentItem();  
    virtual bool isDone();  
private:  
    SongsBook<Item>* songsbook;  
    int index;  
};  

//Aggregate interface
template<typename Item>  
class Aggregate  
{  
public:  
    Aggregate<Item>() {};  
    virtual Iterator<Item>* createIterator() = 0;  
    virtual ~Aggregate() {};  
};  

//concrete Aggregate
template<typename Item>  
class SongsBook : public Aggregate<Item>  
{  
public:  
    SongsBook<Item>() : Aggregate<Item>() { };  
    void addSong(Item* song);  
    int count();  
    virtual Iterator<Item>* createIterator();  
    Item* operator[](int index);  
private:  
    std::vector<Item*> songs;  
};  

//client
int main()  
{  
    SongsBook<std::string>* songsbook = new SongsBook<std::string>();  
    Iterator<std::string>* ktvController = songsbook->createIterator();  
    std::cout << "please select songs:" << std::endl;  
    songsbook->addSong(new std::string("spring story"));  
    songsbook->addSong(new std::string("summer story"));  
    songsbook->addSong(new std::string("fall story "));  
    songsbook->addSong(new std::string("winter story"));  
    /* travel songsbook */  
    std::cout << std::endl;  
    std::cout << "current song list includes: " << songsbook->count() << " songs " << std::endl;  
    while(!ktvController->isDone()) {  
        std::cout << *ktvController->next() << std::endl;  
    }  
    system("Pause");  
}  
\end{lstlisting}
Output:
\begin{verbatim}
please select song:
added song: spring story
added song: summer story
added song: fall story
added song: winter story

current song list includes: 4 songs
spring story
summer story
fall story
winter story
\end{verbatim}

\begin{lstlisting}[caption={Iterator Pattern Example 3 Signly linked list with interator},language=C++]
template <typename T> 
class LinkedList 
{ 
    class Node; // Forward declaration 
  
public: 
    LinkedList<T>() noexcept 
    { 
        // caution: static members can't be initialized by initializer list 
        m_spRoot = nullptr; 
    } 
  
    // Forward declaration must be done in the same access scope 
    class Iterator; 
  
    // Root of LinkedList wrapped in Iterator type 
    Iterator begin() 
    { 
        return Iterator(m_spRoot); 
    } 
  
    // End of LInkedList wrapped in Iterator type 
    Iterator end() 
    { 
        return Iterator(nullptr); 
    } 
  
    // Adds data to the end of list 
    void push_back(T data); 
  
    void Traverse(); 
  
    // Iterator class can be used to sequentially access nodes of linked list 
    class Iterator//nested class 
    { 
    public: 
    Iterator() noexcept : 
        m_pCurrentNode (m_spRoot) { } 
  
    Iterator(const Node* pNode) noexcept : 
        m_pCurrentNode (pNode) { } 
  
        Iterator& operator=(Node* pNode) 
        { 
            this->m_pCurrentNode = pNode; 
            return *this; 
        } 
  
        // Prefix ++ overload 
        Iterator& operator++() 
        { 
            if (m_pCurrentNode) 
                m_pCurrentNode = m_pCurrentNode->pNext; 
            return *this; 
        } 
  
        // Postfix ++ overload 
        Iterator operator++(int) 
        { 
            Iterator iterator = *this; 
            ++*this; 
            return iterator; 
        } 
  
        bool operator!=(const Iterator& iterator) 
        { 
            return m_pCurrentNode != iterator.m_pCurrentNode; 
        } 
  
        int operator*() 
        { 
            return m_pCurrentNode->data; 
        } 
  
    private: 
        const Node* m_pCurrentNode; 
    }; 
  
private: 
  
    class Node //nested class 
    { 
        T data; 
        Node* pNext; 
  
        // LinkedList class methods need to access Node information 
        friend class LinkedList; 
    }; 
  
    // Create a new Node 
    Node* GetNode(T data) 
    { 
        Node* pNewNode = new Node; 
        pNewNode->data = data; 
        pNewNode->pNext = nullptr; 
  
        return pNewNode; 
    } 
  
    // Return by reference so that it can be used in left hand side of the assignment expression 
    Node*& GetRootNode() 
    { 
        return m_spRoot; 
    } 
  
    static Node* m_spRoot; 
}; 
  
template <typename T> 
/*static*/ typename LinkedList<T>::Node* LinkedList<T>::m_spRoot = nullptr; 
  
template <typename T> 
void LinkedList<T>::push_back(T data) 
{ 
    Node* pTemp = GetNode(data); 
    if (!GetRootNode()) 
    { 
        GetRootNode() = pTemp; 
    } 
    else
    { 
        Node* pCrawler = GetRootNode(); 
        while (pCrawler->pNext) 
        { 
            pCrawler = pCrawler->pNext; 
        } 
  
        pCrawler->pNext = pTemp; 
    } 
} 
  
template <typename T> 
void LinkedList<T>::Traverse() 
{ 
    Node* pCrawler = GetRootNode(); 
  
    while (pCrawler) 
    { 
        cout << pCrawler->data << " "; 
        pCrawler = pCrawler->pNext; 
    } 
  
    cout << endl; 
} 
  
//Driver program 
int main() 
{ 
    LinkedList<int> list; 
  
    // Add few items to the end of LinkedList 
    list.push_back(1); 
    list.push_back(2); 
    list.push_back(3); 
  
    cout << "Traversing LinkedList through method" << endl; 
    list.Traverse(); 
  
    cout << "Traversing LinkedList through Iterator" << endl; 
    for ( LinkedList<int>::Iterator iterator = list.begin(); 
            iterator != list.end(); iterator++) 
    { 
        cout << *iterator << " "; 
    } 
  
    cout << endl; 
  
    return 0; 
} 
\end{lstlisting}

Output:
\begin{Verbatim}
Traversing LinkedList through method
1 2 3 
Traversing LinkedList through Iterator
1 2 3 
\end{Verbatim}
see similar exmaple at \url{https://www.robertlarsononline.com/2017/04/24/iterator-pattern-using-cplusplus/#What_is_the_Iterator_Pattern}
\chapter{Mediator patter}\label{MediatorPattern}
\paragraph{Intent}
Define an object that encapsulates how a set of objects interact.
Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.

Define an object that encapsulates how a set of objects interact. 
Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.
Design an intermediary to decouple many peers.
Promote the many-to-many relationships between interacting peers to "full object status".
\paragraph{Example} A general example would be when you talk to someone on your mobile phone,
there is a network provider sitting between you and them and your conversation goes through it instead of being directly sent. In this case network provider is mediator.
Mediator pattern adds a third party object (called mediator) to control the interaction between two objects (called colleagues).
It helps reduce the coupling between the classes communicating with each other. Because now they don't need to have the knowledge of each other's implementation.
\textbf{Wikipedia} In software engineering, the mediator pattern defines an object that encapsulates how a set of objects interact.
This pattern is considered to be a behavioral pattern due to the way it can alter the program's running behavior.
\paragraph{Example: Tenant - Real Estate Agant - Landlord}
Let's look at this example.
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/mediatorsample.PNG}}{\caption{Mediator Sample}\label{Mediators}}
\end{floatrow}
\end{figure}

\begin{lstlisting}[caption={Mediator Pattern Sample code}, language=C++]
class Mediator;  

class Person  //interface
{  
   public:  
       virtual void SetMediator(Mediator *mediator){} //
       virtual void SendMessage(string message) {}    //  send message to RSA
       virtual void GetMessage(string message) {}     //
   protected:  
       Mediator *m_mediator; //Real Estate agent (RSA)
};  

class Mediator  //interface
{  
   public:  
       virtual void Send(string message, Person *person) {}  
       virtual void SetA(Person *A) {}  //  
       virtual void SetB(Person *B) {}  
};  

class Tenant: public Person  // renter
{  
   public:  
       void SetMediator(Mediator *mediator) { m_mediator = mediator; }  
       void SendMessage(string message) { m_mediator->Send(message, this); }  
       void GetMessage(string message) { cout<<"Tenant receives message!"<<message; }  
};  

class Landlord: public Person  
{  
   public:  
       void SetMediator(Mediator *mediator) { m_mediator = mediator; }  
       void SendMessage(string message) { m_mediator->Send(message, this); }  
       void GetMessage(string message) { cout<<"Landlord receives message!"<<message; }  
};  

class HouseMediator : public Mediator  
{  
   public:  
       HouseMediator(): m_A(0), m_B(0) {}  
       void SetA(Person *A) { m_A = A; }  
       void SetB(Person *B) { m_B = B; }  
       void Send(string message, Person *person)   
       {  
           if(person == m_A) //Tenant send message to Landlord
               m_B->GetMessage(message); //  
           else  
               m_A->GetMessage(message);  
       }  
   private:  
       Person *m_A; //Tenant  
       Person *m_B; //Landlord 
};  

int main()  
{     
    Mediator *mediator = new HouseMediator();  
    Person *person1 = new Tenant();    //  
    Person *person2 = new Landlord();  //  
    mediator->SetA(person1);  
    mediator->SetB(person2);  
    person1->SetMediator(mediator);  
    person2->SetMediator(mediator);  
    person1->SendMessage("I want to rent a house at SF!\n");  
    person2->SendMessage("House for rent: bay area!\n");  
    delete person1; delete person2; delete mediator;  
    return 0;  
}  
\end{lstlisting}
\paragraph{Example 2}

Discussion. Though partitioning a system into many objects generally enhances reusability,
proliferating interconnections tend to reduce it again.
You can avoid this problem by encapsulating the interconnections (i.e. the collective behavior) in a separate "mediator" object.
A mediator is responsible for controlling and coordinating the interactions of a group of objects.

In this example, the dialog box object is functioning as the mediator.
Child widgets of the dialog box do not know, or care, who their siblings are.
Whenever a simulated user interaction occurs in a child widget Widget::changed(), the widget does nothing except "delegate" that event to its parent dialog box mediator-$>$widgetChanged(this).

FileSelectionDialog::widgetChanged() encapsulates all collective behavior for the dialog box (it serves as the hub of communication).
The user may choose to "interact" with a simulated: filter edit field, directories list, files list, or selection edit field.

\begin{lstlisting}[caption={Mediator Pattern Sample 3},language=C++]
#include <iostream.h>

class FileSelectionDialog;

class Widget
{
  public:
    Widget(FileSelectionDialog *mediator, char *name)
    {
        _mediator = mediator;
        strcpy(_name, name);
    }
    virtual void changed();
    virtual void updateWidget() = 0;
    virtual void queryWidget() = 0;
  protected:
    char _name[20];
  private:
    FileSelectionDialog *_mediator;
};

class List: public Widget
{
  public:
    List(FileSelectionDialog *dir, char *name): Widget(dir, name){}
    void queryWidget() { cout << "   " << _name << " list queried" << endl; }
    void updateWidget() { cout << "   " << _name << " list updated" << endl; }
};

class Edit: public Widget
{
  public:
    Edit(FileSelectionDialog *dir, char *name): Widget(dir, name){}
    void queryWidget() { cout << "   " << _name << " edit queried" << endl; }
    void updateWidget() { cout << "   " << _name << " edit updated" << endl; }
};

class FileSelectionDialog// mediator
{
  public:
    enum Widgets { FilterEdit, DirList, FileList, SelectionEdit };
    FileSelectionDialog()
    {
        _components[FilterEdit] = new Edit(this, "filter");
        _components[DirList] = new List(this, "dir");
        _components[FileList] = new List(this, "file");
        _components[SelectionEdit] = new Edit(this, "selection");
    }
    virtual ~FileSelectionDialog();
    void handleEvent(int which) { _components[which]->changed(); }
    virtual void widgetChanged(Widget *theChangedWidget)
    {
        if (theChangedWidget == _components[FilterEdit])
        {
            _components[FilterEdit]->queryWidget();
            _components[DirList]->updateWidget();
            _components[FileList]->updateWidget();
            _components[SelectionEdit]->updateWidget();
        }
        else if (theChangedWidget == _components[DirList])
        {
            _components[DirList]->queryWidget();
            _components[FileList]->updateWidget();
            _components[FilterEdit]->updateWidget();
            _components[SelectionEdit]->updateWidget();
        }
        else if (theChangedWidget == _components[FileList])
        {
            _components[FileList]->queryWidget();
            _components[SelectionEdit]->updateWidget();
        }
        else if (theChangedWidget == _components[SelectionEdit])
        {
            _components[SelectionEdit]->queryWidget();
            cout << "   file opened" << endl;
        }
    }
  private:
    Widget *_components[4];
};

FileSelectionDialog::~FileSelectionDialog()
{
  for (int i = 0; i < 4; i++)
    delete _components[i];
}

void Widget::changed()
{
  _mediator->widgetChanged(this);
}

int main()
{
  FileSelectionDialog fileDialog;
  int i;

  cout << "Exit[0], Filter[1], Dir[2], File[3], Selection[4]: ";
  cin >> i;

  while (i)
  {
    fileDialog.handleEvent(i - 1);
    cout << "Exit[0], Filter[1], Dir[2], File[3], Selection[4]: ";
    cin >> i;
  }
}
\end{lstlisting}
Output

\begin{verbatim}
Exit[0], Filter[1], Dir[2], File[3], Selection[4]: 1
   filter edit queried
   dir list updated
   file list updated
   selection edit updated
Exit[0], Filter[1], Dir[2], File[3], Selection[4]: 2
   dir list queried
   file list updated
   filter edit updated
   selection edit updated
Exit[0], Filter[1], Dir[2], File[3], Selection[4]: 3
   file list queried
   selection edit updated
Exit[0], Filter[1], Dir[2], File[3], Selection[4]: 4
   selection edit queried
   file opened
Exit[0], Filter[1], Dir[2], File[3], Selection[4]: 3
   file list queried
   selection edit updated
\end{verbatim}


\paragraph{Example 3}
Colleagues (or peers) are not coupled to one another.
Each talks to the Mediator, which in turn knows and conducts the orchestration of the others.
The "many to many" mapping between colleagues that would otherwise exist, has been "promoted to full object status".
This new abstraction provides a locus of indirection where additional leverage can be hosted.
\begin{lstlisting}[caption={Mediator Pattern Sample 3},language=C++]
#include <iostream>
#include <string>
#include <list>

class MediatorInterface;

class ColleagueInterface {
		std::string name;
	public:
		ColleagueInterface (const std::string& newName) : name (newName) {}
		std::string getName() const {return name;}
		virtual void sendMessage (const MediatorInterface&, const std::string&) const = 0;
		virtual void receiveMessage (const ColleagueInterface*, const std::string&) const = 0;
};

class Colleague : public ColleagueInterface {
	public:
		using ColleagueInterface::ColleagueInterface;
		virtual void sendMessage (const MediatorInterface&, const std::string&) const override;
	private:
		virtual void receiveMessage (const ColleagueInterface*, const std::string&) const override;
};

class MediatorInterface {
    private:
		std::list<ColleagueInterface*> colleagueList;
    public:
    	const std::list<ColleagueInterface*>& getColleagueList() const {return colleagueList;}
		virtual void distributeMessage (const ColleagueInterface*, const std::string&) const = 0;
		virtual void registerColleague (ColleagueInterface* colleague) {colleagueList.emplace_back (colleague);}
};

class Mediator : public MediatorInterface {
    virtual void distributeMessage (const ColleagueInterface*, const std::string&) const override;
};

void Colleague::sendMessage (const MediatorInterface& mediator, const std::string& message) const {
	mediator.distributeMessage (this, message);
}

void Colleague::receiveMessage (const ColleagueInterface* sender, const std::string& message) const {
 	std::cout << getName() << " received the message from " << sender->getName() << ": " << message << std::endl;			
}

void Mediator::distributeMessage (const ColleagueInterface* sender, const std::string& message) const {
	for (const ColleagueInterface* x : getColleagueList())
		if (x != sender)  // Do not send the message back to the sender
			x->receiveMessage (sender, message);
}
 
int main() 
{
	Colleague *bob = new Colleague ("Bob"),  *sam = new Colleague ("Sam"),  *frank = new Colleague ("Frank"),  *tom = new Colleague ("Tom");
	Colleague* staff[] = {bob, sam, frank, tom};
	Mediator mediatorStaff, mediatorSamsBuddies;
	for (Colleague* x : staff)
		mediatorStaff.registerColleague(x);
	bob->sendMessage (mediatorStaff, "I'm quitting this job!");
	mediatorSamsBuddies.registerColleague (frank);  mediatorSamsBuddies.registerColleague (tom);  // Sam's buddies only
	sam->sendMessage (mediatorSamsBuddies, "Hooray!  He's gone!  Let's go for a drink, guys!");	
	return 0;
}

\end{lstlisting}

\chapter{Interpreter Pattern}\label{InterpreterPattern}

\paragraph{Intent}
    Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.
    Map a domain to a language, the language to a grammar, and the grammar to a hierarchical object-oriented design.




\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/interpreterd.PNG}}{\caption{Interpreter Pattern Diagram}\label{Interpreterd}}
\end{floatrow}
\end{figure}
\paragraph{Example}

The Interpreter pattern defines a grammatical representation for a language and an interpreter to interpret the grammar. Musicians are examples of Interpreters. The pitch of a sound and its duration can be represented in musical notation on a staff. This notation provides the language of music. Musicians playing the music from the score are able to reproduce the original pitch and duration of each sound represented. 

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/interpreters.PNG}}{\caption{Interpreter Sample}\label{interpreters}}
\end{floatrow}
\end{figure}



\paragraph{exmaple: Using Interpreter pattern with Template Method}

\paragraph{Discussion.}
Uses a class hierarchy to represent the grammar given below. When a roman numeral is provided, the class hierarchy validates and interprets the string.
RNInterpreter "has" 4 sub-interpreters. Each sub-interpreter receives the "context" (remaining unparsed string and cumulative parsed value) and contributes its share to the processing.
Sub-interpreters simply define the Template Methods declared in the base class RNInterpreter.

\begin{lstlisting}
romanNumeral ::= {thousands} {hundreds} {tens} {ones}
thousands, hundreds, tens, ones ::= nine | four | {five} {one} {one} {one}
nine ::= "CM" | "XC" | "IX"
four ::= "CD" | "XL" | "IV"
five ::= 'D' | 'L' | 'V'
one  ::= 'M' | 'C' | 'X' | 'I'
\end{lstlisting}

\begin{lstlisting}
#include <iostream.h>
#include <string.h>

class Thousand;
class Hundred;
class Ten;
class One;

class RNInterpreter
{
  public:
    RNInterpreter(); // ctor for client
    RNInterpreter(int){}
    // ctor for subclasses, avoids infinite loop
    int interpret(char*); // interpret() for client
    virtual void interpret(char *input, int &total)
    {
        // for internal use
        int index;
        index = 0;
        if (!strncmp(input, nine(), 2))
        {
            total += 9 * multiplier();
            index += 2;
        }
        else if (!strncmp(input, four(), 2))
        {
            total += 4 * multiplier();
            index += 2;
        }
        else
        {
            if (input[0] == five())
            {
                total += 5 * multiplier();
                index = 1;
            }
            else
              index = 0;
            for (int end = index + 3; index < end; index++)
              if (input[index] == one())
                total += 1 * multiplier();
              else
                break;
        }
        strcpy(input, &(input[index]));
    } // remove leading chars processed
  protected:
    // cannot be pure virtual because client asks for instance
    virtual char one(){}
    virtual char *four(){}
    virtual char five(){}
    virtual char *nine(){}
    virtual int multiplier(){}
  private:
    RNInterpreter *thousands;
    RNInterpreter *hundreds;
    RNInterpreter *tens;
    RNInterpreter *ones;
};

class Thousand: public RNInterpreter
{
  public:
    // provide 1-arg ctor to avoid infinite loop in base class ctor
    Thousand(int): RNInterpreter(1){}
  protected:
    char one() { return 'M'; }
    char *four() { return ""; }
    char five() { return '\0'; }
    char *nine() { return ""; }
    int multiplier() { return 1000; }
};

class Hundred: public RNInterpreter
{
  public:
    Hundred(int): RNInterpreter(1){}
  protected:
    char one() { return 'C'; }
    char *four() { return "CD"; }
    char five() { return 'D'; }
    char *nine() { return "CM"; }
    int multiplier() { return 100; }
};

class Ten: public RNInterpreter
{
  public:
    Ten(int): RNInterpreter(1){}
  protected:
    char one() { return 'X'; }
    char *four() { return "XL"; }
    char five() { return 'L'; }
    char *nine() { return "XC"; }
    int multiplier() { return 10; }
};

class One: public RNInterpreter
{
  public:
    One(int): RNInterpreter(1){}
  protected:
    char one() { return 'I'; }
    char *four() { return "IV"; }
    char five() { return 'V'; }
    char *nine() { return "IX"; }
    int multiplier() { return 1; }
};

RNInterpreter::RNInterpreter()
{
  // use 1-arg ctor to avoid infinite loop
  thousands = new Thousand(1);
  hundreds = new Hundred(1);
  tens = new Ten(1);
  ones = new One(1);
}

int RNInterpreter::interpret(char *input)
{
  int total;
  total = 0;
  thousands->interpret(input, total);
  hundreds->interpret(input, total);
  tens->interpret(input, total);
  ones->interpret(input, total);
  if (strcmp(input, ""))
  // if input was invalid, return 0
    return 0;
  return total;
}

int main()
{
  RNInterpreter interpreter;
  char input[20];
  cout << "Enter Roman Numeral: ";
  while (cin >> input)
  {
    cout << "   interpretation is " << interpreter.interpret(input) << endl;
    cout << "Enter Roman Numeral: ";
  }
}
\end{lstlisting}
Output
\begin{verbatim}
Enter Roman Numeral: MCMXCVI
   interpretation is 1996
Enter Roman Numeral: MMMCMXCIX
   interpretation is 3999
Enter Roman Numeral: MMMM
   interpretation is 0
Enter Roman Numeral: MDCLXVIIII
   interpretation is 0
Enter Roman Numeral: CXCX
   interpretation is 0
Enter Roman Numeral: MDCLXVI
   interpretation is 1666
Enter Roman Numeral: DCCCLXXXVIII
   interpretation is 888
\end{verbatim}

\paragraph{ Rules of thumb}

Considered in its most general form (i.e. an operation distributed over a class hierarchy based on the Composite pattern),
nearly every use of the Composite pattern will also contain the Interpreter pattern.
But the Interpreter pattern should be reserved for those cases in which you want to think of this class hierarchy as defining a language.

Interpreter can use State to define parsing contexts.

The abstract syntax tree of Interpreter is a Composite (therefore Iterator and Visitor are also applicable).

Terminal symbols within Interpreter's abstract syntax tree can be shared with Flyweight.

The pattern doesn't address parsing. When the grammar is very complex, other techniques (such as a parser) are more appropriate.

\chapter{State Pattern}\label{StatePattern}
\paragraph{Intent}
    Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.

    An object-oriented state machine

    wrapper + polymorphic wrappee + collaboration
\paragraph{Discussion}

The State pattern is a solution to the problem of how to make behavior depend on state.

    Define a "context" class to present a single interface to the outside world.

    Define a State abstract base class.

    Represent the different "states" of the state machine as derived classes of the State base class.

    Define state-specific behavior in the appropriate State derived classes.

    Maintain a pointer to the current "state" in the "context" class.

    To change the state of the state machine, change the current "state" pointer.

The State pattern does not specify where the state transitions will be defined.
The choices are two: the "context" object, or each individual State derived class.
The advantage of the latter option is ease of adding new State derived classes.
The disadvantage is each State derived class has knowledge of (coupling to) its siblings, which introduces dependencies between subclasses.

A table-driven approach to designing finite state machines does a good job of specifying state transitions, but it is difficult to add actions to accompany the state transitions.
The pattern-based approach uses code (instead of data structures) to specify state transitions, but it does a good job of accommodating state transition actions.
\paragraph{Structure}
The state machine's interface is encapsulated in the "wrapper" class.
The wrappee hierarchy's interface mirrors the wrapper's interface with the exception of one additional parameter.
The extra parameter allows wrappee derived classes to call back to the wrapper class as necessary.
Complexity that would otherwise drag down the wrapper class is neatly compartmented and encapsulated in a polymorphic hierarchy to which the wrapper object delegates.

\begin{figure}[!h]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/states.PNG}}{\caption{State Pattern}\label{states}}
\end{floatrow}
\end{figure}

\paragraph{example 1} assume we need to design a system for smart A/C. if temperature is 20-30 degree, AC switches to normal state, if 30-45 degree, it switches to cool state to cool down the temperature,
if temperature is smaller than 20 degree, it should switch to heat state.

\begin{lstlisting}[caption={State Pattern exmaple 1}, language=C++]
#include <iostream>  
using namespace std;  

class AirConditioner;

class AirConditionerState  // Abstract states
{  
public:   
    virtual void KeepNormalTemperature(AirConditioner * pAirConditioner) = 0;  
    virtual void Cool(AirConditioner * pAirConditioner) = 0;  
    virtual void Heat(AirConditioner * pAirConditioner) = 0;  
};  

class NormalTemperatureState : public AirConditionerState  
{  
public:   
    void KeepNormalTemperature(AirConditioner * pAirConditioner);  
    void Cool(AirConditioner * pAirConditioner);  
    void Heat(AirConditioner * pAirConditioner);  
};  
  
class CoolState : public AirConditionerState  
{  
public:   
    void KeepNormalTemperature(AirConditioner * pAirConditioner);  
    void Cool(AirConditioner * pAirConditioner);  
    void Heat(AirConditioner * pAirConditioner);  
};  

class HeatState : public AirConditionerState  
{  
public:   
    void KeepNormalTemperature(AirConditioner * pAirConditioner);  
    void Cool(AirConditioner * pAirConditioner);  
    void Heat(AirConditioner * pAirConditioner);  
};  

//normal state implementation ----------------------------- concrete states
void NormalTemperatureState::KeepNormalTemperature(AirConditioner * pAirConditioner)  
{  
    int nTemperature = pAirConditioner->GetTemperature();  
  
    if( nTemperature > 20 && nTemperature <= 30 )  
    {  
        cout << "Normal Temperature State currently, change nothing!" << endl;  
    }  
}  
  
void NormalTemperatureState::Cool(AirConditioner * pAirConditioner)  
{  
    int nTemperature = pAirConditioner->GetTemperature();  
      
    if( nTemperature > 30 && nTemperature <= 45 )  
    {  
        pAirConditioner->SetAirConditionerState(pAirConditioner->GetCoolState());  
  
        cout << "Normal state Switches to cool state!" << endl;  
    }  
}  
      
void NormalTemperatureState::Heat(AirConditioner * pAirConditioner)  
{  
    int nTemperature = pAirConditioner->GetTemperature();  
      
    if( nTemperature <= 20 )  
    {  
        pAirConditioner->SetAirConditionerState(pAirConditioner->GetHeatState());  
  
        cout << "Normal state Switches to heat state!" << endl;  
    }  
}  
 
 // cool state implementation -----------------------------concrete states
void CoolState::KeepNormalTemperature(AirConditioner * pAirConditioner)  
{  
    int nTemperature = pAirConditioner->GetTemperature();  
      
    if( nTemperature > 20 && nTemperature <= 30 )  
    {  
        pAirConditioner->SetAirConditionerState(pAirConditioner->GetNormalTemperatureState());  
  
        cout << "Cool state Switches to Normal state!" << endl;  
    }  
}  
      
void CoolState::Cool(AirConditioner * pAirConditioner)  
{  
    int nTemperature = pAirConditioner->GetTemperature();  
      
    if( nTemperature > 30 && nTemperature <= 45 )  
    {  
        cout << "Cool state currently, Change nothing!" << endl;  
    }  
}  
  
void CoolState::Heat(AirConditioner * pAirConditioner)  
{  
    int nTemperature = pAirConditioner->GetTemperature();  
      
    if( nTemperature <= 20 )  
    {  
        pAirConditioner->SetAirConditionerState(pAirConditioner->GetHeatState());  
  
        cout << "Cool state Switches to heat state!" << endl;  
    }  
}  
  
//heat state  implementation -----------------------------concrete states
void HeatState::KeepNormalTemperature(AirConditioner * pAirConditioner)  
{  
    int nTemperature = pAirConditioner->GetTemperature();  
      
    if( nTemperature > 20 && nTemperature <= 30 )  
    {  
        pAirConditioner->SetAirConditionerState(pAirConditioner->GetNormalTemperatureState());  
  
        cout << "Heat state switches to Normal state!" << endl;  
    }  
}  
      
void HeatState::Cool(AirConditioner * pAirConditioner)  
{  
    int nTemperature = pAirConditioner->GetTemperature();  
      
    if( nTemperature > 30 && nTemperature <= 45 )  
    {  
        pAirConditioner->SetAirConditionerState(pAirConditioner->GetCoolState());  
  
        cout << "Heat state switches to Cool state!" << endl;  
    }  
}  
  
void HeatState::Heat(AirConditioner * pAirConditioner)  
{  
    int nTemperature = pAirConditioner->GetTemperature();  
      
    if( nTemperature <= 20 )  
    {  
        cout << "Heat state currently, change nothing!" << endl;  
    }  
}  

// AC --------------
class AirConditioner  
{  
private:  
    string m_strAirName;  //name of AC
    int m_nTemperature;  // current temperature of AC
    AirConditionerState * m_pNormalTemperatureState;  //normal state
    AirConditionerState * m_pCoolState;  //cool state
    AirConditionerState * m_pHeatState;  // heat state
    AirConditionerState * m_pCurState;  // current state
public:  
    AirConditioner(string strAirName, int nTemperature);  
    ~AirConditioner();  
      
    void SetTemperature(int nTemperature);  
    int GetTemperature();  
  
    void SetAirConditionerState(AirConditionerState * pAirConditionerState);  
    AirConditionerState * GetNormalTemperatureState();  
    AirConditionerState * GetCoolState();  
    AirConditionerState * GetHeatState();  
    void KeepNormalTemperature();  
    void Cool();  
    void Heat();  
      
};  

AirConditioner::AirConditioner(string strAirName, int nTemperature)  
{  
    m_strAirName = strAirName;  
    m_nTemperature = nTemperature;  
  
    m_pNormalTemperatureState = new NormalTemperatureState();  
    m_pCoolState = new CoolState();  
    m_pHeatState = new HeatState();  
  
    m_pCurState = m_pNormalTemperatureState;  
}  
  
AirConditioner::~AirConditioner()  
{  
    delete m_pNormalTemperatureState;  
    m_pNormalTemperatureState = NULL;  
  
    delete m_pCoolState;  
    m_pCoolState = NULL;  
  
    delete m_pHeatState;  
    m_pHeatState = NULL;  
}  
      
void AirConditioner::SetTemperature(int nTemperature)  {  m_nTemperature = nTemperature;  }  
int AirConditioner::GetTemperature()  {  return m_nTemperature;  }  
void AirConditioner::SetAirConditionerState(AirConditionerState * pAirConditionerState)  
{  
    m_pCurState = pAirConditionerState;  
}  
  
AirConditionerState * AirConditioner::GetNormalTemperatureState()  
{  
    return m_pNormalTemperatureState;  
}  
  
AirConditionerState * AirConditioner::GetCoolState()  {  return m_pCoolState;  }  
AirConditionerState * AirConditioner::GetHeatState()  {  return m_pHeatState;  }  
void AirConditioner::KeepNormalTemperature()  {  m_pCurState->KeepNormalTemperature(this);  }  
void AirConditioner::Cool()  {  m_pCurState->Cool(this);  }  
void AirConditioner::Heat()  {  m_pCurState->Heat(this);  }  

// client ------------------------
int main()  
{  
  
    AirConditioner * pAirConditioner = new AirConditioner("SamSung", 25);  
  
    pAirConditioner->KeepNormalTemperature();  
  
    cout << endl;  
      
    pAirConditioner->SetTemperature(33);  
    pAirConditioner->Cool();  
  
    cout << endl;  
  
    pAirConditioner->SetTemperature(15);  
    pAirConditioner->Heat();  
  
    delete pAirConditioner;  
    pAirConditioner = NULL;  
  
    return 0;  
}  
\end{lstlisting}
Output:
\begin{verbatim}
Normal Temperature current, change nothing!

Normal state Switches to cool state!

cool state Switches to Heat state!
\end{verbatim}

\paragraph{Example 2}\mbox{}
\begin{lstlisting}[caption={State Pattern exmaple 2}, language=C++]
#include<iostream>  
using namespace std;  

class Context;

class State{//Abstract state  
    public:  
         virtual void switch_state()=0;
};  

//each concrete state has to contain Context *context;  
//in constructor has to have this->context=context;
class StateA:public State
{  
    private:  
         Context *context;  
    public:  
         StateA(Context *context){  this->context=context;  }  
         void switch_state();  // need to implemented outside of the class
};  

class StateB:public State
{  
    private:  
        Context *context;  
    public:  
        StateB(Context *context){  this->context=context;  }  
        void switch_state();  
};  

class Context
{  
    private:  
        State *stateA,*stateB,*state;  
    public:  
        Context(){  
            stateA=new StateA(this);  
            stateB=new StateB(this);  
            this->state=stateA;  
        }  
        void switch_state(){  state->switch_state();  }  
        void setState(State* state){  this->state=state;  }  
        State* getStateA(){  return stateA;  }  
        State* getStateB(){  return stateB;  }  
};  

void StateA::switch_state(){  
    this->context->setState(this->context->getStateB());
    cout<<"State A change to state B!"<<endl;  
};  

void StateB::switch_state(){  
    this->context->setState(this->context->getStateA());
    cout<<"State B change to state A!"<<endl;  
};  

int main(){  
    Context *context=new Context();  
    context->switch_state();  
    context->switch_state();  
    context->switch_state();  
    context->switch_state();  
    return 0;  
}  
\end{lstlisting}
Output:
\begin{verbatim}
State A change to state B! 
State B change to state A! 
State A change to state B! 
State B change to state A! 
\end{verbatim}

\paragraph{Example 3}\mbox{}
The State pattern allows an object to change its behavior when its internal state changes.
This pattern can be observed in a vending machine.
Vending machines have states based on the inventory, amount of currency deposited, the ability to make change, the item selected, etc.
When currency is deposited and a selection is made, a vending machine will either deliver a product and no change,
deliver a product and change, deliver no product due to insufficient currency on deposit, or deliver no product due to inventory depletion. 
\begin{lstlisting}[caption={State Pattern exmaple 3: vending (tissue only) meachine}, language=C++]
#include<iostream>  
using namespace std;  
class TissueMachine;

class State{  
public:  
    virtual void insertQuarter()=0;//  
    virtual void ejectQuarter()=0;//
    virtual void turnCrank()=0;//tissue is carring out
    virtual void dispense()=0;//tissue is being selling  
};  
  
class SoldOutState:public State{//  
private:  
    TissueMachine* tissueMachine;  
public:  
    SoldOutState(TissueMachine *tissueMachine){  this->tissueMachine=tissueMachine;  }  
    void insertQuarter();  
    void ejectQuarter();  
    void turnCrank();  
    void dispense();  
};  

class NoQuarterState:public State{
private:  
    TissueMachine* tissueMachine;  
public:  
    NoQuarterState(TissueMachine *tissueMachine){  this->tissueMachine=tissueMachine;  }  
    void insertQuarter();  
    void ejectQuarter();  
    void turnCrank();  
    void dispense();  
};  
class HasQuarterState:public State{
private:  
    TissueMachine* tissueMachine;  
public:  
    HasQuarterState(TissueMachine *tissueMachine){  this->tissueMachine=tissueMachine;  }  
    void insertQuarter();  
    void ejectQuarter();  
    void turnCrank();  
    void dispense();  
};  
class SoldState:public State{
private:  
    TissueMachine* tissueMachine;  
public:  
    SoldState(TissueMachine *tissueMachine){  this->tissueMachine=tissueMachine;  }  
    void insertQuarter();  
    void ejectQuarter();  
    void turnCrank();  
    void dispense();  
};  
  
class TissueMachine{  
private:  
    State *soldOutState,*noQuarterState,*hasQuarterState,*soldState,*state;  
    int count;//numbers of tissue  
public:  
    TissueMachine(int numbers){
        soldOutState=new SoldOutState(this);  
        noQuarterState=new NoQuarterState(this);  
        hasQuarterState=new HasQuarterState(this);  
        soldState=new SoldState(this);  
        this->count=numbers;  
        if (count> 0) {    this->state=noQuarterState;  }  
    };  

    // functions for clients
    void insertQuarter(){  state->insertQuarter();  }  
    void ejectQuarter(){  state->ejectQuarter();  }  
    void turnCrank(){  
        state->turnCrank();  
        state->dispense();  
    }  
    void setState(State* state){  this->state=state;  }  
    State* getHasQuarterState(){  return hasQuarterState;  }  
    State* getNoQuarterState(){  return noQuarterState;  }  
    State* getSoldState(){  return soldState;  }     
    State* getSoldOutState(){  return soldOutState;  }  
    int getCount(){  return count;  };  
    void setCount(int numbers){  this->count=numbers;  };  
};  
  
void SoldOutState::insertQuarter(){       
    cout<<"SoldOutState:No tissue in machine, take quarter back!"<<endl;  
}  
void SoldOutState::ejectQuarter(){  
    cout<<"SoldOutState:No quarter in the machine!"<<endl;  
}  
void SoldOutState::turnCrank(){  
    cout<<"SoldOutState:Tisse has sold out, don't operate machine!"<<endl;  
}  
void SoldOutState::dispense(){  
}  

void NoQuarterState::insertQuarter(){         
    tissueMachine->setState(tissueMachine->getHasQuarterState());  
    cout<<"NoQuarterState: inserted quarter!"<<endl;  
}  
void NoQuarterState::ejectQuarter(){  
    cout<<"NoQuarterState: ejectQuarter"<<endl;  
}  
void NoQuarterState::turnCrank(){  
    cout<<"NoQuarterState: please insertQuarter!"<<endl;  
}  
void NoQuarterState::dispense(){  
}  

void HasQuarterState::insertQuarter(){  
    cout<<"HasQuarterState: insertQuarter!"<<endl;  
}  
void HasQuarterState::ejectQuarter(){  
    tissueMachine->setState(tissueMachine->getNoQuarterState());  
    cout<<"HasQuarterState: please take quarter back!"<<endl;  
}  
void HasQuarterState::turnCrank(){  
    tissueMachine->setState(tissueMachine->getSoldState());  
    cout<<"HasQuarterState: please take tissue!"<<endl;  
}  
void HasQuarterState::dispense(){  
}  

void SoldState::insertQuarter(){  
    cout<<"SoldState: insertQuarter"<<endl;  
}  
void SoldState::ejectQuarter(){  
    tissueMachine->setState(tissueMachine->getNoQuarterState());  
    cout<<"SoldState: cannot take quarter back!"<<endl;  
}  
void SoldState::turnCrank(){  
    cout<<"SoldState: wait for the tissue!"<<endl;  
}  
void SoldState::dispense(){
    if(tissueMachine->getCount()>0){  
        tissueMachine->setState(tissueMachine->getNoQuarterState());  
        tissueMachine->setCount(tissueMachine->getCount()-1);  
        cout<<"SoldOutState:Please take your tissue!"<<endl;  
    }  
    else{  
        tissueMachine->setState(tissueMachine->getSoldOutState());  
        cout<<"SoldOutState: no tissue anymore, take your quarter back!"<<endl;  
    }  
}     

int main(){  
    TissueMachine *tissueMachine=new TissueMachine(1);  
    cout<<"No. of Tissue:"<<tissueMachine->getCount()<<endl;  
    tissueMachine->insertQuarter();//insertQuarter  
    tissueMachine->turnCrank();//take tissue  
    cout<<"No. of tissue:"<<tissueMachine->getCount()<<endl;//take tissue without quarter  
    tissueMachine->turnCrank();   
    cout<<"No. of Tissue:"<<tissueMachine->getCount()<<endl;//insertQuarter when soldout
    tissueMachine->insertQuarter();    
    tissueMachine->turnCrank();   
    return 0;  
}  
\end{lstlisting}

\paragraph{Exmaple 4: an FSM with two states and two events}
distributed transition logic - logic in the derived state classes.
\begin{lstlisting}[caption={State Pattern exmaple 4: state meachine}, language=C++]
#include <iostream>
using namespace std;

class Machine
{
  class State *current;
  public:
    Machine();
    void setCurrent(State *s) { current = s; }
    void on();
    void off();
};

class State// abstract states
{
  public:
    virtual void on(Machine *m) { cout << "   already ON\n"; }
    virtual void off(Machine *m) { cout << "   already OFF\n"; }
};

void Machine::on() { current->on(this); }
void Machine::off() { current->off(this); }

class ON: public State
{
  public:
    ON() { cout << "   ON-ctor "; };
    ~ON() { cout << "   dtor-ON\n"; };
    void off(Machine *m);
};

class OFF: public State
{
  public:
    OFF() { cout << "   OFF-ctor "; };
    ~OFF() { cout << "   dtor-OFF\n"; };
    void on(Machine *m)
    {
        cout << "   going from OFF to ON";
        m->setCurrent(new ON());
        delete this;
    }
};

void ON::off(Machine *m)
{
  cout << "   going from ON to OFF";
  m->setCurrent(new OFF());
  delete this;
}

Machine::Machine()
{
  current = new OFF();
  cout << '\n';
}

int main()
{
  void(Machine:: *ptrs[])() = { Machine::off, Machine::on };
  Machine fsm;
  int num;
  while (1)
  {
    cout << "Enter 0/1: ";
    cin >> num;
    (fsm. *ptrs[num])();
  }
}
\end{lstlisting}
Output:
\begin{verbatim}
   OFF-ctor
Enter 0/1: 0
   already OFF
Enter 0/1: 1
   going from OFF to ON   ON-ctor    dtor-OFF
Enter 0/1: 1
   already ON
Enter 0/1: 0
   going from ON to OFF   OFF-ctor    dtor-ON
Enter 0/1: 1
   going from OFF to ON   ON-ctor    dtor-OFF
Enter 0/1: 0
   going from ON to OFF   OFF-ctor    dtor-ON
Enter 0/1: 0
   already OFF
Enter 0/1:
\end{verbatim}
\paragraph{Check list}

    Identify an existing class, or create a new class, that will serve as the "state machine" from the client's perspective. That class is the "wrapper" class.

    Create a State base class that replicates the methods of the state machine interface.
    Each method takes one additional parameter: an instance of the wrapper class. The State base class specifies any useful "default" behavior.

    Create a State derived class for each domain state. These derived classes only override the methods they need to override.

    The wrapper class maintains a "current" State object.

    All client requests to the wrapper class are simply delegated to the current State object, and the wrapper object's this pointer is passed.

    The State methods change the "current" state in the wrapper object as appropriate.

\paragraph{Rules of thumb}
    State objects are often Singletons.

    Flyweight explains when and how State objects can be shared.

    Interpreter can use State to define parsing contexts.

    Strategy has 2 different implementations, the first is similar to State. The difference is in binding times (Strategy is a bind-once pattern, whereas State is more dynamic).

    The structure of State and Bridge are identical (except that Bridge admits hierarchies of envelope classes, whereas State allows only one).
    The two patterns use the same structure to solve different problems: State allows an object's behavior to change along with its state,
    while Bridge's intent is to decouple an abstraction from its implementation so that the two can vary independently.

    The implementation of the State pattern builds on the Strategy pattern.
    The difference between State and Strategy is in the intent. With Strategy, the choice of algorithm is fairly stable.
    With State, a change in the state of the "context" object causes it to select from its "palette" of Strategy objects.
\chapter{Servant Pattern}\label{ServantPattern}
\paragraph{Discussion}\mbox{}
In software engineering, the servant pattern defines an object used to offer some functionality to a group of classes without defining that functionality in each of them.
A Servant is a class whose instance (or even just class) provides methods that take care of a desired service, while objects for which (or with whom) the servant does something, are taken as parameters.

Servant is used for providing some behavior to a group of classes.
Instead of defining that behavior in each class - or when we cannot factor out this behavior in the common parent class - it is defined once in the Servant.

For example: we have a few classes representing geometric objects (rectangle, ellipse, and triangle).
We can draw these objects on some canvas.
When we need to provide a “move” method for these objects we could implement this method in each class, or we can define an interface they implement and then offer the “move” functionality in a servant.
An interface is defined to ensure that serviced classes have methods, that servant needs to provide desired behavior.
If we continue in our example, we define an Interface “Movable” specifying that every class implementing this interface needs to implement method “getPosition” and “setPosition”.
The first method gets the position of an object on a canvas and second one sets the position of an object and draws it on a canvas.
Then we define a servant class “MoveServant”, which has two methods “moveTo(Movable movedObject, Position where)” and moveBy(Movable movedObject, int dx, int dy).
The Servant class can now be used to move every object which implements the Movable. Thus the “moving” code appears in only one class which respects the “Separation of Concerns” rule.

Design patterns Command (~\ref{CommandPattern} and Servant are very similar and implementations of them are often virtually the same. The difference between them is the approach to the problem.

    For the Servant pattern we have some objects to which we want to offer some functionality.
    We create a class whose instances offer that functionality and which defines an interface that serviced objects must implement.
    Serviced instances are then passed as parameters to the servant.

    For the Command pattern we have some objects that we want to modify with some functionality.
    So, we define an interface which commands which desired functionality must be implemented.
    Instances of those commands are then passed to original objects as parameters of their methods.

Even though design patterns Command and Servant are similar it doesn’t mean it’s always like that.
There are a number of situations where use of design pattern Command doesn’t relate to the design pattern Servant.
In these situations we usually need to pass to called methods just a reference to another method, which it will need in accomplishing its goal.
Since we can’t pass references to methods in many languages, we have to pass an object implementing an interface which declares the signature of passed method.

\subpart{Creational Patterns}
Creational design patterns are design patterns that deal with \textit{object creation} mechanisms, trying to create objects in a manner suitable to the situation.
The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.
\chapter{Simple Factory Pattern or static Factory Method}\label{StaticFactoryMethod}

\paragraph{Real world examples}
    Consider, you are building a house and you need doors. It would be a mess if every time you need a door, you put on your carpenter clothes and start making a door in your house.
    Instead you get it made from a factory.
\paragraph{In plain words}
    Simple factory simply generates an instance for client without exposing any instantiation logic to the client
\paragraph{Wikipedia says}
    In object$-$oriented programming (OOP), a factory is an object for creating other objects $–$
    formally a factory is a function or method that returns objects of a varying prototype or class from some method call, which is assumed to be "new".

\begin{lstlisting} [caption={Factory.cpp}, language=c++]
#include "Factory.h"
#include "ConcreteProductA.h"
#include "ConcreteProductB.h"

Product* Factory::createProduct(string proname)
{
	if ( "A" == proname ) 
        { return new ConcreteProductA(); }
	else if("B" == proname) 
        { return new ConcreteProductB(); }
	return  NULL;
}
\end{lstlisting}


\begin{lstlisting} [caption={more examples release or retain ownership.cpp}, language=c++]
// Factory returns object and ownership,  Caller responsible for deletion.
#include <memory>
class FactoryReleaseOwnership{
  public:
    std::unique_ptr<Foo> createFooInSomeWay()
    {
      return std::unique_ptr<Foo>(new Foo(some, args));
    }
};

// Factory retains object ownership,  Thus returning a reference.
#include <boost/ptr_container/ptr_vector.hpp>
class FactoryRetainOwnership{
  boost::ptr_vector<Foo>  myFoo;
  public:
    Foo& createFooInSomeWay(){
      // Must take care that factory last longer than all references.
      // Could make myFoo static so it last as long as the application.
      myFoo.push_back(new Foo(some, args));
      return myFoo.back();
    }
};
\end{lstlisting}

\begin{lstlisting} [caption={more examples\_2.cpp}, language=c++]
enum PRODUCTTYPE {SFJ,XSL,NAS};// different soap brands
class soapBase// interface for soaps
{
public:
	virtual ~soapBase(){};
	virtual void show() = 0;
};

class SFJSoap:public soapBase
{
	public: void show() {cout<<"SFJ Soap!"<<endl;}
};

class XSLSoap:public soapBase
{
	public: void show() {cout<<"XSL Soap!"<<endl;}
};

class NASSoap:public soapBase
{
	public: void show() {cout<<"NAS Soap!"<<endl;}
};

class Factory
{
  public:
	soapBase * creatSoap(PRODUCTTYPE type)
	{
		switch(type)
		{
			case SFJ: 
                return new SFJSoap(); 
                break;
			case XSL: 
                return new XSLSoap(); 
                break;
			case NAS: 
                return new NASSoap(); 
                break;
			default:break;
		}
	}
};

int main()
{
	Factory factory;
	soapBase* pSoap1 = factory.creatSoap(SFJ);
	pSoap1->show();
	soapBase* pSoap2 = factory.creatSoap(XSL);
	pSoap2->show();
	soapBase* pSoap3 = factory.creatSoap(NAS);
	pSoap3->show();
	delete pSoap1;
	delete pSoap2;
	delete pSoap3;
	return 0;
}
\end{lstlisting}

\begin{verbatim}
$ g++ main1.cpp -o main
$ ./main
SFJ Soap!
XSL Soap!
NAS Soap!
\end{verbatim}

\chapter{Factory Method Pattern}\label{FactoryMethod}

\paragraph{Real world example}

    Consider the case of a hiring manager.  It is impossible for this hiring manager to interview for each of the positions. 
    Based on the job opening, this hiring manager has to decide and delegate the interview steps to different people.

\paragraph{In plain words}

    It provides a way to delegate the instantiation logic to child classes.

\paragraph{Wikipedia says}

    In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects
    without having to specify the exact class of the object that will be created.
    This is done by creating objects by calling a factory method — either specified in an interface and implemented by child classes,
    or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor.


\begin{lstlisting}
    #include <iostream>  
    using namespace std;  
    enum SOAPTYPE {SFJ,XSL,NAS};  
      
    class soapBase  
    {  
        public:  
        virtual ~soapBase(){};  
        virtual void show() = 0;  
    };  
      
    class SFJSoap:public soapBase  
    {  
        public:  
        void show() {cout<<"SFJ Soap!"<<endl;}  
    };  
      
    class XSLSoap:public soapBase  
    {  
        public:  
        void show() {cout<<"XSL Soap!"<<endl;}  
    };  
      
    class NASSoap:public soapBase  
    {  
        public:  
        void show() {cout<<"NAS Soap!"<<endl;}  
    };  
      
    class FactoryBase  
    {  
        public:  
        virtual soapBase * creatSoap() = 0;  
    };  
      
    class SFJFactory:public FactoryBase  
    {  
        public:  
        soapBase * creatSoap()  
        {  
            return new SFJSoap();  
        }  
    };  
      
    class XSLFactory:public FactoryBase  
    {  
        public:  
        soapBase * creatSoap()  
        {  
            return new XSLSoap();  
        }  
    };  
      
    class NASFactory:public FactoryBase  
    {  
        public:  
        soapBase * creatSoap()  
        {  
            return new NASSoap();  
        }  
    };  
      
      
      
    int main()  
    {  
        SFJFactory factory1;  
        soapBase* pSoap1 = factory1.creatSoap();  
        pSoap1->show();  
        XSLFactory factory2;  
        soapBase* pSoap2 = factory2.creatSoap();  
        pSoap2->show();  
        NASFactory factory3;  
        soapBase* pSoap3 = factory3.creatSoap();  
        pSoap3->show();  
        delete pSoap1;  
        delete pSoap2;  
        delete pSoap3;  
        return 0;  
    }  
\end{lstlisting}

\begin{verbatim}
$ g++ main1.cpp -o main
$ ./main
SFJ Soap!
XSL Soap!
NAS Soap!
\end{verbatim}



\chapter{Abstract Factory}\label{AbstractFactoryPattern}

\paragraph{What's the difference between Abstract Factory Pattern and Factory Method?}\mbox{}

    Abstract Factory design pattern creates Factory

    Factory design pattern creates Products

\paragraph{Real world example}

    Extending our door example from Simple Factory.
    Based on your needs you might get a wooden door from a wooden door shop, iron door from an iron shop or a PVC door from the relevant shop.
    Plus you might need a guy with different kind of specialities to fit the door, for example a carpenter for wooden door, welder for iron door etc.
    As you can see there is a dependency between the doors now, wooden door needs carpenter, iron door needs a welder etc.

\paragraph{In plain words}

    A factory of factories; a factory that groups the individual but related/dependent factories together without specifying their concrete classes.

\paragraph{Wikipedia says}

    The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes
\paragraph{Definition:} A utility class that creates an instance of several families of classes. It can also return a factory for a certain group.

The Factory Design Pattern is useful in a situation that requires the creation of many different types of objects, all derived from a common base type.
The Factory Method defines a method for creating the objects, which subclasses can then override to specify the derived type that will be created.
Thus, at run time, the Factory Method can be passed a description of a desired object (e.g., a string read from user input) and return a base class pointer to a new instance of that object.
The pattern works best when a well-designed interface is used for the base class, so there is no need to cast the returned object.

\paragraph{Problem}
    We want to decide at run time what object is to be created based on some configuration or application parameter. When we write the code, we do not know what class should be instantiated.

\paragraph{Solution} 
    Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

In the following example, a factory method is used to create laptop or desktop computer objects at run time.

Let's start by defining Computer, which is an abstract base class (interface) and its derived classes: Laptop and Desktop.
\begin{lstlisting}[caption={Abstract Factory Pattern sample 1}, language=C++]
class Computer
{
 public:
     virtual void Run() = 0;
     virtual void Stop() = 0;
     virtual ~Computer() {}; /* without this, you do not call Laptop or Desktop destructor in this example! */
 };

class Laptop: public Computer
{
public:
    void Run() override {mHibernating = false;}; 
    void Stop() override {mHibernating = true;}; 
    virtual ~Laptop() {}; /* because we have virtual functions, we need virtual destructor */
private:
    bool mHibernating; // Whether or not the machine is hibernating
};

class Desktop: public Computer
{
public:
    void Run() override {mOn = true;}; 
    void Stop() override {mOn = false;}; 
    virtual ~Desktop() {};
private:
    bool mOn; // Whether or not the machine has been turned on
};

/The actual ComputerFactory class returns a Computer, given a real world description of the object.
class ComputerFactory
{
    public:
       static Computer *NewComputer(const std::string &description)
       {
           if(description == "laptop")
               return new Laptop;
           if(description == "desktop")
               return new Desktop;
           return NULL;
       }
};
\end{lstlisting}
Let's analyze the benefits of this design. First, there is a compilation benefit.
If we move the interface Computer into a separate header file with the factory, we can then move the implementation of the NewComputer() function into a separate implementation file.
Now the implementation file for NewComputer() is the only one that requires knowledge of the derived classes.
Thus, if a change is made to any derived class of Computer, or a new Computer subtype is added, the implementation file for NewComputer() is the only file that needs to be recompiled.
Everyone who uses the factory will only care about the interface, which should remain consistent throughout the life of the application.

Also, if there is a need to add a class, and the user is requesting objects through a user interface, no code calling the factory may be required to change to support the additional computer type.
The code using the factory would simply pass on the new string to the factory, and allow the factory to handle the new types entirely.

\begin{lstlisting}[caption={Abstract Factory Pattern sample 1}, language=C++]
#include <iostream>  
using namespace std;  
enum SOAPTYPE {SFJ,XSL,NAS};  
enum TOOTHTYPE {HR,ZH};  
  
class SoapBase  
{  
  public:  
    virtual ~SoapBase(){};  
    virtual void show() = 0;  
};  
  
class SFJSoap:public SoapBase  
{  
    public:  void show() {cout<<"SFJ Soap!"<<endl;}  
};  
  
class NASSoap:public SoapBase  
{  
    public:  void show() {cout<<"NAS Soap!"<<endl;}  
};  
  
class ToothBase  
{  
  public:  
    virtual ~ToothBase(){};  
    virtual void show() = 0;  
};  
  
class HRTooth:public ToothBase  
{  
    public:  void show() {cout<<"Hei ren Toothpaste!"<<endl;}  
};  
  
class JJSTooth:public ToothBase  
{  
    public:  void show() {cout<<"JJS Toothpaste!"<<endl;}  
};  
  
class FactoryBase  //interface
{  
  public:  
    virtual SoapBase * creatSoap() = 0;  
    virtual ToothBase * creatToothpaste() = 0;  
};  
  
class FactoryA :public FactoryBase  
{  
  public:  
    SoapBase * creatSoap()  {  return new SFJSoap();  }  
    ToothBase * creatToothpaste()  {  return new HRTooth();  }  
};  
  
class FactoryB :public FactoryBase  
{  
  public:  
    SoapBase * creatSoap()  {  return new NASSoap();  }  
    ToothBase * creatToothpaste()  {  return new JJSTooth();  }  
};  
  
int main()  
{  
    FactoryA factory1;  
    FactoryB factory2;  
    SoapBase *pSoap1 = NULL;  
    ToothBase *pToothpaste1 = NULL;  
    pSoap1 = factory1.creatSoap();  
    pToothpaste1 = factory1.creatToothpaste();  
    pSoap1->show();  
    pToothpaste1->show();  
      
    SoapBase *pSoap2 = NULL;  
    ToothBase *pToothpaste2 = NULL;  
    pSoap2 = factory2.creatSoap();  
    pToothpaste2 = factory2.creatToothpaste();  
    pSoap2->show();  
    pToothpaste2->show();  
      
    delete pSoap1;  
    delete pSoap2;  
    delete pToothpaste1;  
    delete pToothpaste2;  
      
    return 0;  
}  
\end{lstlisting}

\begin{verbatim}
$ g++ main1.cpp -o main
$ ./main
SFJ Soap!
Hei ren Toothpaste!
NAS Soap!
JJS Toothpaste!
\end{verbatim}

\paragraph{Exmaple 2}
%\url{http://www.dorodnic.com/blog/2014/03/29/abstract-factory/}
Every implementation starts with an interface. For my example, I’ve decided to implement an inheritance-tree of geometric shapes, so the parent will look something like this:
\begin{lstlisting}[caption={Abstract Factory Pattern sample 2-1}, language=C++]
namespace Common
{
    class IShape//interface
    {
      public:
        virtual double GetArea() const = 0;
        // More virtual functions here
        virtual ~IShape() {};
    };
}

//Next, we will implement a couple of concrete shape classes:

// Rectangle.h
..
namespace SimpleShapes
{
    class Rectangle : public Common::IShape
    {
    public:
        Rectangle(double width, double height);
        Rectangle(rapidxml::xml_node<>* node);
        virtual double GetArea() const;
    private:
        double _width;
        double _height;
    };
}

// Rectange.cpp
..
namespace SimpleShapes
{
    double Rectangle::GetArea() const
    {
        return _height * _width;
    }

    Rectangle::Rectangle(double width, double height) 
        : _width(width), _height(height) { }

    Rectangle::Rectangle(rapidxml::xml_node<>* node)
        : _width(0), _height(0)
    {
        rapidxml::xml_attribute<>* pWidthAttr = node->first_attribute("Width");
        _width = atof(pWidthAttr->value());

        rapidxml::xml_attribute<>* pHeightAttr = node->first_attribute("Height");
        _height = atof(pHeightAttr->value());
    }
}
\end{lstlisting}

Note that all concrete implementations support construction from XML.  I’ve chosen RapidXML for parsing. It’s easy to use and has the added benefit of header-only distribution.
Our goal will be to hide the concrete methods for construction of sub-classes from XML, so that the client will not need to know or care about them.
\paragraph{The Motivation}

Before diving into the solution, let’s recap why would we want a generic mechanism for constructing sub-classes in the first-place.

    It will (hopefully) enable us and the community to add new shapes even after deployment as plug-ins, without changing any client code.

    It will enable us to augment our implementations with new functionality such as logging, thread-safety, performance monitoring and more using the Decorator pattern~\ref{DecoratorPattern}

    It will enable us to test our code better by providing mock implementations when needed (Dependency Injection~\ref{DependencyInjectionPattern})

    In general, it will reduce coupling between different shape implementations and client code


\paragraph{Shape Factory Class}
//Abstract Factory is commonly implemented as a Singleton:

\begin{lstlisting}[caption={Abstract Factory Pattern sample 2-1}, language=C++]
// ShapeFactory.h
..
namespace Common
{
    class ShapeFactory
    {
    public:
        static ShapeFactory& Instance();
        IShape * Create(rapidxml::xml_node<> * node) const;
    };
}

// ShapeFactory.cpp
..
ShapeFactory& ShapeFactory::Instance()
{
    static ShapeFactory factory;
    return factory;
}
\end{lstlisting}
When would you not implement Factory as a Singleton?
Consider our little shape project. We might want to have multiple implementations for each of our shapes, using different 3rd Party libraries.
For example, in some parts of the program we will want the underlying implementation to rely on boost::geometry, while in others we might prefer more powerful CGAL implementation.
In addition, our unit-tests might benefit from mock implementations for some of the test cases.
This can be accomplished by specifying the desired strategy in some global configuration. Alternatively, you might prefer to have multiple factories.

\paragraph{Perfectly Legal Solution}
The simplest way to implement Create is:

\begin{lstlisting}[caption={Abstract Factory Pattern sample 2 legal solution}, language=C++]
IShape* ShapeFactory::Create(rapidxml::xml_node<> * node) const
{
    if (key == "Circle") return new Circle(node);
    else if (key == "Rectangle") return new Rectangle(node);
    // ...
    else throw new std::exception("Unrecognized object type!");
}
\end{lstlisting}
Don’t be mistaken – this is perfectly legal implementation of the pattern.
It’s limited (no run-time plug-ins since all sub-classes have to be hard-coded) but it’s functional.
My biggest concern with this solution is that adding or removing a sub-class involves changing factory implementation.
This adds to the list of rituals and rain dances your team already has to practice, and in my experience, will almost always lead to (stupid) bugs.

\paragraph{Inversion of Control~\ref{IOC}}

Instead of the factory depending on all of the different implementations, we could make all implementations inform the factory how to construct themselves.
This will allow the factory to be extended with new sub-classes, and each sub-class to be self-contained.

So how do we translate “a way to construct itself” to code? There is no reflection so simply passing the class-name won’t cut it.
When implementing any sort of events, listeners or callbacks in C++ traditionally you can go down one of two paths:

    C-style: use function-pointers

    OOP-style: use polymorphism

While you can absolutely make an extensible factory out of function-pointers I personally can’t stand them (for implementation based on function-pointers see “C++ API Design”.
C++ 11 standard gives new life to functional solution with function element – check out this CodeProject article)

So, I would much rather define a new interface:

\begin{lstlisting}[caption={Abstract Factory Pattern sample 2-2}, language=C++]
namespace Common
{
    class IShapeMaker
    {
    public:
        virtual IShape * Create(rapidxml::xml_node<> * node) const = 0;
        virtual ~IShapeMaker() {}
    };
}
\end{lstlisting}
This interface will encapsulate all details of calling the concrete constructor. We can extend our factory to take advantage it:

\begin{lstlisting}[caption={Abstract Factory Pattern sample 2-3}, language=C++]
//ShapeFactory.h
class ShapeFactory
{
    public:
        void RegisterMaker(const std::string& key, IShapeMaker * maker);
    private:
        std::map<std::string, IShapeMaker*> _makers;
};

//ShapeFactory.cpp
void ShapeFactory::RegisterMaker(const std::string& key, IShapeMaker* maker)
{
    if (_makers.find(key) != _makers.end())
    {
        throw new std::exception("Multiple makers for given key!");
    }
    _makers[key] = maker;
}

IShape* ShapeFactory::Create(rapidxml::xml_node<> * node) const
{
    std::string key(node->name());
    auto i = _makers.find(key);
    if (i == _makers.end())
    {
        throw new std::exception("Unrecognized object type!");
    }
    IShapeMaker* maker = i->second;
    return maker->Create(node);
}
\end{lstlisting}
\paragraph{The Shape-Makers}

For this solution to work, every concrete shape class must provide a shape-maker aside him, looking something like that:

\begin{lstlisting}[caption={Abstract Factory Pattern sample 2-4}, language=C++]
// Circle.h
class CircleMaker : public IShapeMaker
{
public:
    virtual IShape * Create(rapidxml::xml_node<> * node) const
    {
        return new Circle(node);
    }
};
\end{lstlisting}
In fact all the shape-makers will look exactly like that, with the only difference being the name of the class being constructed. Sounds like a job for templates:

\begin{lstlisting}[caption={Abstract Factory Pattern sample 2-5}, language=C++]
// ShapeMaker.h
template<typename T>
class ShapeMaker : public IShapeMaker
{
public:
    virtual IShape * Create(rapidxml::xml_node<> * node) const
    {
        return new T(node);
    }
};
\end{lstlisting}

Using this small template we can avoid manually writing a class for every shape in our project.
This is the way we register a maker with the factory:
\begin{verbatim}
ShapeFactory::Instance().RegisterMaker("Circle", new ShapeMaker<Circle>());
\end{verbatim}

Since we are still obligated to register every shape, the shorter the registration is the better.
We can slice couple of extra tokens by letting the maker “take care of itself”:

\begin{lstlisting}[caption={Abstract Factory Pattern sample 2-6}, language=C++]
template<typename T>
class ShapeMaker : public IShapeMaker
{
public:
    ShapeMaker(const std::string& key)
    {
        ShapeFactory::Instance().RegisterMaker(key, this);
    }
}; 
\end{lstlisting}

This way we can reduce the registration to just throwing a maker in some static context:

\begin{verbatim}
// Circle.cpp
static Common::ShapeMaker<Circle> maker("Circle");
\end{verbatim}

Here’s how you use it:

\begin{lstlisting}[caption={Abstract Factory Pattern sample 2-1}, language=C++]
void main()
{
    char * str = "<Rectangle LibraryName=\"SimpleShapes.dll\" Width=\"5.3\" Height=\"3.7\" />";
    std::string content(str);

    xml_document<> doc;
    doc.parse(&content[0]);

    auto shape = ShapeFactory::Instance().Create(doc.first_node());
    auto area = shape->GetArea();
}
\end{lstlisting}
This way you can introduce new functionality to your project without re-compiling the client-app.
It’s important to note that using LoadLibrary opens you up to potential security risks.

\paragraph{Room for Improvement}

While the implementation in it’s current state is fully functional, there are a couple of things we could tighten up:

    Binary Compatibility – since I didn’t bother to hide the implementation details from potential client code,
    3rd Party plug-ins compiled with different version of C++ run-time or just different compilation parameters might not be compatible with existing binaries.
    The issue of binary-compatibility in C++ is complex, ultimately taking you towards using COM,
    but you can solve some of the challenges by hiding the implementation behind an interface or using the PIMPL idiom.

    Thread-Safety – there are numerous articles on ensuring thread-safety of Singleton implementation and thread-safety in general.
    You are also presented with a variety of threading and synchronization libraries to choose from.

    Ownership Management – depending on your preferred resource management strategy, you might want the factory to return a smart pointer of some sort.
    Similar to threading, you are presented with a wealth of options like reference counting, RAII wrapping and so on.

    Generalization – our Abstract Factory is quite concrete. It does the job of converting RapidXML nodes into Shapes, and that’s it.

    Tomorrow you might need a factory that receives some other type of input, and behaves in slightly different way.
    You might end up with quite a lot of duplicate code. However, creating an elegant generalization can be challenging. I would strongly suggest “Modern C++ Design” to anyone interested.
\chapter{Singleton Pattern}\label{SingletonPattern}
\paragraph{Intent}
The Singleton pattern ensures a class has only one instance/object, and provides a global point of access to it.

constructor is declared as ``private'' or ``protected'' to prevent from generating object.

class has static private pointer to it.

one public method generates the object.

\paragraph{implementation 1: lazy}
In this implementation, ``GetInstance()'' uses lazy initialization, which means that the return value, ``m\_pInstance'' is created only when the function is first being called upon.
\begin{lstlisting}[caption={sample code 1: lazily-initialized Singleton},language=C++]
class CSingleton  
{  
    public:  
         static CSingleton* GetInstance()  
         {  
            if ( m_pInstance == NULL )    
                m_pInstance = new CSingleton();  
            return m_pInstance;  
         }  
     private:  
          CSingleton(){}; //constructor 
          static CSingleton * m_pInstance;  
};  
// to Initialize static variable ``m\_pInstance'', the below line has to be added into the corresponding cpp file like, 
CSingleton* CSingleton::m_pInstance = NULL;
\end{lstlisting}
However, the problem is that the ``m\_pInstance'' is not deleted. next implementation is a improvement.
Some consider a memory leak to be an accumulation of data, of which you lose the references (and thus the ability to free them) during runtime.
In this case ``m\_pInstance'' is holding on to the memory right up to the end of the application, so does not have to be considered a memory leak.
Since most operating systems free the memory a process has been using when it terminates, ``m\_pInstance'' can be considered not to be leaking.
\paragraph{implementation 1.2: lazy-initializated singleton}
The constructor and copy constructor are hidden because they are made private, so no user has access to them except for the class itself.
The only way to instantiate a Log is by calling Instance() which checks whether or not this class has already been instantiated.
The first time that it's accessed, this guarantees that all accesses are to a valid object.
The disadvantages are that creation is not thread-safe, and that the object and any resources it acquires are not released at the end of the program.
\begin{lstlisting}[caption={sample code 1.2: lazy},language=C++]
class CSingleton    
{    
   public:    
        static CSingleton * GetInstance()    
        {    
            if(m_pInstance == NULL)    
                m_pInstance = new CSingleton();    
            return m_pInstance;    
        }    
    private:    
        CSingleton()    {    }    //constructor
        static CSingleton *m_pInstance;    

        class CGarbo    //1.nested class 
        {    
        public:    
            ~CGarbo()   //will be called when the program runs to end 
            {    
                if(CSingleton::m_pInstance)    
                    delete CSingleton::m_pInstance;    //release memory
            }    
        };    
        static CGarbo Garbo;    //2.static object 
};    
// to Initialize static variable ``m\_pInstance'', the below line has to be added into the corresponding cpp file like, 
CSingleton* CSingleton::m_pInstance = NULL;
\end{lstlisting}

\paragraph{implementation 2: eager initialization}
To Initialize the resource at the beginning of the program run. This is the one without thread safe.
Using a local static object, creation is thread-safe on any compiler that supports the C++11 threading model;
also, the object will be destroyed at the end of the program.
However, it is possible to access the object after its destruction (e.g. from the destructor of another static object), which could lead to nasty bugs.
\begin{lstlisting}[caption={sample code 1.2: eager initialization},language=C++]
class CSingleton    
{    
    public:    
        static CSingleton * GetInstance()    
        {    
            static CSingleton instance;    //local static 
            return &instance;    
        }    
    private:    
        CSingleton()      {    }   //constructor 
};    
\end{lstlisting}
\paragraph{We can modify the design of the code with the following constraints:}

    We do not want the singleton by copied so that there is only one instance, this can be achieved by declaring a private copy constructor and a private assignment operator.
    The GetInstance() method should return a reference rather than a pointer, this blocks a client from deleting the object, also, by making destructor private, we can achieve the same effect.

The revised code looks like this:

\begin{lstlisting}[caption={sample code 1.2: revised},language=C++]
#include <iostream>

class Singleton
{
    public:
    	static Singleton& getInstance(); 
    private:
    	Singleton() {std::cout << "Ctor\n";};
    	~Singleton() {std::cout << "Dtor\n";};
    	Singleton(const Singleton&);//copy 
    	const Singleton& operator=(const Singleton&);//assignment
};

Singleton& Singleton::getInstance() 
{
	static Singleton instance;
	return instance;
}

int main()
{
	Singleton &s1 = Singleton::getInstance();
	Singleton &s2 = Singleton::getInstance();
	return 0;
}
\end{lstlisting}

\paragraph{implementation 3: Thread safe: Double-Checked Locking Patter}\label{DCLP}
\url{http://www.aristeia.com/Papers/DDJ\_Jul\_Aug\_2004\_revised.pdf}
\begin{lstlisting}[caption={sample code 3: thread safe},language=C++]
class Singleton  
{  
    public:  
        static Singleton* getInstance();  
      
    Singleton* Singleton::getInstance()  
    {  
        if(NULL == m_instance)  // 1st check!
        {  
            Lock();//for thread safe  
            if(NULL == m_instance) // double check !
            {  
                m_instance = new Singleton;  
            }  
            UnLock();  // problematic trade-off when deal with big data.
        }  
        return m_instance;  
    }

    private:  
        static Singleton* m_instance;  
        Singleton(){}  
}  
\end{lstlisting}

\paragraph{Exmaple 4: Meyers Singleton}

Luckily there is another solution that is very easy to implement and we call it the Meyers Singleton [Meyers]:
\begin{lstlisting}[caption={sample code 4: Meyers Singleton},language=C++]
class Log 
{
  public:
      static Log& Instance()
      {
        static Log theLog;
        return theLog;
      }
      void Write(char const *logline);
      bool SaveTo(char const *filename);
  private:
      Log();          // ctor is hidden
      Log(Log const&);      // copy ctor is hidden
      Log& operator=(Log const&);  // assign op is hidden
    
      static std::list<std::string> m_data;
};
\end{lstlisting}

This construction relies on the fact that function-static objects are only initialized when the function is first being called upon;
thus we maintain the benefit of dynamic initialization. (Function-static primitive variables like ``static int number=100;'' do get translated during compile time however!)

An additional safeguard is the returned \textbf{reference} instead of the pointer.
The caller cannot be tempted to delete the singleton (as was the case when we were returning a pointer).
The constructor is hidden, making it impossible for a user to instantiate a Log object; 
it would still be possible to assign the singleton Log to itself, however, and since this makes no sense we might just as well hide the assignment operator.

\begin{lstlisting}[caption={sample code 4: usage of Meyers Singleton},language=C++]
Log::Instance().Write("Test line");// works fine
Log &myLog = Log::Instance();// works fine
Log another = myLog;// FAILS
myLog = myLog;// works until we hide the assign ops!
\end{lstlisting}

To wrap it all up, here is an abstract of the Meyers Singleton:

\begin{lstlisting}[caption={sample code 4: abstract of Meyers Singleton},language=C++]
class Singleton 
{
 public:
    static Singleton& Instance() 
    {
      static Singleton theSingleton;
      return theSingleton;
    }
    /* more (non-static) functions here */
 private:
    Singleton(); // ctor hidden
    Singleton(Singleton const&); // copy ctor hidden
    Singleton& operator=(Singleton const&); // assign op. hidden
    ~Singleton(); // dtor hidden
};
\end{lstlisting}


\paragraph{Notes}
In 2009, the authors of the original design patterns said the only pattern they would consider removing from the original list is Singleton.
This is because it is essentially a way to store global data and tends to be an indicator of poor design.

There are several alternatives to the Singleton pattern:

1.    dependency injection

2.    Monostate pattern

3.    session context

\chapter{Monostate Pattern}\label{MonostatePattern}
\chapter{Prototype Pattern}\label{PrototypePattern}

Prototype allows us to \textbf{hide the complexity} of making new instances from the client. %In this sample, we used prototype manager to set the registry of concrete prototypes.
\paragraph{Intent}

    Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.

    Co-opt one instance of a class for use as a breeder of all future instances.

    The \textit{new} operator considered harmful.

\paragraph{Problem}
Application "hard wires" the class of object to create in each "new" expression.
\paragraph{Discussion}

Declare an abstract base class that specifies a pure virtual "clone" method, and, maintains a dictionary of all "cloneable" concrete derived classes.
Any class that needs a "polymorphic constructor" capability: derives itself from the abstract base class, registers its prototypical instance, and implements the clone() operation.

The client then, instead of writing code that invokes the "new" operator on a hard-wired class name,
calls a "clone" operation on the abstract base class, supplying a string or enumerated data type that designates the particular concrete derived class desired.
\paragraph{Implementation:} Declare an abstract base class that specifies a pure virtual clone() method.
Any class that needs a "polymorphic constructor" capability derives itself from the abstract base class, and implements the clone() operation.
\paragraph{Exmaple 0: for dummy}
Take an Exmaple, when you are looking for a job, you have to prepare resume. if without printer then you have to write it by hand and if there is an error, you have to update all your wrote resumes.
However if you have a printer and if resume has an error, you only need to change 1 copy and print updated resume.
The original resume is a \textit{Prototype} and the Printer can \textit{copy} them for you. the \textbf{key} to implement the pattern is to implement the ``clone'' function, in C++, which is to 
implement the \textbf{deep copy constructor}.

\begin{lstlisting}[caption={Prototype Pattern sample 0},language=C++]
class Resume  
{  
    public:  
        Resume() {}  
        virtual ~Resume() {}  
        virtual Resume* Clone() { return NULL; } // Clone !!!!!!!! 
        virtual void Set(char *n) {}  
        virtual void Show() {}  
    protected:  
        char *name;  
};  

class ResumeA : public Resume  
{  
public:  
    ResumeA(const char *str);  //constructor  
    ResumeA(const ResumeA &r); //copy constructor  
    ~ResumeA();                //  
    ResumeA* Clone();          //!!!!!!!  clone !!!!
    void Show();               //  
};  

ResumeA::ResumeA(const char *str) //constructor implementation   
{  
    if(str == NULL) {  
        name = new char[1];   
        name[0] = '\0';   
    }  
    else {  
        name = new char[strlen(str)+1];  
        strcpy(name, str);  
    }  
}  

ResumeA::~ResumeA() { delete [] name;}  

ResumeA::ResumeA(const ResumeA &r) {  
    name = new char[strlen(r.name)+1];  
    strcpy(name, r.name);  
}  

ResumeA* ResumeA::Clone() {  
    return new ResumeA(*this); //call copy constructor !!!!!!!! 
}  

void ResumeA::Show() {  cout<<"ResumeA name : "<<name<<endl;   }  

// the implementations of ResumeB ... is similar

int main()  
{  
    Resume *r1 = new ResumeA("A");  
    Resume *r2 = new ResumeB("B");  
    Resume *r3 = r1->Clone();  
    Resume *r4 = r2->Clone();  
    r1->Show();
    r2->Show();  
    delete r1;
    delete r2;     
    r1 = r2 = NULL;  
    //deep copy has no impact on r3,r4 !!!!!!!!!!! 
    r3->Show();
    r4->Show();  
    delete r3;
    delete r4;  
    r3 = r4 = NULL;  
}  
\end{lstlisting}

\paragraph{Example 0.1} Prototype Pattern essentially is to implement ``virtual constructor'' that C++ does not support. C++ can implement this feature by requiring
different derived classes to implement ``clone'' function.
\begin{lstlisting}[caption={Prototype Pattern sample 0.1},language=C++]
class Prototype // Virtual base class 
{  
  public:  
    Prototype(){}  
    virtual ~Prototype(){}  
    virtual Prototype *Clone() = 0; //derived classes need to implement it 
};  

class ConcretePrototype : public Prototype  
{  
 public :  
    ConcretePrototype()  :m_count(0)  {}  
    virtual ~ConcretePrototype()  {}   
    ConcretePrototype(const ConcretePrototype &cp)  //copy constructor
    {  
        m_count = cp.m_count;  
    }  
    virtual ConcretePrototype * Clone()  
    {  
        return new ConcretePrototype(*this);  //invoke copy constructor
    }  
private:  
    int m_count;  
};  

//client
int test_Prototype()  
{  
    ConcretePrototype *pa = new ConcretePrototype();  
    ConcretePrototype* pb = pa->Clone();  //copy itself
  
    delete pa;  
    delete pb;  
    pa = NULL;  
    pb = NULL;  
  
    system("pause");  
    return 0;  
}  
\end{lstlisting}


\begin{lstlisting}[caption={Prototype Pattern sample 1},language=C++]
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

const int N = 4;

class Document // Prototype, interface
{
public:
   virtual Document* clone() const = 0;
   virtual void store() const = 0;
   virtual ~Document() { }
};

// Concrete prototypes : xmlDoc, plainDoc, spreadsheetDoc
class xmlDoc : public Document 
{
public:
   Document*   clone() const { return new xmlDoc; }
   void store() const { cout << "xmlDoc\n"; }
};

class plainDoc : public Document 
{
public:
   Document* clone() const { return new plainDoc; }
   void store() const { cout << "plainDoc\n"; }
};

class spreadsheetDoc : public Document 
{
public:
   Document* clone() const { return new spreadsheetDoc; }
   void store() const { cout << "spreadsheetDoc\n"; }
};

// makeDocument() calls Concrete Portotype's clone() method inherited from Prototype
class DocumentManager 
{
   public:
      static Document* makeDocument( int choice );
      ~DocumentManager(){}
   private:
      static Document* mDocTypes[N];
};

Document* DocumentManager::mDocTypes[] = {0, new xmlDoc, new plainDoc, new spreadsheetDoc};

Document* DocumentManager::makeDocument( int choice ) 
{
   return mDocTypes[choice]->clone();
}

// for_each op ()
struct Destruct
{
    void operator()(Document *a) const { delete a; }
};

// Client
int main() 
{
   vector<Document*> docs(N);
   int choice;
   cout << "quit(0), xml(1), plain(2), spreadsheet(3): \n";
   while (true) {
	  cout << "Type in your choice (0-3)\n";
	  cin >> choice;
      if (choice <= 0 || choice >= N)
         break;
      docs[choice] = DocumentManager::makeDocument( choice );
   }

   for (int i = 1; i < docs.size(); ++i) 
	   if(docs[i]) docs[i]->store();

   Destruct d;
    // this calls Destruct::operator()
    for_each(docs.begin(), docs.end(), d);

   return 0;
}
\end{lstlisting}
Output:
\begin{verbatim}
quit(0), xml(1), plain(2), spreadsheet(3):
Type in your choice (0-3)
1
Type in your choice (0-3)
2
Type in your choice (0-3)
3
Type in your choice (0-3)
0
xmlDoc
plainDoc
spreadsheetDoc
\end{verbatim}

\paragraph{Example 2}

\textbf{Discussion.} Image base class provides the mechanism for storing, finding, and cloning the prototype for all derived classes.
Each derived class specifies a private static data member whose initialization "registers" a prototype of itself with the base class.
When the client asks for a "clone" of a certain type, the base class finds the prototype and calls clone() on the correct derived class.

\begin{lstlisting}[caption={Prototype Pattern sample 2},language=C++]
#include <iostream>

enum imageType { LSAT, SPOT };

class Image//interface
{
  public:
    virtual void draw() = 0;
    static Image *findAndClone(imageType);
  protected:
    virtual imageType returnType() = 0;
    virtual Image *clone() = 0;
    // As each subclass of Image is declared, it registers its prototype
    static void addPrototype(Image *image) { _prototypes[_nextSlot++] = image; }
  private:
    // addPrototype() saves each registered prototype here
    static Image *_prototypes[10];
    static int _nextSlot;
};

Image *Image::_prototypes[];
int Image::_nextSlot;

// Client calls this public static member function when it needs an instance of an Image subclass
Image *Image::findAndClone(imageType type)
{
  for (int i = 0; i < _nextSlot; i++)
    if (_prototypes[i]->returnType() == type)
      return _prototypes[i]->clone();
  return NULL;
}

class LandSatImage: public Image
{
  public:
    imageType returnType() { return LSAT; }
    void draw() { std::cout << "LandSatImage::draw " << _id << std::endl; }
    // When clone() is called, call the one-argument ctor with a dummy arg
    Image *clone() { return new LandSatImage(1); }
  protected:
    // This is only called from clone()
    LandSatImage(int dummy) { _id = _count++; }
  private:
    // Mechanism for initializing an Image subclass - this causes the
    // default ctor to be called, which registers the subclass's prototype
    static LandSatImage _landSatImage;
    // This is only called when the private static data member is initiated
    LandSatImage() { addPrototype(this); }
    // Nominal "state" per instance mechanism
    int _id;
    static int _count;
};

// Register the subclass's prototype
LandSatImage LandSatImage::_landSatImage;
// Initialize the "state" per instance mechanism
int LandSatImage::_count = 1;

class SpotImage: public Image
{
  public:
    imageType returnType() { return SPOT; }
    void draw() { std::cout << "SpotImage::draw " << _id << std::endl; }
    Image *clone() { return new SpotImage(1); }
  protected:
    SpotImage(int dummy) { _id = _count++; }
  private:
    SpotImage() { addPrototype(this); }
    static SpotImage _spotImage;
    int _id;
    static int _count;
};

SpotImage SpotImage::_spotImage;
int SpotImage::_count = 1;

// Simulated stream of creation requests
const int NUM_IMAGES = 8;
imageType input[NUM_IMAGES] = { LSAT, LSAT, LSAT, SPOT, LSAT, SPOT, SPOT, LSAT };

int main()
{
  Image *images[NUM_IMAGES];

  // Given an image type, find the right prototype, and return a clone
  for (int i = 0; i < NUM_IMAGES; i++)
    images[i] = Image::findAndClone(input[i]);

  // Demonstrate that correct image objects have been cloned
  for (int i = 0; i < NUM_IMAGES; i++)
    images[i]->draw();

  // Free the dynamic memory
  for (int i = 0; i < NUM_IMAGES; i++)
    delete images[i];
}
\end{lstlisting}
Output:
\begin{verbatim}
LandSatImage::draw 1
LandSatImage::draw 2
LandSatImage::draw 3
SpotImage::draw 1
LandSatImage::draw 4
SpotImage::draw 2
SpotImage::draw 3
LandSatImage::draw 5
\end{verbatim}
\paragraph{Check list}

    Add a clone() method to the existing "product" hierarchy.

    Design a "registry" that maintains a cache of prototypical objects. The registry could be encapsulated in a new Factory class, or in the base class of the "product" hierarchy.

    Design a factory method that: may (or may not) accept arguments, finds the correct prototype object, calls clone() on that object, and returns the result.

    The client replaces all references to the new operator with calls to the factory method.

\paragraph{Rules of thumb}

    Sometimes creational patterns are competitors: there are cases when either Prototype or Abstract Factory could be used properly.
    At other times they are complementary: Abstract Factory might store a set of Prototypes from which to clone and return product objects.
    Abstract Factory, Builder, and Prototype can use Singleton in their implementations.

    Abstract Factory classes are often implemented with Factory Methods, but they can be implemented using Prototype.

    Factory Method: creation through inheritance. Prototype: creation through delegation.

    Often, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory,
    Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed.

    Prototype doesn't require subclassing, but it does require an "initialize" operation. Factory Method requires subclassing, but doesn't require Initialize.

    Designs that make heavy use of the Composite and Decorator patterns often can benefit from Prototype as well.

    Prototype co-opts one instance of a class for use as a breeder of all future instances.

    Prototypes are useful when object initialization is expensive, and you anticipate few variations on the initialization parameters.
    In this context, Prototype can avoid expensive "creation from scratch", and support cheap cloning of a pre-initialized prototype.

    Prototype is unique among the other creational patterns in that it doesn't require a class – only an object.
    Object-oriented languages like Self and Omega that do away with classes completely rely on prototypes for creating new objects.


\chapter{Builder Pattern}\label{BuilderPattern}

\paragraph{Intent}
 1)   Separate the construction of a complex object from its representation so that the same construction process can create different representations.
  2)  Parse a complex representation, create one of several targets.
\paragraph{Problem}
We want to construct a complex object, however we do not want to have a complex constructor member or one that would need many arguments.
\paragraph{Solution}
Define an intermediate object whose member functions define the desired object part by part before the object is available to the client.
Builder Pattern lets us defer the construction of the object until all the options for creation have been specified. 
\paragraph{Example}
Assume that this pattern is used by fast food restaurants to construct children's meals.
Children's meals typically consist of a main item, a side item, a drink, and a toy (e.g., a hamburger, fries, Coke, and toy dinosaur).
Note that there can be variation in the content of the children's meal, but the construction process is the same.
Whether a customer orders a hamburger, cheeseburger, or chicken, the process is the same.
The employee at the counter directs the crew to assemble a main item, side item, and toy.
These items are then placed in a bag. The drink is placed in a cup and remains outside of the bag. This same process is used at competing restaurants.

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/builderss.PNG}}{\caption{Builder Pattern Example}\label{Builderpe}}
\end{floatrow}
\end{figure}

\paragraph{Discussion.}
The forte of Builder is constructing a complex object step by step.
An abstract base class declares the standard construction process, and concrete derived classes define the appropriate implementation for each step of the process.

In this example, ``distributed work packages'' have been abstracted to be persistent and platform independent.

This means that the platform-specific mechanism for implementing files, queues, and concurrency pathways is defined in each platform's concrete derived class.
A single "reader" object (i.e. parser) retrieves the archived specification for a DistrWorkPackage and proceeds to delegate each build step to the builder object that was registered by the client.
Upon completion, the client retrieves the end result from the builder.

\begin{lstlisting}[caption={Builder Patterns sample code 1}, language=C++]
#include <iostream.h>
#include <stdio.h>
#include <string.h>

enum PersistenceType { File, Queue, Pathway };

struct PersistenceAttribute
{
  PersistenceType type;
  char value[30];
};

class DistrWorkPackage
{
  public:
    DistrWorkPackage(char *type)
    {
        sprintf(_desc, "Distributed Work Package for: %s", type);
    }
    void setFile(char *f, char *v)
    {
        sprintf(_temp, "\n  File(%s): %s", f, v);
        strcat(_desc, _temp);
    }
    void setQueue(char *q, char *v)
    {
        sprintf(_temp, "\n  Queue(%s): %s", q, v);
        strcat(_desc, _temp);
    }
    void setPathway(char *p, char *v)
    {
        sprintf(_temp, "\n  Pathway(%s): %s", p, v);
        strcat(_desc, _temp);
    }
    const char *getState()
    {
        return _desc;
    }
  private:
    char _desc[200], _temp[80];
};

class Builder
{
  public:
    virtual void configureFile(char*) = 0;
    virtual void configureQueue(char*) = 0;
    virtual void configurePathway(char*) = 0;
    DistrWorkPackage *getResult() { return _result; }
  protected:
    DistrWorkPackage *_result;
};

class UnixBuilder: public Builder
{
  public:
    UnixBuilder() { _result = new DistrWorkPackage("Unix"); }
    void configureFile(char *name) { _result->setFile("flatFile", name); }
    void configureQueue(char *queue) { _result->setQueue("FIFO", queue); }
    void configurePathway(char *type) { _result->setPathway("thread", type); }
};

class VmsBuilder: public Builder
{
  public:
    VmsBuilder() { _result = new DistrWorkPackage("Vms"); }
    void configureFile(char *name) { _result->setFile("ISAM", name); }
    void configureQueue(char *queue) { _result->setQueue("priority", queue); }
    void configurePathway(char *type) { _result->setPathway("LWP", type); }
};

class Reader
{
  public:
    void setBuilder(Builder *b) { _builder = b; }
    void construct(PersistenceAttribute[], int);
  private:
    Builder *_builder;
};

void Reader::construct(PersistenceAttribute list[], int num)
{
  for (int i = 0; i < num; i++)
    if (list[i].type == File)
      _builder->configureFile(list[i].value);
    else if (list[i].type == Queue)
      _builder->configureQueue(list[i].value);
    else if (list[i].type == Pathway)
      _builder->configurePathway(list[i].value);
}

const int NUM_ENTRIES = 6;
PersistenceAttribute input[NUM_ENTRIES] = 
{
  { File, "state.dat" } , 
  { File, "config.sys" } , 
  { Queue, "compute" } , 
  { Queue, "log" } , 
  { Pathway, "authentication" } , 
  { Pathway, "error processing" }
};

int main()
{
  UnixBuilder unixBuilder;
  VmsBuilder vmsBuilder;
  Reader reader;

  reader.setBuilder(&unixBuilder);
  reader.construct(input, NUM_ENTRIES);
  cout << unixBuilder.getResult()->getState() << endl;

  reader.setBuilder(&vmsBuilder);
  reader.construct(input, NUM_ENTRIES);
  cout << vmsBuilder.getResult()->getState() << endl;
}
\end{lstlisting}
Output:
\begin{verbatim}
Distributed Work Package for: Unix
  File(flatFile): state.dat
  File(flatFile): config.sys
  Queue(FIFO): compute
  Queue(FIFO): log
  Pathway(thread): authentication
  Pathway(thread): error processing
Distributed Work Package for: Vms
  File(ISAM): state.dat
  File(ISAM): config.sys
  Queue(priority): compute
  Queue(priority): log
  Pathway(LWP): authentication
  Pathway(LWP): error processing
\end{verbatim}

\begin{lstlisting}[caption={Builder Patterns sample code 1}, language=C++]
#include <string>
#include <iostream>
#include <memory>
using namespace std;

class Pizza // "Product"
{
public:
	void setDough(const string& dough) { m_dough = dough; }
	void setSauce(const string& sauce) { m_sauce = sauce; }
	void setTopping(const string& topping) { m_topping = topping; }
	void open() const
	{
		cout << "Pizza with " << m_dough << " dough, " << m_sauce << " sauce and "
			<< m_topping << " topping. Mmm." << endl;
	}
private:
	string m_dough;
	string m_sauce;
	string m_topping;
};

class PizzaBuilder // "Abstract Builder"
{
public:
	virtual ~PizzaBuilder() {};
	Pizza* getPizza() { return m_pizza.release(); }
	void createNewPizzaProduct() { m_pizza = make_unique<Pizza>(); }
	virtual void buildDough() = 0;
	virtual void buildSauce() = 0;
	virtual void buildTopping() = 0;
protected:
	unique_ptr<Pizza> m_pizza;
};

class HawaiianPizzaBuilder : public PizzaBuilder
{
public:
	virtual ~HawaiianPizzaBuilder() {};

	virtual void buildDough() { m_pizza->setDough("cross"); }
	virtual void buildSauce() { m_pizza->setSauce("mild"); }
	virtual void buildTopping() { m_pizza->setTopping("ham+pineapple"); }
};

class SpicyPizzaBuilder : public PizzaBuilder
{
public:
	virtual ~SpicyPizzaBuilder() {};

	virtual void buildDough() { m_pizza->setDough("pan baked"); }
	virtual void buildSauce() { m_pizza->setSauce("hot"); }
	virtual void buildTopping() { m_pizza->setTopping("pepperoni+salami"); }
};

class Cook
{
public:
	void openPizza() { m_pizzaBuilder->getPizza()->open(); }
	void makePizza(PizzaBuilder* pb)
	{
		m_pizzaBuilder = pb;
		m_pizzaBuilder->createNewPizzaProduct();
		m_pizzaBuilder->buildDough();
		m_pizzaBuilder->buildSauce();
		m_pizzaBuilder->buildTopping();
	}
private:
	PizzaBuilder* m_pizzaBuilder;
};

int main()
{
	Cook cook;
	HawaiianPizzaBuilder hawaiianPizzaBuilder;
	SpicyPizzaBuilder    spicyPizzaBuilder;

	cook.makePizza(&hawaiianPizzaBuilder);
	cook.openPizza();

	cook.makePizza(&spicyPizzaBuilder);
	cook.openPizza();
}
\end{lstlisting}
\paragraph{Rules of thumb}

Sometimes creational patterns are complementary: Builder can use one of the other patterns to implement which components get built.
Abstract Factory~\ref{AbstractFactoryPattern}, Builder, and Prototype~\ref{PrototypePattern} can use Singleton in their implementations.

Builder focuses on constructing a complex object step by step. Abstract Factory emphasizes a family of product objects (either simple or complex).
Builder returns the product as a final step, but as far as the Abstract Factory is concerned, the product gets returned immediately.

Builder often builds a Composite.

Often, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory,
Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed.


\subpart{Structural Patterns}\label{StructuralPattern}
\chapter{Facade Pattern}\label{FacadePattern}

\paragraph{Intent}
Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

Facade pattern is different from adapter pattern~\ref{AdapterPattern} because facade simplifies a class structure while adapter keeps the same class structure.
The Facade Pattern \textbf{hides the complexities} of the system by providing an interface to the client from where the client can access the system on an unified interface.
Facade defines a higher-level interface that makes the subsystem easier to use.
\paragraph{Exmaple}
How do you turn on the computer? "Hit the power button" you say! That is what you believe because you are using a simple interface that computer provides on the outside,
internally it has to do a lot of stuff to make it happen. This simple interface to the complex subsystem is a facade.
\textbf{Facade pattern} provides a simplified interface to a complex subsystem.
\textbf{Wikipedia says} A facade is an object that provides a simplified interface to a larger body of code, such as a class library.
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/facade.PNG}}{\caption{Diagram}\label{facadep}}
\end{floatrow}
\end{figure}
The Facade pattern is a way to structure our API into subsystems to reduce ever growing size and complexity of interfaces of API.

\begin{lstlisting}[caption={Facade Pattern sample 1}, language=C++]
#include <iostream>

class SubSystemOne
{
public:
	void MethodOne(){ std::cout << "SubSystem 1" << std::endl; };
};

class SubSystemTwo
{
public:
	void MethodTwo(){ std::cout << "SubSystem 2" << std::endl; };
};

class SubSystemThree
{
public:
	void MethodThree(){ std::cout << "SubSystem 3" << std::endl; }
};

class Facade
{
public:kk
    Facade()
    {
	    pOne = new SubSystemOne();
	    pTwo = new SubSystemTwo();
	    pThree = new SubSystemThree();
    }
    void MethodA()
    {
    	std::cout << "Facade::MethodA" << std::endl;
    	pOne->MethodOne();
    	pTwo->MethodTwo();
    }
    void MethodB()
    {
    	std::cout << "Facade::MethodB" << std::endl;
    	pTwo->MethodTwo();
    	pThree->MethodThree();
    }
private:
    SubSystemOne *pOne;
    SubSystemTwo *pTwo;
    SubSystemThree *pThree;
};

int main()
{
    Facade *pFacade = new Facade();

    pFacade->MethodA();
    pFacade->MethodB();

    return 0;
}
\end{lstlisting}
Output is:
\begin{verbatim}
Facade::MethodA
SubSystem 1
SubSystem 2
Facade::MethodB
SubSystem 2
SubSystem 3
\end{verbatim}
\paragraph{Example 2} Facade normally knows subclasses functionalities and responsibilities, as well it delegates client's requests to the right subclass.
subsystems don't know the existing of Facade.

\begin{lstlisting}[caption={Facade Pattern sample 2}, language=C++]
#include<iostream>  
using namespace std;  

class Scanner    
{    
public:    
    void Scan() { cout<<"syntax check!"<<endl; }    
};    
class Parser    
{    
public:    
    void Parse() { cout<<"semantic check!"<<endl; }    
};    
class GenMidCode    
{    
public:    
    void GenCode() { cout<<"Generate middle code!"<<endl; }    
};    
class GenMachineCode    
{    
public:    
    void GenCode() { cout<<"Generate machine code!"<<endl;}    
};    
//high level interface Fecade  
class Compiler    
{    
public:    
    void Run()     
    {    
        Scanner scanner;    
        Parser parser;    
        GenMidCode genMidCode;    
        GenMachineCode genMacCode;    
        scanner.Scan();    
        parser.Parse();    
        genMidCode.GenCode();    
        genMacCode.GenCode();    
    }    
};    
  
//client  
int main()    
{    
    Compiler compiler;    
    compiler.Run();    //client only need to invoke run method to run 
    return 0;    
}    
\end{lstlisting}
\paragraph{Example 3}
Imagine you set up a smart house where everything is on remote. So to turn the lights on you push lights on button - And same for TV,
AC, Alarm, Music, etc...

When you leave a house you would need to push a 100 buttons to make sure everything is off and are good to go which could be little 
annoying if you are lazy like me .
so I defined a Facade for leaving and coming back. (Facade functions represent buttons...) So when I come and leave I just make one 
call and it takes care of everything...

\begin{lstlisting}[caption={Facade Pattern sample 3}, language=C++]
#include <string>
#include <iostream>
using namespace std;

class Alarm
{
public:
	void alarmOn() { cout << "Alarm is on and house is secured"<<endl; }
	void alarmOff() { cout << "Alarm is off and you can go into the house"<<endl; }
};

class Ac
{
public:
	void acOn() { cout << "Ac is on"<<endl; }
	void acOff() { cout << "AC is off"<<endl; }
};

class Tv
{
public:
	void tvOn() { cout << "Tv is on"<<endl; }
	void tvOff() { cout << "TV is off"<<endl; }
};

class HouseFacade
{
	Alarm alarm;
	Ac ac;
	Tv tv;

public:
	HouseFacade(){}

	void goToWork()
	{
		ac.acOff();
		tv.tvOff();
		alarm.alarmOn();
	}

	void comeHome()
	{
		alarm.alarmOff();
		ac.acOn();
		tv.tvOn();
	}
};

int main()
{
	HouseFacade hf;

	//Rather than calling 100 different on and off functions thanks to facade I only have 2 functions...
	hf.goToWork();
	hf.comeHome();
}

The output of the program above is:
\begin{verbatim}
AC is off
TV is off
Alarm is on and house is secured
Alarm is off and you can go into the house
Ac is on
Tv is on
\end{verbatim}

\chapter{Bridge Pattern}\label{BridgePattern}
\paragraph{Alias:} ``handle and body'' or ``Interface'' Pattern.
\paragraph{Intent}
The pattern change the implementation relationship to composition relationship.
Decouple an abstraction from its implementation so that the two can vary independently.
Publish interface in an inheritance hierarchy, and bury implementation in its own inheritance hierarchy.
Beyond encapsulation, to insulation

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/bridge.PNG}}{\caption{Bridge Pattern}\label{bridgeadapterp}}
\end{floatrow}
\end{figure}
\paragraph{Bridge Pattern example 1}\mbox{}

\begin{lstlisting}[caption={Bridge Pattern sample code},label={lst:bridgepsc},language=C++]
#include <iostream>
using namespace std;

// Implementor
class DrawingImplementor {
public:
    virtual void drawSquare(double) = 0;
    virtual ~DrawingImplementor() { }
};
 
class DrawingImplementorA: public DrawingImplementor { // ConcreteImplementor A
public:
    DrawingImplementorA() { }
    virtual ~DrawingImplementorA() { }
 
	// example: drawing with BRUSH
    void drawSquare(double side) { cout << "\nImplementorA (Brush).square with side = "<< side << endl;}
};
 
class DrawingImplementorB: public DrawingImplementor { // ConcreteImplementor B
public:
    DrawingImplementorB() { }
    virtual ~DrawingImplementorB() { }
 
	// example: drawing with PENCIL
    void drawSquare(double side) { cout << "\nImplementorB (Pencil).square with side = "<< side << endl; }
};

class Shape {//interface
public:
    virtual void draw()= 0; // low-level
    virtual void resize(double pct) = 0; // high-level
    virtual ~Shape() { }
};
 
class Square: public Shape {
public:
    Square(double s, DrawingImplementor& Implementor) : side(s), drawingImplementor(Implementor) { }
    virtual ~Square() { }
 
    // low-level i.e. Implementation specific
    void draw() { drawingImplementor.drawSquare(side); }

    // high-level i.e. Abstraction specific
    void resize(double pct) { side *= pct; }
private:
    double side;
    DrawingImplementor& drawingImplementor; // !
};
 
int main(int argc, char* argv[]) {
    DrawingImplementorA ImplementorA;
    DrawingImplementorB ImplementorB;
 
    Square sqA(1, ImplementorA);
    Square sqB(2, ImplementorB);
 
    Shape* shapes[2];
    shapes[0] = &sqA;
    shapes[1] = &sqB;
 
    shapes[0]->resize(10);
    shapes[0]->draw();
    shapes[1]->resize(10);
    shapes[1]->draw();
 
    return 0;
}
\end{lstlisting}
Output from the run:
\begin{verbatim}
ImplementorA (Brush).square with side = 10

ImplementorB (Pencil).square with side = 20
\end{verbatim}

All operations on Shape subclasses are implemented in terms of abstract operations from the DrawingImplementor interface.
This decouples the Shape abstractions from the various Shape-specific implementations.
We refer to the relationship between Shape and DrawingImplementor as a bridge, because it bridges the abstraction and its implementation, letting them vary independently.
\paragraph{Bridge Pattern Example 2}
Phone has different brands and different functionalities while running different software.

\begin{lstlisting}[caption={Bridge Pattern sample code 2},label={lst:bridgepsc2},language=C++]
#include <iostream>
#include <string>
using namespace std;

class PhoneSW // interface, since software could be changed
{
public:
	virtual void run()=0;
};

class PhoneGame:public PhoneSW 
{
public:
	void run() { cout<<"run phone games!"<<endl; }
};

class PhoneContactbook:public PhoneSW 
{
public:
	void run() { cout<<"run phone contactbook"<<endl; }
};

class PhoneBrand 
{
protected:
	PhoneSW *psoftware;
public:
	void setPhoneSoftware(PhoneSW *soft) { this->psoftware = soft; }
	virtual void run()=0;
};

class PhoneBrandA:public PhoneBrand 
{
public:
	void run() { psoftware->run(); }
};

class PhoneBrandB:public PhoneBrand 
{
public:
	void run() { psoftware->run(); }
};

int main()
{
	PhoneBrand *pb;
	pb = new PhoneBrandB();
	
	pb->setPhoneSoftware(new PhoneGame());
	pb->run();
	pb->setPhoneSoftware(new PhoneContactbook());
	pb->run();

	return 0;
}
\paragraph{Bridge Pattern Exmaple 3}
Assume we need to provide 3 different pens, such big, medium and samll and also need to draw 5 different colors. if we use crayon then we need to provide 3\*5=15 crayons.
however, if we can provide brush then we only need to provide 3 brushes plus 5 different color box, this combination can do the same work as 15 crayons.
the different between crayon and brush is that if it different the pen tool and color.

\paragraph{Bridge Pattern Exmaple 4}
%\url{https://www.codeproject.com/Articles/890/Bridge-Pattern-Bridging-the-gap-between-Interface}
Development, Marketing and Technical Support teams play a vital role in the success of a software product.
Development team is of course the backbone of the product, Marketing team plays a key role in selling the product and Technical support team provides after sales support to the customers.
Often, I use to think why development team could not provide support. I found the answer only after a very long time.
Technical support team should interact with both customers and computers, whereas the development team spends most of their time in hacking computers.
So, the members working in both teams should have different mind set and have totally different roles to play.
On top of this, the nature of operation in both the teams is mutually exclusive.
For example, we can see products having 24 x 7 technical support, whereas the development team hardly works round the clock.
The change in the operational strategy in one of the team will not have a direct impact on the other.
In short, the technical support team acts as an \textbf{interface} to the product whereas the development team \textbf{implements} the product.

I could relate the above-mentioned scenario with the Bridge Pattern.
Separating the technical support team from the development team is similar to isolating the abstraction from implementation.
That's what the Bridge Pattern is intended to do.
In this article, I will be talking about the Bridge Pattern, what, why and when it is needed. Benefits and drawbacks in using the Bridge Pattern are also presented.
The discussion will not be complete without mentioning about the variants and known uses of the Bridge Pattern in popular libraries. Let me start the discussion with a simple programming example.

Internet is a very good example for proving the fact, "A picture is better than thousand words".
When it all started, HTML was just a text based markup language, concentrating mainly on the structure of the document but not its presentation.
However, HTML has gone through various revisions to include graphics and images. Now, thousands of web sites, spread all over the Internet, contains GIF and JPEG images.
Though GIF and JPEG are popular image formats used on the web, there are hundreds of other image formats such as BMP, PCX, TIFF, TARGA etc.,
which serve very different purposes and are popular in different operating systems.
For example, BMP image format is widely used on Windows operating systems, however its existence is also there on OS/2, Macintosh and UNIX operating systems.

The structure and the representation are two important aspects of an image format.
The structure defines the way in which the image is stored and the representation deals with the display of the image.
For a given format, the structure remains the same across operating systems, whereas the representation or the way in which the image is displayed may vary between operating systems.
For example, the structure of a Windows BMP file remains unchanged in all operating systems,
but the mechanism used by the Windows operating system to display a BMP file is different from the one used by Macintosh or OS/2 operating systems to display the same file.
On the other hand, for a given operating system, the representation can remain unchanged across different image formats.
For example, Windows can display an image represented as a Bitmap object, without having to know about its source format which can be a BMP, a JPEG or a PCX.
In short, the representation and the structure of an image format are two different aspects and they should be allowed to 
vary independently based on the other factors like operating system, hardware etc.

Bridge Pattern classified under the Structural pattern by 'Gang of Four (GoF)' can be used to abstract and model these variations.
According to GoF, the Bridge Pattern is intended to "Decouple an abstraction from its implementation so that the two can vary independently".
In this article, I will be using the terms used by GoF to explain the Bridge Pattern.

This article uses an Image viewer application to explain the concept behind the Bridge Pattern. This sample application is designed to view BMP files on Windows operating systems.
However, it can easily be extended to view other image formats like JPEG on Windows or view BMP images on other operating systems like OS/2.

This example uses two-class hierarchies viz., CImage and CImageImp (see diagram).
CImage class hierarchy defines the abstraction for the clients and CImageImp class hierarchy provides implementation for the specified abstraction.
CImage and its derived classes are responsible for handling different image formats such as BMP, JPEG, PCX etc.,
and CImageImp classes are responsible for the representation of the images on different operating systems like Windows, OS/2.
The CImage object provides basic services for loading and showing images and it is configured with a CImageImp object.
Services that are dependent on a particular implementation (like show) are forwarded to CImageImp class (say to PaintImage).
In this way, new image formats can be added to the CImage class hierarchy without affecting the CImageImp and CImageImp can be extended
to provide implementation for a new operating system without affecting CImage. In short, the goal of the Bridge Pattern is achieved, that is, to vary abstraction and implementation independently.

Bridge Pattern has four participants that include Abstraction, Refined Abstraction, Implementor and Concrete Implementor.
In this example, the abstract image class CImage, is referred as the Abstraction,
the concrete image class CBmpImage (for handling Windows Bitmaps) is referred as Refined Abstraction,
the abstract image implementation class CImageImp is referred as Implementor and the concrete class CWinImp that implements
the interfaces of the Implementor is referred as the Concrete Implementor. The application using the CImage Abstraction is the client.
Depending on the operating system, the client can configure the CImage subclass (Refined Abstraction) with a concrete CImageImp class object (Concrete Implementor).

CImage maintains a reference to the CImageImp object.
When the client calls Load or Show method in CImage, it does some preprocessing and forwards the request to CImageImp object by
calling InitImageInfo or PaintImage method that provides the actual implementation.
Isolating the image and image implementation in separate class hierarchies entitles them to vary independently.
UML diagram showing the relationship between the participants of the Bridge Pattern is presented below.
Listing 1 contains the class declarations and Listing 2 contains sample method implementations.
\begin{lstlisting}[caption={Bridge Pattern sample Listing 1}, language=C++]
class CImage
{
    public :
        virtual INT Load( LPCSTR, CRuntimeClass * )    = 0;
        virtual INT Show( CWnd *, WPARAM );
    protected :
        CImageImp    * m_pImageImp;
};

class CBmpImage : public CImage
{
    public :
        virtual INT Load( LPCSTR, CRuntimeClass * );
};

class CImageImp : public CObject
{
    public :
        virtual INT    InitImageInfo( LPSTR )           = 0;
        virtual BOOL    PaintImage( CWnd *, CRect * )   = 0;
    public :
        LPBYTE      m_pImage;
        LONG        m_lNormalWidth;
        LONG        m_lNormalHeight;
};

class CWinImp : public CImageImp
{
    public :
        INT        InitImageInfo( LPSTR );
        BOOL       PaintImage( CWnd *, CRect * );
    protected :
        BYTE        * m_pBmi;
        CPalette    * m_pPalette;
};
\end{lstlisting}

\begin{lstlisting}[caption={Bridge Pattern sample Listing 2}, language=C++]
INT CImage::Show( CWnd * pWnd, WPARAM wParam )
{
    // Step 1 - Check and delegate this method to m_pImageImp
    ASSERT( m_pImageImp != NULL );
    return m_pImageImp->PaintImage( pWnd, ( CRect * ) wParam );
}

INT CBmpImage::Load( LPCSTR lpszFileName, CRuntimeClass * pRuntimeClass )
{
    // Some initialization code before creating image implementation object
    //...
    //  Initialize image information, after creating image implementation object
    m_pImageImp = ( CImageImp * ) pRuntimeClass->CreateObject();
    if( m_pImageImp == NULL )
    {
       // ...
        return FAILURE;
    }
    m_pImageImp->InitImageInfo(..);
    // ...
    return SUCCESS;
}
\end{lstlisting}



\chapter{Decorator Pattern}\label{DecoratorPattern}

\paragraph{Intent}
Attach additional responsibilities to an object dynamically.
Decorators provide flexible alternatives to subclassing for extending functionality. 

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/decorator.PNG}}{\caption{Decorator Pattern}\label{decoratorp}}
\end{floatrow}
\end{figure}

\paragraph{Example 1}
\begin{lstlisting}[caption={Decorator Pattern sample 1}, language=C++]
#include <iostream> 
#include <string>
using namespace std;
 
class Window //interface
{
public:
  virtual void draw() = 0;
  virtual string getDescription() = 0;
  virtual ~Window() {}
};
 
class SimpleWindow : public Window 
{
public:
  void draw() { /* draw window */ }
  string getDescription() { return "simple window\n"; }
};

class WindowDecorator : public Window 
{
public:
	WindowDecorator (Window *decoratedWindow): m_decoratedWindow(decoratedWindow) {}
protected:
	Window *m_decoratedWindow; 
};

class VerticalScrollBarDecorator : public WindowDecorator 
{
public:
	VerticalScrollBarDecorator (Window *decoratedWindow): 
		WindowDecorator(decoratedWindow) {}
 
	void draw() {
        drawVerticalScrollBar();
        m_decoratedWindow->draw();
    }
 
    string getDescription() {
        return m_decoratedWindow->getDescription() + "with vertical scrollbars\n";
    }
private:
	void drawVerticalScrollBar() { // draw the vertical scrollbar }
};

class HorizontalScrollBarDecorator : public WindowDecorator 
{
public:
	HorizontalScrollBarDecorator (Window *decoratedWindow): 
		WindowDecorator(decoratedWindow) {}
 
	void draw() {
        drawHorizontalScrollBar();
        m_decoratedWindow->draw();
    }
 
    string getDescription() {
        return m_decoratedWindow->getDescription() + "with horizontal scrollbars\n";
	}
private:
	void drawHorizontalScrollBar() { // draw the horizontal scrollbar }
};

int main()
{
  Window *simple = new SimpleWindow();
  cout << simple -> getDescription() << endl;

  Window *horiz = new HorizontalScrollBarDecorator ( new SimpleWindow());
  cout << horiz -> getDescription() << endl;

  Window *vert = new VerticalScrollBarDecorator ( new SimpleWindow());
  cout << vert -> getDescription() << endl;

  Window *decoratedWindow = new HorizontalScrollBarDecorator (
                new VerticalScrollBarDecorator(new SimpleWindow()));
  cout << decoratedWindow -> getDescription() << endl;

  return 0;
}
\end{lstlisting}
Output:
\begin{verbatim}
simple window

simple window
with horizontal scrollbars

simple window
with vertical scrollbars

simple window
with vertical scrollbars
with horizontal scrollbars
\end{verbatim}

Let's take a look at code with the class diagram.

    Each component (Window) can be used on its own, or wrapped by decorator.
    The ConcreteComponent (SimpleWindow) is the object we're going to dynamically add new behavior (vertical/horizontal scrollbars) to. It inherits Component.

\begin{verbatim}
    class SimpleWindow : public Window
\end{verbatim}
    Each decorator has-a (wraps) a component, which means the decorator has an instance variable that holds a pointer to a component.

\begin{verbatim}
    class WindowDecorator : public Window 
    {
    protected:
    	Window *m_decoratedWindow; 
    ...
\end{verbatim}
    Decorators implement the same interface or abstract class as the component they are going to decorate.
    The ConcreteDecorator has an instance variable for the thing it decorate (the Component the Decorator wraps).

\begin{verbatim}
    class VerticalScrollBarDecorator : public WindowDecorator 
    {
    public:
    	VerticalScrollBarDecorator (Window *decoratedWindow): 
    		WindowDecorator(decoratedWindow) {}
     
    	void draw() {
            drawVerticalScrollBar();
            m_decoratedWindow->draw();
        }
     
        string getDescription() {
            return m_decoratedWindow->getDescription() + "with vertical scrollbars\n";
        }
    ...
    };
\end{verbatim}

\paragraph{Example 2}\mbox{}
\paragraph{Why}
Suppose you have an object of a class.
And there is a feature of interest in that object.
Only if it did that extra little thing you wanted.
Oh it will be so perfect.
You can use that class object as it is.
Like you had an alarm clock. And along with the loud alarm, only if it also sprayed your face with water !!!
But this is a real world. You have to do with what you got.
So what you do? Inherit the class? And then change the method implementation in the derived class?
Yes you can but then isn’t inheritance to be avoided if possible? And what if the class is of sealed type?

Decorator solves this problem. It allows you to have functionality you want from the given object without needing the touch its class. And does that in a composition friendly way.

\paragraph{How}
So how do you bake a decorator.
You will need:

    The base class which you want to add more features to. (I will call it Cake)

    The interface which the base class was implementing in the first place. (I will call it ICake)

    A class called LayeredCake which also will implement the interface ICake.

    Inside the LayeredCake class you will need to hide a Cake class instance.

\begin{lstlisting}[caption={Decorator Pattern sample 2}, language=C++]
#include <string>  
#include <iostream>  
#include <memory>  
using namespace std;  
  
class ICar // interface 
{  
public:  
    virtual void fire()=0; //start engine, current feature
    virtual void race()=0; // speed, current feature
    virtual ~ICar()  {  cout<<"in the destructor of ICar"<<endl;  }     
};  

class VW:public ICar  //real car
{  
public:  
    void fire()  {  cout<<"VW  fire()"<<endl;  }  
    void race()  {  cout<<"VW  race()"<<endl;  }  
    virtual ~VW()  {  cout<<"In the destructor of VW"<<endl;  }  
};  

class BMW:public ICar  //real car
{  
public:  
    void fire()  {  cout<<"BMW fire()"<<endl;  }  
    void race()  {  cout<<" BMW race()"<<endl;  }  
    virtual ~BMW()  {  cout<<"In the destructor of BMW"<<endl;  }  
};  
  
class Decorator: public ICar  //Decorator  
{  
    public:  
        Decorator(ICar* ccar):car(ccar) {}  //concrete car Decorator class  
        virtual ~Decorator()  {  cout<<"In the destructor of Decorator"<<endl;  }  
        void fire()  {  car->fire();  }  
        void race()  {  car->race();  }  
    protected:  
        ICar* car;  
};  
      
class InfraredDecorator: public Decorator  // new feature
{  
    public:  
        InfraredDecorator(ICar* car):Decorator(car) {}  
        virtual ~InfraredDecorator()  {  cout<<"in the destructor of InfraredDecorator"<<endl;  }  
        void set_Infrared(const string &infrared)  {  this->infrared=infrared;  }  
        string get_infrared() const  {  return infrared;  }  
        void race()  
        {  
            car->race();  
            set_Infrared("+Infrared");  
            cout<<get_infrared()<<endl;  
        }  
        void fire()  {  car->fire();  }  
    private:  
        string infrared;//add Atrribute  
};  
      
class AmphibianDecorator:public Decorator  //new feature
{  
    public:  
        AmphibianDecorator(ICar* car):Decorator(car) {}  
        ~AmphibianDecorator()  {  cout<<"in the destructor of AmphibianDecorator"<<endl;  }  
        void set_amphibian(const string &hibian)  {  this->amphibian=hibian;  }  
        string get_amphibian() const  {  return amphibian;  }  
        void race()  
        {  
            car->race();  
            set_amphibian("+amphibian");  
            cout<<get_amphibian()<<endl;  
        }  
        void fire()  {  car->fire();  }  
    private:  
        string amphibian;  
};  
      
int main(int argc, char **argv)  
{  
    //add Infrared feature to VW  
    ICar* car1(new VW);  
    ICar* pid1(new InfraredDecorator(car1));  
    pid1->fire();  
    cout<<endl;  
    pid1->race();  
    cout<<endl;  
    cout<<endl<<"---------------"<<endl;  

    //add Infrared and Amphibian features to BMW
    ICar* car2(new BMW);  
    car2->race();  
    ICar* pid2(new InfraredDecorator(car2));  
    ICar* pad2(new AmphibianDecorator(pid2));  
    pad2->fire();  
    cout<<endl;  
    pad2->race();  
    cout<<endl;  
    cout<<endl<<"--------------"<<endl;  
  
   //remove decorator dynamically ?
    car2->race();  
  
    ICar * car3(car2);  
    car3->race();  
    return 0;  
}  
\end{lstlisting}

\paragraph{Example 3}
\begin{lstlisting}[caption={Decorator Pattern sample 3}, language=C++]
class Phone //interface 
{  
public:  
    Phone() {}  
    virtual ~Phone() {}  
    virtual void ShowDecorate() {}  
};  

class iPhone : public Phone  //real phone
{  
private:  
    string m_name; 
public:  
    iPhone(string name): m_name(name){}  
    ~iPhone() {}  
    void ShowDecorate() { cout<<m_name<<"'s decorator"<<endl;}  
};  

class NokiaPhone : public Phone  //real phone
{  
private:  
    string m_name;  
public:  
    NokiaPhone(string name): m_name(name){}  
    ~NokiaPhone() {}  
    void ShowDecorate() { cout<<m_name<<"'s decorator"<<endl;}  
};  

class DecoratorPhone : public Phone //interface 
{  
private:  
    Phone *m_phone;  //phone needs to be decorated  
public:  
    DecoratorPhone(Phone *phone): m_phone(phone) {}  
    virtual void ShowDecorate() { m_phone->ShowDecorate(); }  
};  

class DecoratorPhoneA : public DecoratorPhone  
{  
public:  
    DecoratorPhoneA(Phone *phone) : DecoratorPhone(phone) {}  
    void ShowDecorate() { DecoratorPhone::ShowDecorate(); AddDecorate(); }  
private:  
    void AddDecorate() { cout<<"add phone accessories"<<endl; }
};  

class DecoratorPhoneB : public DecoratorPhone  
{  
public:  
    DecoratorPhoneB(Phone *phone) : DecoratorPhone(phone) {}  
    void ShowDecorate() { DecoratorPhone::ShowDecorate(); AddDecorate(); }  
private:  
    void AddDecorate() { cout<<"add phone screen protector"<<endl; }
};  

int main()  
{  
    Phone *iphone = new NokiaPhone("6300");  
    Phone *dpa = new DecoratorPhoneA(iphone); //add accessory  
    Phone *dpb = new DecoratorPhoneB(dpa);    //add screen protector  
    dpb->ShowDecorate();  
    delete dpa;  
    delete dpb;  
    delete iphone;  
    return 0;  
}  
\end{lstlisting}

\chapter{Proxy Pattern}\label{ProxyPattern}

\paragraph{Let's take look at the diagram}

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/proxy.PNG}}{\caption{Proxy}\label{Proxypp}}
\end{floatrow}
\end{figure}

    Both the Proxy and the RealSubject implement the Subject interface. This allows any client to treat the Proxy just like the RealSubject.
    The RealSubject is usually the object that does most of the real work; the Proxy controls access to it.
    The control may be needed if the Subject is running on a remote machine, if the Subject is expensive to create in some way or if access to the subject needs to be protected in some way.
    The Proxy often instantiates or handle the creation of the RealSubject.
    The Proxy keeps a reference (pointer) to the Subject, so it can forward requests to the Subject when necessary.
    In some cases, the Proxy may be responsible for creating and destroying the RealSubject. Clients interact with the RealSubject through the Proxy.

\begin{lstlisting}[caption={Proxy pattern exmaple 1}, language=C++]
class Subject 
{
    public:
        virtual void request() = 0;
        virtual ~Subject() {}
};
 
class RealSubject : public Subject 
{
    public:
         void request() { cout << "RealSubject.request()" << endl; }
};
 
class Proxy : public Subject 
{
    private:
        Subject* realSubject;
    public:
        Proxy() : realSubject (new RealSubject()) {}
        ~Proxy() { delete realSubject; }
        void request() { realSubject->request(); } // Forward calls to the RealSubject:
};
 
int main() {
    Proxy p;
    p.request();
}
\end{lstlisting}

A Proxy provides an interface that forwards function calls to another interface of the same form.
A Proxy pattern is useful to modify the behavior of the RealSubject class while still preserving its interface.
This is particularly useful if the RealSubject class is in third-party library and hence not easily modifiable directly.

\paragraph{Use cases of Proxy}
\subparagraph{1. Implement lazy instantiation of the RealSubject object}
    In this case, the RealSubject object is not actually instantiated until a method call is invoked.
    This can be useful if instantiating the RealSubject object is a heavyweight operation that we wish to defer until absolutely necessary.
 \subparagraph{2. Implement access control to the RealSubject object}
    We may want to insert a permissions layer between the Proxy and the RealSubject objects 
    to ensure that users can only call certain methods on the RealSubject object if they have appropriate permission.
 \subparagraph{3. Support debug or dry-run modes}
    This lets us insert debugging statement into the Proxy methods to log all call to the RealSubject object or
    we can stop the forwarding to certain RealSubject method with a flag to let us call the Proxy in a dry-run mode, such as to turn off writing the object's state to disk.
 \subparagraph{4. Make the RealSubject class to be thread safe}
    This can be done by adding mutex locking to the methods that are not thread safe.
    While this may not be the most efficient way to make the underlying class thread safe, it is a useful if we cannot modify the RealSubject.
 \subparagraph{5. Share resources}
    We could have multiple Proxy objects share the same underlying RealSubject class. This could be used to implement reference counting, for instance.
    This is, actually, another design pattern called the Flyweight pattern~\ref{FlyweightPattern}, where multiple objects share the same underlying data to minimize memory.
 \subparagraph{6. Protect against future changes in the RealSubject class}
    We anticipate that a dependent library will change in the future so we create a proxy wrapper around that API that directly mimics the current behavior.
    So, when the library changes later, we can preserve the old interface via our proxy object and simply change its underlying implementation to use the new library methods.

\paragraph{Remote Proxy}
With Remote Proxy, the proxy acts as a local representative for an object that lives in a different address space.
A method call on the proxy results in the call being transferred over the wire, invoked remotely, and the result being returned back to the proxy and then to the client.
\paragraph{Virtual Proxy/Copy-on-Write}
With Virtual Proxy, the proxy acts as a representative for an object that may be expensive to create. The Virtual Proxy often defers the creation of the object until it is needed.
The Virtual Proxy also act as a surrogate for the object before and while it is being created. After that, the proxy delegates requests directly to the RealSubject.
\paragraph{Protection Proxy/Protector Access}
With Protection Proxy, the proxy controls access to an object based on access rights.
For instance, if we had an employee object, a Protection Proxy might allow the employee to call certain methods on the object,
a manager to call additional methods (like makeBonus()), and a HR employee to call any method on the object.
\paragraph{Cache Proxy}
With Cache Proxy, the result of object operations has temporary save space so that multiple clients can share the result.
\paragraph{Firewall Proxy}
with Firewall Proxy, the proxy keep malicious clients from accessing to it.
\paragraph{Synchroization Proxy}
With Synchroization Proxy, multiple clients can use one same object.
\paragraph{SmartReference Proxy}
with SmartReference, the proxy/method can provide extra functions, e.g., to record the object reference counts.

\begin{lstlisting} [caption={SmartReference exmaple 1}, language=C++]
template<class T>    
  class auto_ptr {    
    public:    
        explicit auto_ptr(T *p = 0): pointee(p) {}    
        auto_ptr(auto_ptr<T>& rhs): pointee(rhs.release()) {}    // proxy
        ~auto_ptr() { delete pointee; }    
        auto_ptr<T>& operator=(auto_ptr<T>& rhs)    
        {    
            if (this != &rhs) reset(rhs.release());    
            return *this;    
        }    
        T& operator*() const { return *pointee; }    
        T* operator->() const { return pointee; }    
        T* get() const { return pointee; }    
        T* release()    
        {    
            T *oldPointee = pointee;    
            pointee = 0;    
            return oldPointee;    
        }    
        void reset(T *p = 0)    
        {    
            if (pointee != p) {    
                   delete pointee;    
                   pointee = p;    
                }    
            }    
    private:    
        T *pointee;    
};    
\end{lstlisting}

\begin{lstlisting} [caption={SmartReference exmaple 2}, language=c++]
template <typename T>  
 class smart_ptr  
    {  
    public:  
        smart_ptr(T *p = 0): pointee(p), count(new size_t(1)) { }  //  initialize to 1
        smart_ptr(const smart_ptr &rhs): pointee(rhs.pointee), count(rhs.count) { ++*count; } //copy constructor , +1
        ~smart_ptr() { decr_count(); }              //  
        smart_ptr& operator= (const smart_ptr& rhs) //assigment  
        {  
            ++*rhs.count;  
            decr_count();  
            pointee = rhs.pointee;  
            count = rhs.count;  
            return *this;  
        }    
        T *operator->() { return pointee; }  
        const T *operator->() const { return pointee; }  
        T &operator*() { return *pointee; }  
        const T &operator*() const { return *pointee; }  
        size_t get_refcount() { return *count; } //
    private:   
        T *pointee;       //real pointer, is being proxied
        size_t *count;    //  
        void decr_count() //-1  
        {  
            if(--*count == 0)   
            {  
                delete pointee;  
                delete count;  
            }  
        }  
    };  
\end{lstlisting}

\chapter{Composite Pattern}\label{CompositePattern}
\paragraph{Intent}
Composite objects into tree structures to represent part-whole hierarchies.
Composite lets clients treat individual objects and compositions of objects uniformly.

\begin{figure}[h]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/composition.PNG}}{\caption{Composite diagram}\label{Compositediagram}}
\end{floatrow}
\end{figure}

\begin{lstlisting}[caption={Composite Pattern - sample 1}, language=c++]
#include <vector>
#include <iostream> 
#include <algorithm> 
#include <functional> 
using namespace std;
 
class Graphic {
public:
  virtual void draw() const = 0;
  virtual void remove(Graphic *g) {}
  virtual void add(Graphic *g) {}
  virtual void getChild(int) {}
  virtual ~Graphic() {}
};
 
class Line : public Graphic {
public:
  void draw() const { cout << "Line draw()\n"; }
};

class Rectangle : public Graphic {
public:
  void draw() const { cout << "Rectangle draw() \n"; }
};

class Text : public Graphic {
public:
  void draw() const { cout << "Text draw() \n"; }
};

class Picture : public Graphic { // Composite object because it contain line, Rectangle and Text
public:
  void draw() const {
    // for each element in gList, call the draw member function
    for_each(gList.begin(), gList.end(), mem_fun(&Graphic;::draw));
  }
 
  void add(Graphic *aGraphic) { gList.push_back(aGraphic); }
 
private:
  vector<Graphic*> gList;
};
 
int main()
{
  Line line;
  line.draw();
  Rectangle rect;
  rect.draw();
  Text text;
  text.draw();

  Picture pic;
  pic.add(&line;);
  pic.add(&rect;);
  pic.add(&text;);
  pic.add(&rect;);
  pic.draw();

  return 0;
}
\end{lstlisting}
Output:
\begin{verbatim}
Line draw()
Rectangle draw()
Text draw()
Line draw()
Rectangle draw()
Text draw()
Rectangle draw()
\end{verbatim}
\paragraph{Here is the summary of the composite pattern.}
    The Composite pattern allows us to build structures of objects in the form of trees that contain both \textbf{composition} of objects and \textbf{individual} objects as nodes.
    Using a composite structure, we can apply the same operations over both composites and individual object.
    In other words, in most cases we can \textbf{ignore} the differences between composition of objects and individual objects.
\begin{verbatim}
    line.draw();	// individual object
    pic.draw();	// compositions of objects
\end{verbatim}
    The client uses the Component interface, draw() interface to manipulate the objects in the composition.

    The Component defines an interface for all objects in the composition both the composite (Picture) and the leaf (Line, Rectangle, and Text) nodes.

    The Component may implement a default behavior for add(), remove(), getChild() and its operation.

    Note that the Leaf also inherits methods like add(), remove(), and getChild(), which don't necessarily make a lot of sense for a leaf node.

    A leaf defines the behavior for the elements in the composition. It does this by implementing the operations the Composite supports.

    The composite's role is to define behavior of the components having children and to store child components.

    The composite also implements the Leaf-related operations.

\paragraph{In the next example}, we have two sub-classes: SimpleNode class which has limited features while the ComplextNode class has more complete set of functions
such as append\_node(), copy\_children(), and remove\_node etc.

\begin{lstlisting}[caption={Composite Pattern - sample 2}, language=c++]
#include <iostream>
#include <algorithm>
#include <cassert>
#include <functional>
#include <iterator>
#include <list>
#include <string>

using namespace std;

class Node
{
public:
    explicit Node(const std::string &n;) : m_name(n) { assert(!n.empty()); }
    const std::string& get_name() const { return m_name; }
    void set_name(const std::string &n;)
    {
        assert(!n.empty());
        m_name = n;
    }

    virtual Node* copy() const = 0;
    virtual ~Node() { }
    std::string m_name;

private:
    Node(const Node&);
    Node& operator=(const Node&);
};

class SimpleNode : public Node
{
private:
    SimpleNode(const std::string &n;, const std::string &v;) : Node(n), m_value(v)
    { assert(!n.empty()); }

public:
    static SimpleNode* create(const std::string &n;, const std::string &v;)
    {
        return new SimpleNode(n, v);
    }

    const std::string& get_value() const { return m_value; }
    void set_value(const std::string &v;) { m_value = v; }
    SimpleNode* copy() const
    {
        assert(!get_name().empty());
        return SimpleNode::create(get_name(), get_value());
    }

private:
    std::string m_value;
    SimpleNode(const SimpleNode&);
    SimpleNode& operator=(const SimpleNode&);
};

class ComplexNode : public Node
{
private:
    explicit ComplexNode(const std::string &n;) : Node(n) { assert(!n.empty()); }

    template<typename ITER>
        ComplexNode(const std::string &n;, ITER b, ITER e) : Node(n), m_child_nodes(b, e)
        { assert(!n.empty()); }

public:
    static ComplexNode* create(const std::string &s;) { return new ComplexNode(s); }

    template<typename ITER>
        static ComplexNode* create(const std::string &s;, ITER b, ITER e)
        { return new ComplexNode(s, b, e); }

    typedef std::list<Node*> ChildNodes;
    const ChildNodes& get_child_nodes() const { return m_child_nodes; }

    void append_node(Node *n)
    {
        assert(n != 0);
        m_child_nodes.push_back(n); 
    }

    void remove_node(Node *nd)
    {
        assert(nd != 0);
        ChildNodes &c; = m_child_nodes;
        ChildNodes::iterator i = std::find(c.begin(), c.end(), nd);
        if (i != c.end()) {
            c.erase(i);
        }
    }
	
    ComplexNode* copy() const
    {
        assert(!get_name().empty());
        ChildNodes c;
        copy_children(c);
        return ComplexNode::create(get_name(), c.begin(), c.end());
    }

    ~ComplexNode()
    {
        const ChildNodes &c; = get_child_nodes();
        ChildNodes::const_iterator b = c.begin();
        for ( ; b != c.end(); ++b) delete *b;

    }

private:
    void copy_children(ChildNodes &c;) const
    {
        assert(c.empty());
        const ChildNodes &t; = get_child_nodes();
        std::transform(t.begin(), t.end(), std::back_inserter(c),
                       std::mem_fun(&Node;::copy));
        assert(c.size() == t.size());
    }

    ChildNodes m_child_nodes;

    ComplexNode(const ComplexNode&);
    ComplexNode& operator=(const ComplexNode&);
};

int main()
{
	SimpleNode *sa = SimpleNode::create("simpleA", "sA");
	SimpleNode *sb = SimpleNode::create("simpleB", "sB");
	ComplexNode *ca = ComplexNode::create("cmplxA");
	ComplexNode *cb = ComplexNode::create("cmplxB");
	ComplexNode *cc = ComplexNode::create("cmplxC");
	ca->append_node(cb);
	ca->append_node(cc);
	cb->append_node(sa);
	cb->append_node(sb);

	list<Node*> nodes;
	nodes.push_back(ComplexNode::create("cmplx1"));
	nodes.push_back(ComplexNode::create("cmplx2"));
	list<Node*>::const_iterator b = nodes.begin(), e = nodes.end();
	ComplexNode *cd = ComplexNode::create("cmplx3", b, --e);

	return 0;
}
\end{lstlisting}

\paragraph{Exmaple 3}
This is tutorial is a C++ implementation of the Composite design pattern. This is one of the easier design pattern out there.
Sometimes confused with ``Prefer composition over Inheritance''~\ref{pcoi}. Yes, few people do get confused. In interview.
There is not much to talk about. So I will as usual, jump immediately into the “WHY” followed by the “HOW”.

\paragraph{WHY}
To put it simply, it makes dealing with collections easy.
Ever heard of the saying “Everyone is equal in front of Law”?
Something similar going on here. The client does not care if it is an element or a collection of elements. Both are equal in its eyes.
It will just call one method. And wants to be assured that the stuff just works.
Whether it called the method on the collection of elements or an individual element does not matter here. This makes client code much simpler.

\paragraph{HOW}
What we will do is to make the client talk to an interface as usual. The interface will have some methods.
The interface will be implemented by a single element as well as a collection of elements.
If there are some methods will do not make sense for an element then we will return something like “Not implemented”. And same for the collection too.

The example here will be very simple. The interface called “IComposite” will have two methods, Display and Add.
We will have two classes implement this interface. Class “Single” and “Composite”.
We will have a small class class “Node”. The class “Single” will have only one object of kind “Node”. And class “Composite” will have a collection of “Node” objects in it.
Note that since class “Single” is supposed to contain only single object of type “Node”, the Add method in it will return “Not Implemented”.

\begin{lstlisting}[caption={Composite Pattern - sample 3}, language=c++]
#include<iostream>
#include<vector>
using namespace std;

class node
{
public:
	node(int x) :val(x){}
	int value() const { return val; }
private:
	int val;
};

class IComposite
{
public:
	virtual void Display(void) const = 0;
	virtual void Add(node* elem){}
};

class Single : public IComposite
{
public:
	Single(node* x) :elem(x){}
	void Display(void) const { cout << elem->value() << "\n"; }
	void Add(node* elem) { cout << "Not implemented\n"; }
	~Single() { delete elem; }
private:
	node* elem;
};

class Composite : public IComposite
{
public:
	void Display(void) const
	{
		for (vector<node*>::const_iterator iter = elems.begin(); iter != elems.end(); ++iter)
		{
			cout << (*iter)->value() << "\n";
		}
		cout << "\n";
	}

	void Add(node* elem) { elems.push_back(elem); }

	~Composite()
	{
		for (vector<node*>::const_iterator iter = elems.begin(); iter != elems.end(); ++iter)
		{
			delete *iter;
		}
	}
private:
	vector<node*> elems;
};

int main()
{
	node* a = new node(5);
	node* b = new node(6);
	node* c = new node(7);
	IComposite* clientSingle = new Single(a);
	clientSingle->Display();
	clientSingle->Add(b);
	cout << "\n";
	IComposite* clientComposite = new Composite();
	clientComposite->Add(b);
	clientComposite->Display();
	clientComposite->Add(c);
	clientComposite->Display();
	return 1;
}
\end{lstlisting}
And the output is:
\begin{verbatim}
5
Not implemented

6

6
7
\end{verbatim}

\chapter{Adapter Pattern}\label{AdapterPattern}
\paragraph{Intent}
Convert the interface of a class into another interface clients expect.
Adapter (or Wrapper) lets classes work together that couldn't otherwise because of incompatible interfaces.
Adapter pattern's motivation is that we can reuse existing software if we can modify the interface.
This pattern contains ``class adapter'' and ``object adapter''.
\paragraph{Exmaple}
Consider that you have some pictures in your memory card and you need to transfer them to your computer.
In order to transfer them you need some kind of adapter that is compatible with your computer ports so that you can attach memory card to your computer.
In this case card reader is an adapter.
Another example would be the power adapter: a three legged plug can't be connected to a two pronged outlet, it needs to use a power adapter that makes it compatible with the two pronged outlet.
Yet another example would be a translator translating words spoken by one person to another.
\textbf{Adapter pattern} lets you wrap an otherwise incompatible object in an adapter to make it compatible with another class.
\textbf{Wikipedia says}
In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface.
It is often used to make existing classes work with others without modifying their source code.
\section{Class Adapter}\label{AdapterPatternClass}

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/adapter1.PNG}}{\caption{Class Adapter Pattern}\label{classadapterp}}
\end{floatrow}
\end{figure}

Adaptee class does not have Request method,but client expects it.
in order to use Adaptee class by client, then Adapter class is requred,Adapter class implement Target interface, and inherit from Adaptee,
Adapter class Request method wrappers Adaptee's SpecificRequest method to satisfy the goal - Adapter.

Since Adapter inherits from Adaptee, which decides the class relationship.

Target: interface that client needs.

Adaptee: the class needs to be adapted

Adapter: convert Adaptee to Target.

\begin{lstlisting}[caption={Adapter Pattern - Diagram sample 1}, language=c++]
#include<iostream>  
using namespace std;  
  
class Target  // "ITarget"  
{  
public:  
    virtual void Request(){};  
};  
  
class Adaptee  
{  
public:  
    void SpecificRequest()  {  cout<<"Called SpecificRequest()"<<endl;  }  
};  
  
class Adapter : public Adaptee, public Target  
{  
public:  
    void Request()  // Implements ITarget interface  
    {  
        // Possibly do some data manipulation and then call SpecificRequest    
        this->SpecificRequest();  
    }  
};  
  
int main()  
{  
    // Create adapter and place a request  
    Target *t = new Adapter();  
    t->Request();  
  
    return 0;  
}  
\end{lstlisting}

\paragraph{A class adapter uses multiple inheritance to adapt one interface to another.}\mbox{}
1.    Adapter pattern relies on object composition.

2.    Client calls operation on Adapter object.

3.    Adapter calls Adaptee to carry out the operation.

4.    In STL, stack adapted from vector: When stack executes push(), underlying vector does vector::push\_back().
\begin{lstlisting}[caption={Adapter Pattern - sample 1}, language=c++]
#include <iostream>

// Desired interface (Target)
class Rectangle 
{
  public:
    virtual void draw() = 0;
};

// Legacy component (Adaptee)
class LegacyRectangle 
{
  public:
    LegacyRectangle(int x1, int y1, int x2, int y2) {
        x1_ = x1;
        y1_ = y1;
        x2_ = x2;
        y2_ = y2;
        std::cout << "LegacyRectangle(x1,y1,x2,y2)\n";
    }
    void oldDraw() {
        std::cout << "LegacyRectangle:  oldDraw(). \n";
    }
  private:
    int x1_;
    int y1_;
    int x2_;
    int y2_;
};

// Adapter wrapper
class RectangleAdapter: public Rectangle, private LegacyRectangle 
{
  public:
    RectangleAdapter(int x, int y, int w, int h): LegacyRectangle(x, y, x + w, y + h) {
         std::cout << "RectangleAdapter(x,y,x+w,x+h)\n";
      }
    
    void draw() {
        std::cout << "RectangleAdapter: draw().\n"; 
        oldDraw();
    }
};

int main()
{
  int x = 20, y = 50, w = 300, h = 200;
  Rectangle *r = new RectangleAdapter(x,y,w,h);
  r->draw();
}
\end{lstlisting}

Output from the run:
\begin{verbatim}
LegacyRectangle(x1,y1,x2,y2)
RectangleAdapter(x,y,x+w,x+h)
\end{verbatim}

\paragraph{Summary of the code:}

    The client thinks he is talking to a Rectangle
    The target is the Rectangle class. This is what the client invokes method on.

\begin{verbatim}
      Rectangle *r = new RectangleAdapter(x,y,w,h);
      r->draw();
\end{verbatim}
    Note that the adapter class uses multiple inheritance.

\begin{verbatim}
    class RectangleAdapter: public Rectangle, private LegacyRectangle {
    ...
    }
\end{verbatim}
    The Adapter RectangleAdapter lets the LegacyRectangle responds to request (draw() on a Rectangle) by inheriting BOTH classes.
    The LegacyRectangle class does not have the same methods (draw()) as Rectangle,
    but the Adapter(RectangleAdapter) can take the Rectangle method calls and turn around and invoke method on the LegacyRectangle, oldDraw()

\begin{verbatim}
    class RectangleAdapter: public Rectangle, private LegacyRectangle {
      public:
        RectangleAdapter(int x, int y, int w, int h):
          LegacyRectangle(x, y, x + w, y + h) {
    		std::cout << "RectangleAdapter(x,y,x+w,x+h)\n";
    	  }
        
        void draw() {
            std::cout << "RectangleAdapter: draw().\n"; 
            oldDraw();
        }
    };
\end{verbatim}

Adapter design pattern translates the interface for one class into a compatible but different interface.
So, this is similar to the proxy pattern~\ref{ProxyPattern} in that it's a single$-$component wrapper. But the interface for the adapter class and the original class may be different.

As we've seen in the example above, this adapter pattern is useful to expose a different interface for an existing API to allow it to work with other code.
Also, by using adapter pattern, we can take heterogeneous interfaces, and transform them to provide consistent API.

Bridge pattern~\ref{BridgePattern} has a structure similar to an object adapter, but Bridge has a different intent:
It is meant to separate an interface from its implementation so that they can be varied easily and independently.
An adapter is meant to change the interface of an existing object.

\paragraph{Exmaple 2}

\begin{lstlisting}[caption={Bridge Pattern sample code 2},label={lst:bridgepsc2},language=C++]
class Deque //Adapter 
{  
    public:  
        void push_back(int x) { cout<<"Deque push_back"<<endl; }  
        void push_front(int x) { cout<<"Deque push_front"<<endl; }  
        void pop_back() { cout<<"Deque pop_back"<<endl; }  
        void pop_front() { cout<<"Deque pop_front"<<endl; }  
};  

class Sequence  
{  
    public:  
        virtual void push(int x) = 0;  
        virtual void pop() = 0;  
};  

class Stack: public Sequence  
{  
    public:  
        void push(int x) { deque.push_back(x); }  
        void pop() { deque.pop_back(); }  
    private:  
        Deque deque;
};  

class Queue: public Sequence  
{  
    public:  
        void push(int x) { deque.push_back(x); }  
        void pop() { deque.pop_front(); }  
    private:  
        Deque deque;
};  


    int main()  
    {  
        Sequence *s1 = new Stack();  
        Sequence *s2 = new Queue();  
        s1->push(1); s1->pop();  
        s2->push(1); s2->pop();  
        delete s1; delete s2;  
        return 0;  
    }  
\end{lstlisting}

\paragraph{example 3}
Assume you bought a laptop with a 3$-$prong plug but the you don't have a 3-phrase outlet but one 2$-$phrase outlet.
so you want an Adapter converting 3$-$prong plug (Adaptee) to 2$-$prong to use the 2$-$phrase outlet.

\begin{lstlisting}
    class ThreePhaseOutlet  
    {  
    public:  
        void doThreePhasePlugin()  
        {  
            cout<<"plugin 3 prong plug!"<<endl;  
        }  
    };  
    
    class TwoPhaseOutlet   
    {  
    public:  
        virtual void doPlugin() = 0;  
    };  

    class OutletConvertor: public TwoPhaseOutlet,public ThreePhaseOutlet  
    {  
    public:  
        void doPlugin()  
        {  
            doConvertor();  
            doThreePhasePlugin();  
        }     
            void doConvertor()  
        {  
            cout<<"convert 3 prong plug to 2 prong plug"<<endl;  
        }  
    };  

    main() 
    {
        TwoPhaseOutlet* outlet = new OutletConvertor();  
        outlet->doPlugin(); 
    }
\end{lstlisting}

\section{Object Adapter}\label{AdapterPatternObject}

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/adapter2.PNG}}{\caption{Object Adapter Pattern}\label{objectadapterp}}
\end{floatrow}
\end{figure}
client needs to call Request method, but Adaptee does not have it, so Adapter class is required.
this Wrapper (Adapter) wrappers a Adaptee instance to connect to Client from Adaptee. Since Adapter delegates Adaptee so it is object Adapter Pattern.

\begin{lstlisting}[caption={Adapter Pattern - diagram example code}, language=C++]
#include<iostream>  
using namespace std;  
  
class Target  // "ITarget"  
{  
public:  
    virtual void Request(){};  
};  
  
class Adaptee  
{  
public:  
    void SpecificRequest()  {  cout<<"Called SpecificRequest()"<<endl;  }  
};  
  
class Adapter : public Target  
{  
private:  
    Adaptee *adaptee;  
  
public:  
    Adapter()  
    {  
        adaptee = new Adaptee();  
    }  
  
    // Implements ITarget interface  
    void Request()  
    {  
        // Possibly do some data manipulation and then call SpecificRequest    
        adaptee->SpecificRequest();  
    }  
};  
  
  
int main()  
{  
    // Create adapter and place a request  
    Target *t = new Adapter();  
    t->Request();  
  
    return 0;  
}  
\end{lstlisting}

\begin{lstlisting}
class OutletConvertor : public TwoPhaseOutlet  
{  
public:  
    OutletConvertor(ThreePhaseOutlet out)  
    {  
        m_out = out;  
    }  
    void doPlugin()  
    {  
        doConvertor();  
        m_out.doThreePhasePlugin();  
    }  
    void doConvertor()  
    {  
        cout<<"convert 3-prong plug to 2-prong plug!"<<endl;  
    }  
    ThreePhaseOutlet m_out;  
};  
\end{lstlisting}

\section{Default Adapter}\label{AdapterPatternDefault}
This is a specific Adapter Pattern, which is implemented by virtual class and it implements (empty) all methods inside of Target. all concrete subclasses need to inherit from this virtual class.
\begin{lstlisting}

    #include<iostream>  
    using namespace std;  
      
      
    class Target {   
    public:  
        virtual void f1(){};   
        virtual void f2(){};   
        virtual void f3(){};     
    };  
      
    class DefaultAdapter : public Target   
    {   
    public:  
        void f1() {   }   
        void f2() {   }   
        void f3() {   }   
    };  
      
    class MyInteresting :public DefaultAdapter  
    {   
    public:  
         void f3(){ cout<<"I only am interested in the function 3rd!"<<endl;  }   
    };  
      
    int main()  
    {  
        // Create adapter and place a request  
        Target *t = new MyInteresting();  
        t->f3();  
      
        return 0;  
    }  

\end{lstlisting}

\section{More examples}
\paragraph{WHY}
In one word : Legacy.
Adapter design pattern is the answer to the question “So what do you do with good ol’ boys like me?“.
It allows you to use the old(read already implemented and working) software which is doing something similar to what you want. Just that the times (read interfaces) changed.

\paragraph{HOW}
It is very simple. Get hold of the snazzy new interface which the client wants to use. Implement the interface via the Adapter class.
Take the legacy class. Call the legacy class methods inside the adapter class methods.

\paragraph{Time for some code}
Let us suppose we have an old player which plays songs.
It has a method called OldPlay which takes the volume at which the song has to be played as a parameter.
The new interface which we have has a play method too. But that method does not take the volume as a parameter. So lets put Adapter design pattern in action.
\begin{lstlisting}
#include<iostream>
#include<string>

using namespace std;

class IPlayer //Client wants to use this.
{
public:
	virtual void Play() = 0;	//This is function client wants to use
};

class OldPlayer	//What we have
{
public:
	OldPlayer(string song) :_song(song){}

	void OldPlay(int volume)	//This is function we got 
	{
		cout << "\nPlaying song : " << _song << " at volume :" << volume << "\n";
	}
private:
	string _song;
};

class Adapter : public IPlayer, private OldPlayer
{
public:
	Adapter(string song, int volume) :_volume(volume), OldPlayer(song){}

	void Play()		//Comes from public inheritance
	{
		OldPlay(_volume);	//Comes from private inheritance
	}
private:
	int _volume;
};

int main()
{
	IPlayer* newStuffDad = new Adapter("Good Ole Boy Like Me", 50);
	newStuffDad->Play();	//The call to the interface function is routed by the adapter to the LegacyCode.
	cout << "\n";
        delete newStuffDad;
	return 1;
}
\end{lstlisting}

\begin{verbatim}
output:
Playing song : Good Ole Boy Like Me at volume :50
\end{verbatim}

%\bcquestion{\textbf{...}} \\
%\phantom{0.5ex}1.1 If the answer is negative, should ERL or Renesas implement the function ?\\

\chapter{Flyweight Pattern}\label{FlyweightPattern}
\paragraph{Discussion}
The Flyweight pattern describes how to share objects to allow their use at fine granularity without prohibitive cost.
Each "flyweight" object is divided into two pieces: the state-dependent (extrinsic) part, and the state-independent (intrinsic) part.
Intrinsic state is stored (shared) in the Flyweight object.
Extrinsic state is stored or computed by client objects, and passed to the Flyweight when its operations are invoked.
\paragraph{Structure}
Flyweights are stored in a Factory's repository.
The client restrains herself from creating Flyweights directly, and requests them from the Factory.
Each Flyweight cannot stand on its own. Any attributes that would make sharing impossible must be supplied by the client whenever a request is made of the Flyweight.
If the context lends itself to "economy of scale" (i.e. the client can easily compute or look-up the necessary attributes), then the Flyweight pattern offers appropriate leverage.

\paragraph{exmaple}

Discussion. Flyweight describes how to share objects, so that their use at fine granularity is not cost prohibitive.
A key concept is the distinction between "intrinsic" and "extrinsic" state.
Intrinsic state consists of information that is independent of the flyweight's context - information that is sharable (i.e. each Icon's name, width, and height).

It is stored in the flyweight (i.e. the Icon class).
Extrinsic state cannot be shared, it depends on and varies with the Flyweight's context (i.e. the x,y position that each Icon instance's upper left corner will be drawn at).
Extrinsic state is stored or computed by the client and is passed to the flyweight when an operation is invoked.
Clients should not instantiate Flyweights directly, they should obtain them exclusively from a FlyweightFactory object to ensure they are shared properly.

\begin{lstlisting}[caption={Flyweight Pattern sample 1},language=C++]
#include <iostream.h>
#include <string.h>

class Icon
{
  public:
    Icon(char *fileName)
    {
        strcpy(_name, fileName);

        if (!strcmp(fileName, "go"))
        {
            _width = 20;
            _height = 20;
        }
        if (!strcmp(fileName, "stop"))
        {
            _width = 40;
            _height = 40;
        }
        if (!strcmp(fileName, "select"))
        {
            _width = 60;
            _height = 60;
        }
        if (!strcmp(fileName, "undo"))
        {
            _width = 30;
            _height = 30;
        }
    }
    const char *getName() { return _name; }
    draw(int x, int y)
    {
        cout<<"   drawing " <<_name<<": upper left (" <<x<<","<<y<< 
          ") - lower right (" << x + _width << "," << y + _height << ")" <<
          endl;
    }
  private:
    char _name[20];
    int _width;
    int _height;
};

class FlyweightFactory
{
  public:
    static Icon *getIcon(char *name)
    {
        for (int i = 0; i < _numIcons; i++)
          if (!strcmp(name, _icons[i]->getName()))
            return _icons[i];
        _icons[_numIcons] = new Icon(name);
        return _icons[_numIcons++];
    }
    static void reportTheIcons()
    {
        cout << "Active Flyweights: ";
        for (int i = 0; i < _numIcons; i++)
          cout << _icons[i]->getName() << " ";
        cout << endl;
    }
  private:
    enum { MAX_ICONS = 5 };
    static int _numIcons;
    static Icon *_icons[MAX_ICONS];
};

int FlyweightFactory::_numIcons = 0;

Icon *FlyweightFactory::_icons[];

class DialogBox
{
  public:
    DialogBox(int x, int y, int incr): _iconsOriginX(x), _iconsOriginY(y), _iconsXIncrement(incr){}
    virtual void draw() = 0;
  protected:
    Icon *_icons[3];
    int _iconsOriginX;
    int _iconsOriginY;
    int _iconsXIncrement;
};

class FileSelection: public DialogBox
{
  public:
    FileSelection(Icon *first, Icon *second, Icon *third): DialogBox(100, 100, 100)
    {
        _icons[0] = first;
        _icons[1] = second;
        _icons[2] = third;
    }
    void draw()
    {
        cout << "drawing FileSelection:" << endl;
        for (int i = 0; i < 3; i++)
          _icons[i]->draw(_iconsOriginX + (i *_iconsXIncrement), _iconsOriginY);
    }
};

class CommitTransaction: public DialogBox
{
  public:
    CommitTransaction(Icon *first, Icon *second, Icon *third): DialogBox(150, 150, 150)
    {
        _icons[0] = first;
        _icons[1] = second;
        _icons[2] = third;
    }
    void draw()
    {
        cout << "drawing CommitTransaction:" << endl;
        for (int i = 0; i < 3; i++)
          _icons[i]->draw(_iconsOriginX + (i *_iconsXIncrement), _iconsOriginY);
    }
};

int main()
{
  DialogBox *dialogs[2];

  dialogs[0] = new FileSelection(FlyweightFactory::getIcon("go"),
    FlyweightFactory::getIcon("stop"), FlyweightFactory::getIcon("select"));

  dialogs[1] = new CommitTransaction(FlyweightFactory::getIcon("select"),
    FlyweightFactory::getIcon("stop"), FlyweightFactory::getIcon("undo"));

  for (int i = 0; i < 2; i++)
    dialogs[i]->draw();

  FlyweightFactory::reportTheIcons();
}
\end{lstlisting}
Output
\begin{verbatim}
drawing FileSelection:
   drawing go: upper left (100,100) - lower right (120,120)
   drawing stop: upper left (200,100) - lower right (240,140)
   drawing select: upper left (300,100) - lower right (360,160)
drawing CommitTransaction:
   drawing select: upper left (150,150) - lower right (210,210)
   drawing stop: upper left (300,150) - lower right (340,190)
   drawing undo: upper left (450,150) - lower right (480,180)
Active Flyweights: go stop select undo 
\end{verbatim}

\paragraph{Exmaple 2}

The pattern for saving memory (basically) by sharing properties of objects.
Imagine a huge number of similar objects which all have most of their properties the same.
It is natural to move these properties out of these objects to some external data structure and provide each object with the link to that data structure.

\begin{lstlisting}[caption={Flyweight Pattern sample 2},language=C++]
#include <iostream>
#include <string>
#include <vector>

#define NUMBER_OF_SAME_TYPE_CHARS 3;

/* Actual flyweight objects class (declaration) */
class FlyweightCharacter;

/*
	FlyweightCharacterAbstractBuilder is a class holding the properties which are shared by
	many objects. So instead of keeping these properties in those objects we keep them externally, making
	objects flyweight. See more details in the comments of main function.
*/
class FlyweightCharacterAbstractBuilder {
	FlyweightCharacterAbstractBuilder() {}
	~FlyweightCharacterAbstractBuilder() {}
public:
	static std::vector<float> fontSizes; // lets imagine that sizes may be of floating point type
	static std::vector<std::string> fontNames; // font name may be of variable length (lets take 6 bytes is average)

	static void setFontsAndNames();
	static FlyweightCharacter createFlyweightCharacter
        (unsigned short fontSizeIndex,
		unsigned short fontNameIndex,
		unsigned short positionInStream);
};

std::vector<float> FlyweightCharacterAbstractBuilder::fontSizes(3);
std::vector<std::string> FlyweightCharacterAbstractBuilder::fontNames(3);

void FlyweightCharacterAbstractBuilder::setFontsAndNames() {
	fontSizes[0] = 1.0;
	fontSizes[1] = 1.5;
	fontSizes[2] = 2.0;

	fontNames[0] = "first_font";
	fontNames[1] = "second_font";
	fontNames[2] = "third_font";
}

class FlyweightCharacter {
	unsigned short fontSizeIndex; // index instead of actual font size
	unsigned short fontNameIndex; // index instead of font name

	unsigned positionInStream;

public:

	FlyweightCharacter(unsigned short fontSizeIndex, unsigned short fontNameIndex, unsigned short positionInStream):
		fontSizeIndex(fontSizeIndex), fontNameIndex(fontNameIndex), positionInStream(positionInStream) {}
	void print() {
		std::cout << "Font Size: " << FlyweightCharacterAbstractBuilder::fontSizes[fontSizeIndex]
			<< ", font Name: " << FlyweightCharacterAbstractBuilder::fontNames[fontNameIndex]
			<< ", character stream position: " << positionInStream << std::endl;
	}
	~FlyweightCharacter() {}
};

FlyweightCharacter FlyweightCharacterAbstractBuilder::createFlyweightCharacter(
                unsigned short fontSizeIndex,
                unsigned short fontNameIndex, 
                unsigned short positionInStream) {
	FlyweightCharacter fc(fontSizeIndex, fontNameIndex, positionInStream);

	return fc;
}

int main(int argc, char** argv) {
	std::vector<FlyweightCharacter> chars;

	FlyweightCharacterAbstractBuilder::setFontsAndNames();
	unsigned short limit = NUMBER_OF_SAME_TYPE_CHARS;

	for (unsigned short i = 0; i < limit; i++) {
		chars.push_back(FlyweightCharacterAbstractBuilder::createFlyweightCharacter(0, 0, i));
		chars.push_back(FlyweightCharacterAbstractBuilder::createFlyweightCharacter(1, 1, i + 1 * limit));
		chars.push_back(FlyweightCharacterAbstractBuilder::createFlyweightCharacter(2, 2, i + 2 * limit));
	}
	/*
		Each char stores links to its fontName and fontSize so what we get is:

		each object instead of allocating 6 bytes (convention above) for string
		and 4 bytes for float allocates 2 bytes for fontNameIndex and fontSizeIndex.

		That means for each char we save 6 + 4 - 2 - 2 = 6 bytes.
		Now imagine we have NUMBER_OF_SAME_TYPE_CHARS = 1000 i.e. with our code
		we will have 3 groups of chars with 1000 chars in each group which will save 
		3 * 1000 * 6 - (3 * 6 + 3 * 4) = 17970 saved bytes.

		3 * 6 + 3 * 4 is a number of bytes allocated by FlyweightCharacterAbstractBuilder.

		So the idea of the pattern is to move properties shared by many objects to some
		external container. The objects in that case don't store the data themselves they
		store only links to the data which saves memory and make the objects lighter.
		The data size of properties stored externally may be significant which will save REALLY
		huge amount of memory and will make each object super light in comparison to its counterpart.
		That's where the name of the pattern comes from: flyweight (i.e. very light).
	*/
	for (unsigned short i = 0; i < chars.size(); i++) {
		chars[i].print();
	}

	std::cin.get(); return 0;
}
\end{lstlisting}


\subpart{More Patterns}
\chapter{Private Implementation (PImpl) pattern}\label{pimplpattern}
\url{https://www.robertlarsononline.com/2017/01/12/private-implementation-pattern-using-c/}

\paragraph{PImpl}
The Private Implementation Design Pattern (PImpl) is a nice way to hide the internals of a class from other classes that would depend on it otherwise. 
The advantage of doing so is that it simplifies the header dependency tree which will result in faster build times. 
For larger systems and/or slow build servers, this may be very desirable. Let’s take a look at the pattern as implemented in C++. 
We will use our favorite object name Foo to be the class other classes would depend on. 
We want to limit those dependencies so we provide a private implementation of Foo called FooImpl, which Foo contains as a member. 
The attributes and behavior are encapsulated to the FooImpl class. You will see there are two data structures members in FooImpl. 
Without using the Private Implementation pattern, classes using Foo would have been dependent on the two header files for those data structures. 
Hope this helps anyone interested in the topic. Feedback is always appreciated! Code on!

In Foo.h

\begin{lstlisting}
// Forward declare your private implementation class 
// instead of including a header as that would defeat
// the point of the private implementation pattern
// of limiting header dependencies.

class FooImpl;

class Foo
{
  public:
    Foo();
    ~Foo();
    void doSomething();

  private:
    FooImpl * m_pImpl;
}
\end{lstlisting}
In Foo.cc

\begin{lstlisting}
#include "Foo.h"
#include "FooImpl.h"

Foo::Foo()
  : m_pImpl(new FooImpl()) { }

Foo::~Foo() { }

// delegate doing something to the private implementation object.
Foo::doSomething()
{
   return m_pImpl->doSomething(); 
}
\end{lstlisting}

In FooImpl.h

\begin{lstlisting}
#include "SomeDataStructure.h"
#include "SomeOtherDataStructure.h"

class FooImpl
{
   public:
      FooImpl();
      ~FooImpl();

      void doSomething();

   private:

      SomeDataStructure m_someDataStructure;
      SomeOtherDataStructure m_someOtherDataStructure;
};
\end{lstlisting}

In FooImpl.cc

\begin{lstlisting}
#include "FooImpl.h"

FooImpl::FooImpl() { }

FooImpl::~FooImpl() { }

FooImpl::doSomething()
{
    m_someDataStructure.doWork();
    m_someOtherDataStructure.doWork();
}
\end{lstlisting}

\paragraph{the second example}
\url{https://www.bfilipek.com/2018/01/pimpl.html}
\subparagraph{Intro}

A lot has been written about the pimpl pattern. Starting from some old posts by Herb Sutter: GotW \#24: Compilation Firewalls and GotW \#7b Solution: Minimizing Compile-Time Dependencies.
To some recent ones: GotW \#100: Compilation Firewalls and GotW \#101: Compilation Firewalls, Part 2 and even a few months ago from Fluent C++ How to implement the pimpl idiom by using unique\_ptr. 
Plus of course tons of other great articles…

So why would I like to write again about pimpl?

First of all, I’d like to make a summary of the essential facts. The pattern is used to break dependencies - both physical and logical of the code.
The basics sound simple, but as usual, there’s more to the story.

There’s also an important question: should we all use pimpl today? Maybe there are better alternatives?

Let’s start with a simple example to set the background:
\subparagraph{The basics}

Pimpl might appear with different names: d-pointer, compiler firewall or even Cheshire Cat pattern or Opaque pointer.

In its basic form the pattern looks as follows:

    In a class we move all private members to a newly declared type - like PrivateImpl class
    it’s only forward declared in the header file of the main class
    in the corresponding cpp file we declare the PrivateImpl class and define it.
    now, if you change the private implementation, the client code won't have to be recompiled (as the interface hasn't changed).

So it might look like that (crude, old style code!):
\begin{lstlisting}
// class.h
class MyClassImpl;
class MyClass {
 public:
    MyClass(){}
    ~MyClass(){}
    void Foo();
 private:    
    MyClassImpl* m_pImpl; // warning!!!  a raw pointer! :)
};

// class.cpp
class MyClassImpl
{
public:
    void DoStuff() { /*...*/ }
};

MyClass::MyClass () 
: m_pImpl(new MyClassImpl()) 
{ }

MyClass::~MyClass () { delete m_pImpl; }

void MyClass ::Foo() {
    m_pImpl->DoSth();
}
\end{lstlisting}

Ech… ugly raw pointers!

So briefly: we pack everything that is private into that forward declared class. 
We use just one member of our main class - the compiler can work with only the pointer without having full type declaration - as only size of the pointer is needed. 
Then the whole private declaration \& implementation happens in the .cpp file.

Of course in modern C++ it’s also advised to use unique\_ptr rather than raw pointers.

The two obvious downsides of this approach: we need a separate memory allocation to store the private section. And also the main class just forwards the method calls to the private implementation.

Ok… but it’s all… right? Not so easy!

The above code might work, but we have to add a few bits to make it work in real life.
\subparagraph{More code}

We have to ask a few questions before we can write the full code:

    is your class copyable or only movable?
    how to enforce const for methods in that private implementation?
    do you need a “backward” pointer - so that the impl class can call/reference members of the main class?
    what should be put in that private implementation? everything that’s private?

The first part - copyable/movable relates to the fact that with the simple - raw - pointer we can only shallow copy an object. Of course, this happens in every case you have a pointer in your class.

So, for sure we have to implement copy constructor (or delete it if we want only movable type).

What about that const problem? Can you catch it in the basic example?

If you declare a method const then you cannot change members of the object. In other words, they become const. But it’s a problem for our m\_pImpl which is a pointer. 
In a const method this pointer will also become const which means we cannot assign a different value to it… but… we can happily call all methods of this underlying private class (not only constant)!.

So what we need is a conversion/wrapper mechanism. Something like this:

\begin{lstlisting}
const MyClassImpl* Pimpl() const { return m_pImpl; }
MyClassImpl* Pimpl() { return m_pImpl; }
\end{lstlisting}

And now, in all of our methods of the main class, we should be using that function wrapper, not the pointer itself.

Still, such rule - remembering to use this wrapper accessor - might be hard to follow and keep consistent. If you want to read more about const propagation read my post: How to propagate const on a member pointer?

So far, I didn’t mention that “backward” pointer (“q-pointer” in QT terminology). The answer is connected to the last point - what should we put in the private implementation - only private fields? Or maybe even private functions?

The basic code won’t show those practical problems. But In a real application, a class might contain a lot of methods and fields. I’ve seen examples where all of the private section (with methods) go to the pimpl class. Still, sometimes the pimpl class need to call a ‘real’ method of the main class, so we need to provide that “back” pointer. This can be done at construction, just pass the pointer to this.
The improved version

So here’s an improved version of our example code:

\begin{lstlisting}
// class.h
class MyClassImpl;
class MyClass
{
public:
    explicit MyClass();
    ~MyClass(); 

    // movable:
    MyClass(MyClass && rhs) noexcept;   
    MyClass& operator=(MyClass && rhs) noexcept;

    // and copyable
    MyClass(const MyClass& rhs);
    MyClass& operator=(const MyClass& rhs);

    void DoSth();
    void DoConst() const;

private:
    const MyClassImpl* Pimpl() const { return m_pImpl.get(); }
    MyClassImpl* Pimpl() { return m_pImpl.get(); }

    std::unique_ptr<MyClassImpl> m_pImpl;
};

// class.cpp
class MyClassImpl
{
public:
    ~MyClassImpl() = default;

    void DoSth() { }
    void DoConst() const { }
};

MyClass::MyClass() : m_pImpl(new MyClassImpl()) 
{

}

MyClass::~MyClass() = default;
MyClass::MyClass(MyClass &&) noexcept = default;
MyClass& MyClass::operator=(MyClass &&) noexcept = default;

MyClass::MyClass(const MyClass& rhs)
    : m_pImpl(new MyClassImpl(*rhs.m_pImpl))
{}

MyClass& MyClass::operator=(const MyClass& rhs) {
    if (this != &rhs) 
        m_pImpl.reset(new MyClassImpl(*rhs.m_pImpl));

    return *this;
}

void MyClass::DoSth()
{
    Pimpl()->DoSth();
}

void MyClass::DoConst() const
{
    Pimpl()->DoConst();
}
\end{lstlisting}

A bit better now.

The above code uses

    unique\_ptr - but see that the destructor for the main class must be defined in the cpp file. Otherwise, the compiler will complain about missing deleter type…
    The class is movable and copyable, so four methods were defined
    To be safe with const methods all of the proxy methods of the main class uses Pimpl() method to fetch the proper type of the pointer.

Have a look at this blog Pimp My Pimpl — Reloaded by Marc Mutz for a lot of information about pimpl.

You can play with the full example, live, here (it also contains some more nice stuff to explore)
...

\chapter{Private class data Pattern}\label{PrivateClassDataPattern}
\paragraph{Intent}
The private class data design pattern is one of Structural pattern~\ref{StructuralPattern} which seeks to reduce exposure of attributes by limiting their visibility.
It reduces the number of class attributes by encapsulating them in single Data object.
It allows the class designer to remove write privilege of attributes that are intended to be set only during construction, even from methods of the target class.
\paragraph{Implementation}

The private class data design pattern solves the problems above by extracting a data class for the target class and giving the target class instance an instance of the extracted data class.

    The data class exposes each attribute (variable or property) through a getter.

    The data class exposes each attribute that must change after construction through a setter.

\chapter{Null Object Pattern}\label{NullObjectPattern}
\paragraph{Intent}
    Provide an object as a surrogate for the lack of an object of a given type.

    The Null Object Pattern provides intelligent do nothing behavior, hiding the details from its collaborators.

\paragraph{Wikipedia says,} In object-oriented computer programming, a null object is an object with no referenced value or with defined neutral ("null") behavior.
The null object design pattern describes the uses of such objects and their behavior (or lack thereof).

 most object-oriented languages, such as Java or C\#, references may be null.
 These references need to be checked to ensure they are not null before invoking any methods, because methods typically cannot be invoked on null references.

Instead of using a null reference to convey absence of an object (for instance, a non-existent customer), one uses an object which implements the expected interface, but whose method body is empty.
The advantage of this approach over a working default implementation is that a null object is very predictable and has no side effects: it does nothing.

For example, a function may retrieve a list of files in a folder and perform some action on each.
In the case of an empty folder, one response may be to throw an exception or return a null reference rather than a list.
Thus, the code which expects a list must verify that it in fact has one before continuing, which can complicate the design.

By returning a null object (i.e. an empty list) instead, there is no need to verify that the return value is in fact a list.
The calling function may simply iterate the list as normal, effectively doing nothing.
It is, however, still possible to check whether the return value is a null object (an empty list) and react differently if desired.

The null object pattern can also be used to act as a stub for testing, if a certain feature such as a database is not available for testing.
\paragraph{real world examples} 1)  I particularily find it useful when working with the Command Pattern.
Say you build a Server that takes some input, given a specific input a command is executed.
When faulty data is sent to the server I create a Null Object Command instead of null which does nothing when executed. This keeps me from checking for null.
2) It is of immense use in huge data centric application as well.
For e.g. many financial/banking industries there are lots of calculations that happens in bulk mode wherein you read lots of data and some processing happens on that.
It may be millions in numbers.  This pattern comes in very handy (as I have faced situations like this many time).  

Create a null object for the said entity and process everything in bulk.
The null object logs the state and the processing is continued without being interrruped to unwanted null exceptions (note if they happen they are automatically logged :))... 
Though this can be done without using NULL Object pattern, but you can imagine the no. of not null check that you need to make for this....
\paragraph{C++ Example} A language with statically typed references to objects illustrates how the null object becomes a more complicated pattern:
\begin{lstlisting}[caption={Null Object Pattern sample code}, language=C++]
class animal 
{
public:
  virtual void make_sound() const = 0;
};

class dog : public animal 
{
  virtual void make_sound() const override 
  { 
      std::cout << "woof!" << std::endl; 
  }
};

class null_animal : public animal 
{
  virtual void make_sound() const override { }
};
\end{lstlisting}

\paragraph{Discussion,} Here, the idea is that there are situations where a pointer or reference to an animal object is required, but there is no appropriate object available.
A null reference is impossible in standard-conforming C++.
A null ``animal *'' pointer is possible, and could be useful as a place-holder, but may not be used for direct dispatch: ``a-$>$make\_sound()'' is undefined behavior if ``a'' is a null pointer.

The null object pattern solves this problem by providing a special ``null\_animal'' class which can be instantiated bound to an animal pointer or reference.

The special null class must be created for \textbf{each} class hierarchy that is to have a null object,
since a null\_animal is of no use when what is needed is a null object with regard to some widget base class that is not related to the animal hierarchy.

Note, that NOT having a null class at all is an important feature,
in contrast to languages where ``anything is a reference'' (e.g. Java and C\#). In C++, the design of a function or method may explicitly state whether null is allowed or not.

\begin{lstlisting}[caption={Null Object Pattern sample code}, language=C++]
// function which requires an animal instance and will not accept null
void do_something( const animal& Inst ) {
  // Inst may never be null here
}

// function which may accept an animal instance or null
void do_something( const animal* pInst ) {
  // pInst may be null
}
\end{lstlisting}

\paragraph{Relation to other patterns} Null Object Pattern is one of the ``behavior patterns''. It can be regarded as a special case of
the State pattern~\ref{StatePattern} and the Strategy pattern~\ref{StrategyPattern}.
It is not a pattern from Design Patterns, but is mentioned in Martin Fowler's Refactoring[3] and Joshua Kerievsky's Refactoring To Patterns[4] as the Insert Null Object refactoring.
\textbf{Null Object and Factory},
The Null Object design pattern is more likely to be used in conjunction with the Factory pattern. The reason for this is obvious: A Concrete Classes need to be instantiated and then to be served to the client. The client uses the concrete class. The concrete class can be a Real Object or a Null Object.
\textbf{Null Object and Template Method},
The Template method design pattern need to define an abstract class that define the template and each concrete class implements the steps for the template. If there are cases when sometimes template is called and sometimes not then, in order to avoid the checking a Null Object can be use to implement a Concrete Template that does nothing.
\textbf{Removing old functionality},
The Null Object can be used to remove old functionality by replacing it with null objects. The big advantage is that the existing code doesn't need to be touched.
\paragraph{Rules of thumb}\mbox{}
%\url{https://sourcemaking.com/design_patterns/null_object}
    The Null Object class is often implemented as a Singleton. Since a null object usually does not have any state, its state can't change, so multiple instances are identical.
    Rather than use multiple identical instances, the system can just use a single instance repeatedly.

    If some clients expect the null object to do nothing one way and some another, multiple NullObject classes will be required.
    If the do nothing behavior must be customized at run time,
    the NullObject class will require pluggable variables so that the client can specify how the null object should do nothing (see the discussion of pluggable adaptors in the Adapter pattern).
    This may generally be a symptom of the AbstractObject not having a well defined (semantic) interface.

    A Null Object does not transform to become a Real Object. If the object may decide to stop providing do nothing behavior and start providing real behavior, it is not a null object.
    It may be a real object with a do nothing mode, such as a controller which can switch in and out of read-only mode.
    If it is a single object which must mutate from a do nothing object to a real one, it should be implemented with the State pattern or perhaps the Proxy pattern.
    In this case a Null State may be used or the proxy may hold a Null Object.

    The use of a null object can be similar to that of a Proxy, but the two patterns have different purposes.
    A proxy provides a level of indirection when accessing a real subject, thus controlling access to the subject.
    A null collaborator does not hide a real object and control access to it, it replaces the real object.
    A proxy may eventually mutate to start acting like a real subject.
    A null object will not mutate to start providing real behavior, it will always provide do nothing behavior.

    A Null Object can be a special case of the Strategy pattern. Strategy specifies several ConcreteStrategy classes as different approaches for accomplishing a task.
    If one of those approaches is to consistently do nothing, that ConcreteStrategy is a NullObject.
    For example, a Controller is a View's Strategy for handling input, and NoController is the Strategy that ignores all input.

    A Null Object can be a special case of the State pattern. Normally, each ConcreteState has some do nothing methods because they're not appropriate for that state.
    In fact, a given method is often implemented to do something useful in most states but to do nothing in at least one state.
    If a particular ConcreteState implements most of its methods to do nothing or at least give null results, it becomes a do nothing state and as such is a null state.

    A Null Object can be used to allow a Visitor to safely visit a hierarchy and handle the null situation.

    Null Object is a concrete collaborator class that acts as the collaborator for a client which needs one.
    The null behavior is not designed to be mixed into an object that needs some do nothing behavior.
    It is designed for a class which delegates to a collaborator all of the behavior that may or may not be do nothing behavior.

\chapter{Dependency Injection}\label{DependencyInjectionPattern}
"Dependency injection is a software design pattern that allows the removal of hard-coded dependencies and makes it possible to change them, whether at run-time or compile-time."
-wiki.
\paragraph{What is dependency?} there are ``logical dependency'' and ``include/compile dependency''. for example,  

    funcA() calls funcB() and funcC(), then funcA() directly depends on funcB() and funcC() functions.

    main() calls funcA(), then main() directly depends on funcA() function and via funcA() indirectly on funcB().

include/compile dependencies means that if b.h includes c.h then b.h directly depends on c.h header.

\paragraph{What is dependency injection (DI) ?}
It allows us to standardize and centralize the way objects are constructed in our application 
by supplying (injecting) an external dependency into a software component
rather than creating an dependency within.
%Here is a brief description from \url{https://docs.angularjs.org/guide/di}. Here is some samples of using it in AngularJS, AngularJS - Dependency Injection.
    There are three ways a component (object or function) can get a hold of its dependencies:

        The component can create the dependency, typically using the new operator.

        The component can look up the dependency, by referring to a global variable.

        The component can have the dependency passed to it where it is needed.

    The first two options of creating or looking up dependencies are not optimal because they hard code the dependency to the component.
    This makes it difficult, if not impossible, to modify the dependencies.
    This is especially problematic in tests, where it is often desirable to provide mock dependencies for test isolation.

    The third option is the most viable, since it removes the responsibility of locating the dependency from the component. The dependency is simply handed to the component.
\paragraph{What types of dependency injection are there?}
%Making a class's dependencies explicit and requiring that they be injected into it is a good way of making a class more reusable, testable and decoupled from others. 
%There are several ways that the dependencies can be injected:
\subparagraph{Setter Injection}
    Adding a setter method that accepts the dependency is one way of injection point into a class.

    Pros:
        Setter injection works well with optional dependencies. If we do not need the dependency, then just do not call the setter.
        We can call the setter multiple times. This is particularly useful if the method adds the dependency to a collection. We can then have a variable number of dependencies.

    Cons:
        The setter can be called more than just at the time of construction so we cannot be sure the dependency is not replaced during the lifetime of the object
        (except by explicitly writing the setter method to check if has already been called).
        We cannot be sure the setter will be called and so we need to add checks that any required dependencies are injected.
    \subparagraph{Constructor Injection (the most popular way of injection)}
    The most common way to inject dependencies is via a class's constructor. To do this, we need to add an argument to the constructor signature to accept the dependency.
    There are several advantages to using constructor injection:

        If the dependency is a requirement and the class cannot work without it then injecting it via the constructor ensures it is present
when the class is used as the class cannot be constructed without it.

        The constructor is only ever called once when the object is created, so we can be sure that the dependency will not change during the object's lifetime.

    These advantages do mean that constructor injection is not suitable for working with optional dependencies.
    It is also more difficult to use in combination with class hierarchies:
    if a class uses constructor injection then extending it and overriding the constructor becomes problematic.
    \subparagraph{Property Injection}
    Just setting public fields of the class directly.
    The disadvantages of using property injection are similar to setter injection but with the following additional important problems:

        We cannot control when the dependency is set at all, it can be changed at any point in the object's lifetime.
We cannot use type hinting so we cannot be sure what dependency is injected except by writing into the class code to explicitly test the class instance before using it.

    But, it is useful to know that this can be done with the service container, especially if we are working with code that is out of our control,
    such as in a third party library, which uses public properties for its dependencies.
\paragraph{Tightly coupled classes}
In the code below, the application (Drawing class) is drawing a specified shape.
\begin{lstlisting}[caption={Dependency Injection example code}, language=C++]
#include <iostream>
#include <string>
using namespace std;

class Shape
{
public:
  virtual void draw() = 0;
};

class Circle : public Shape
{
public:
  void draw() { cout << "circle\n"; }
};

class Triangle : public Shape
{
public:
  void draw() { cout << "triangle\n"; }
};

class Drawing
{
public:
  void drawShape(string s)
  {
    if(s == "triangle")
      pShape = new Triangle;
    else if( s == "circle")
      pShape = new Circle;

    pShape->draw();
  }
private:
    Shape *pShape;
};
\end{lstlisting}
If the drawShape() method is given "triangle" as its parameter, it will draw triangle, if "circle" is given, then it will draw circle. 
However, in software design perspective, the fact that the instantiation is done within the class itself, the Drawing class is tightly coupled with Triangle and Circle classes.

\textbf{Dependency Issue}
According to above example code, What problems does dependency create? 1)   Code is tightly coupled. 2) Difficult to isolate the code to test.
3)    Maintenance cost is high.  If I change code A (i.e., above code), how do I know what else did I break?

Now, we want to modify the previous sample code so that we can break the coupling between Drawing and Triangle/Circle classes.
(DW: plus, after modified the code, it should not affect other code) How?

\begin{lstlisting}[caption={Dependency Injection example code}, language=C++]
#include <iostream>
#include <string>
using namespace std;

class Shape
{
public:
  virtual void draw() = 0;
};

class Circle : public Shape
{
public:
  void draw() { cout << "circle\n"; }
};

class Triangle : public Shape
{
public:
  void draw() { cout << "triangle\n"; }
};

/* 1. This class does not have hard-coded shapes such as Triangle and Circle
      So, it's decoupled and has no dependency
   2. The specific information is injected by other class
   3. This code can be remained untouched when we switch the shape to draw  
*/
class Drawing
{
public:
  void drawShape(Shape *pShape) { pShape->draw(); }
private:
    Shape *pShape;
};

/* 1. This class pulled the hard-coded shape info out of the Drawing class (compare with the previous example)
   2. This class is an interface that can be modified depending on what to draw
   3. This class is doing the dependency injection
*/
class IDrawing
{
public:

  IDrawing() { d = new Drawing; }

  void draw(string s)
  {
    if(s == "triangle")
        d->drawShape(new Triangle);
    else if( s == "circle")
        d->drawShape(new Circle);
    else
        cout << " Need shape";
  }
private:
  Drawing *d;
};
\end{lstlisting}
As we can see from the code, the Drawing class does not have hard-coded shapes anymore. Now, it's decoupled and has no dependency. 
The specific shape information is injected by other interface class (IDrawing) and it does not instantiate anything within the class.
Therefore, this code can be remained untouched even though we switch the shape to draw.

The interface class IDrawing pulled the hard-coded shape info out of the Drawing class. This class as an interface can be modified depending on what to draw, and it is doing the dependency injection.

\paragraph{Pros and Cons of Dependency Injection}

\subparagraph{Pros}
1)      Loosely coupled code
2)     Increase testibility
3)    Can use IoC container~\ref{IOC}
 \subparagraph{Cons}
1)        Increase code complexity
 2)       Hard to understand code, at least initially

\chapter{Model View Controller - MVC}

1.Separation of Model from View components makes it possible to implement several user interfaces that reuse the common core business logic.

2.Duplication of low-level Model code is eliminated across multiple UI implementations.

3.Decoupling of Model and View code results in an improved ability to write unit tests for the core business logic code.

4.Modularity of components allows core logic developers and UI developers to work simultaneously without affecting the other.

Basically, it says that there are three distinct responsibilities for our application. 

    Model

        Manages the app data and state

        Not concerned with UI or presentation

        Often persists somewhere

        Same model should be reusable, unchanged in different interfaces

    View

        Present the Model to the user in an appropriate interface

        Allows user to manipulate data

        Does not store any data except to cache state

        Easily reusable \& configurable to display different data

    Controller
        Intermediary between Model \& View
        Updates the view when the model changes
        Updates the model when the user manipulates the view
        Typically where the app logic lives

This pattern decouples changes to how data are manipulated from how they are displayed or stored, while unifying the code in each component. 
In other words, it's a way of developing apps keeping the data (model) used in the program, and the visual (view) component of the program separate from one another,
each interacting only with a controller containing the logic of our program. 
The view and the model interact only with the controller NEVER with each other.

A triad of three modules linked by the Observer Pattern\label{ObserverPattern}. 
The View drives a presentation and elements within the View observe the Model.
Elements within the Controller observe the View and Model, and elements within the Model observe the Controller.

In a simple application, the Controller can affect changes to the Model based on user input and also communicate those changes to the View so that the UI can be updated.
In real-world applications, however, the View will normally also need to update to reflect additional changes to the underlying Model. 
This is necessary because changing one aspect of the Model may cause it to update other dependent Model state.
This requires Model code to inform the View layer when state changes happen. The Model code, however, cannot statically bind and call the View code. This is where observers come in.

The Observer Pattern is a specific instance of the publish/subscribe paradigm.
These techniques define a one-to-many dependency between objects such that a publisher object can notify all subscribed objects of any state changes without depending on them directly.

MVC is often seen in web applications where the view is the HTML or XHTML generated by the app.
The controller receives GET or POST input and decides what to do with it, handing over to domain objects (i.e., the model) which contain the business rules
and know how to carry out specific tasks such as processing a new subscription,
and which hand control to (X)HTML-generating components such as templating engines, XML pipelines, AJAX callbacks, etc.

The MVC model can be found in UI toolkits such as Nokia's Qt, Apple's Cocoa, Java Swing, and MFC library.

\paragraph{Model View Controller (MVC) Pattern in Android architecture}

Models: Content Providers.
Data Managers that are the recommended form of inter-application data sharing.

Views: Activities.
This is the application's primary user interface component. Every individual screen of an Android application is derived from the Activity Java class (android.app.Activity).
They are containers for Views (android.view.View).

Controllers: Services.
These are background components that behave like UNIX daemons and Windows services. They run invisibly and perform ongoing unattended processing.

\section{Model-View-Controller Explained in C++}
\paragraph{The Model}

The Model is directly responsive for handling data. For example, the Model component accesses MySQL database.
The Model should not rely on other components such as View or Controller.
In other words, the Model does not care how its data can be displayed or when to be updated.

The data changes in the Model will generally be published through some event handlers.
For example, the View model must register on the Model so that it understands the data changes. We can define a function callback when data changes:
\begin{lstlisting}
// common.h
#pragma once
#include <string>
using namespace std;
typedef void (*DataChangeHandler)(string newData);
\end{lstlisting}
DataChangeHandler is now a function pointer type that returns void and takes a parameter of a string (data type). 
The Model is responsible for data retrieval and optionally, it can register the data-change-event.

\begin{lstlisting}
// model.h
#pragma once
#include <string>
using namespace std;
#include "common.h"
// Model is responsible for data get and set
class Model {
    public:
        Model(const string &data) { this->SetData(data); }
        Model() { } // default constructor
        string Data(){ return this->data; }
 
        void SetData(const string &data) {
            this->data = data;
            if (this->event != nullptr) { // data change callback event
                this->event(data);
            }   
        }
        //  register the event when data changes.
        void RegisterDataChangeHandler(DataChangeHandler handler) {
            this->event = handler;
        }
    private:
        string data = "";
        DataChangeHandler event = nullptr;
//The keyword nullptr (since C++11) denotes the pointer literal. It is a prvalue of type std::nullptr\_t.
//There exist implicit conversions from nullptr to null pointer value of any pointer type and any pointer to member type.
//Similar conversions exist for any null pointer constant, which includes values of type std::nullptr\_t as well as the macro NULL. 
};
\end{lstlisting}
\paragraph{View}

The View component knows how to present the Data to the users. It needs to access the Model and normally needs to define its ‘Render()’ function.

\begin{lstlisting}
// view.h
#pragma once
#include <iostream>                  
#include "model.h"                                               
// View is responsible to present data to users
class View {
    public:
        View(const Model &model) { this->model = model; }
        View() {}
        void SetModel(const Model &model) { this->model = model; }
        void Render() { std::cout << "Model Data = " << model.Data() << endl; }
    private:
        Model model;
};
\end{lstlisting}
\paragraph{Controller}

The Controller can ask the Model to update its data.
Also, the Controller can ask the View to change its presentation, e.g. Showing a Dialog instead of Outputing to Console.
Basically it is a component that takes input from the user and sends commands to the View or Model.
	
\begin{lstlisting}
// controller.h
#pragma once
#include "model.h"
#include "view.h"
// Controller combines Model and View
class Controller {
    public:
        Controller(const Model &model, const View &view) {
          this->SetModel(model);
          this->SetView(view);        
        }
        void SetModel(const Model &model) { this->model = model; }
        void SetView(const View &view) { this->view = view; }
        // when application starts
        void OnLoad() { this->view.Render(); }
    private:
        Model model;
        View view;
};
\end{lstlisting}
\paragraph{MVC Demo}

With the above three component classes, we can have the following code to demonstrate MVC.

\begin{lstlisting}
// mvc.cpp
#include <iostream>
#include "view.h"
#include "model.h"
#include "controller.h"
#include "common.h"
 
using namespace std;

void DataChange(string data) { cout << "Data Changes: " << data <<endl; }
 
int main() {
    Model model("Model");
    View view(model);    
    // register the data-change event
    model.RegisterDataChangeHandler(&DataChange);
    // binds model and view.
    Controller controller(model, view);
    // when application starts or button is clicked or form is shown...
    controller.OnLoad();
    model.SetData("Changes"); // this should trigger View to render
    return 0;
}
\end{lstlisting}
To avoid the circular dependency in C++ between class View and Model, we use a function pointer to represent the event of data-change instead of the pointer to a member of object. 
To compile the above code, use the following command:
\begin{Verbatim}
 g++ --std=c++11 mvc.cpp
\end{Verbatim}
Then run ./a.out should give you:

\begin{Verbatim}
Model Data = Model
Data Changes: Changes
\end{Verbatim}
The ``model.SetData(“Changes”);'' triggers the data-change event that is registered in the Model component.

\chapter{Differences among patterns}\label{difampa}

\paragraph{Chain of Responsibility, Command, Mediator, and Observer}

    Chain of Responsibility, Command, Mediator, and Observer, address how you can decouple senders and receivers, but with different trade-offs.
    Chain of Responsibility passes a sender request along a chain of potential receivers.
    Command normally specifies a sender-receiver connection with a subclass.
    Mediator has senders and receivers reference each other indirectly.
    Observer defines a very decoupled interface that allows for multiple receivers to be configured at run-time.

    Mediator and Observer are competing patterns.
    The difference between them is that Observer distributes communication by introducing "observer" and "subject" objects, whereas a Mediator object encapsulates the communication between other objects.
    We've found it easier to make reusable Observers and Subjects than to make reusable Mediators.

    On the other hand, Mediator can leverage Observer for dynamically registering colleagues and communicating with them.

    Mediator is similar to Facade in that it abstracts functionality of existing classes.
    Mediator abstracts/centralizes arbitrary communication between colleague objects, it routinely "adds value",
    and it is known/referenced by the colleague objects (i.e. it defines a multidirectional protocol).
    
    In contrast, Facade defines a simpler interface to a subsystem, it doesn't add new functionality, and it is not known
    by the subsystem classes (i.e. it defines a unidirectional protocol where it makes requests of the subsystem classes but not vice versa).

\paragraph{Proxy, Decorator, Adapter, and Bridge are all variations on "wrapping" a class. But their uses are different.}

    Proxy could be used when you want to lazy-instantiate an object, or hide the fact that you're calling a remote service, or control access to the object.

    Decorator is also called "Smart Proxy." This is used when you want to add functionality to an object, but not by extending that object's type. This allows you to do so at runtime.

    Adapter is used when you have an abstract interface, and you want to map that interface to another object which has similar functional role, but a different interface.

    Bridge is very similar to Adapter, but we call it Bridge when you define both the abstract interface and the underlying implementation.
    I.e., you're not adapting to some legacy or third-party code, you're the designer of all the code but you need to be able to swap out different implementations.

    Facade is a higher-level (read: simpler) interface to a subsystem of one or more classes. Suppose you have a complex concept that requires multiple objects to represent. Making changes to that set of objects is confusing, because you don't always know which object has the method you need to call. That's the time to write a Facade that provides high-level methods for all the complex operations you can do to the collection of objects. Example: a Domain Model for a school section, with methods like countStudents(), reportAttendance(), assignSubstituteTeacher(), and so on.


\paragraph{So are their structures.}

    Proxy and Decorator both have the same interface as their wrapped types, but the proxy creates an instance under the hood, whereas the decorator takes an instance in the constructor.

    Adapter and Facade both have a different interface than what they wrap. But the adapter derives from an existing interface, whereas the facade creates a new interface.

    Bridge and Adapter both point at an existing type. But the bridge will point at an abstract type, and the adapter might point to a concrete type.
    The bridge will allow you to pair the implementation at runtime, whereas the adapter usually won't.


\part{AntiPatterns: Patterns to indentify failure}
\paragraph{What Is an AntiPattern?}\mbox{}
AntiPatterns, like their design pattern counterparts, define an industry vocabulary for the common defective processes and implementations within organizations.
A higher-level vocabulary simplifies communication between software practitioners and enables concise description of higher-level concepts.

An AntiPattern is a literary form that describes a commonly occurring solution to a problem that generates decidedly negative consequences.
The AntiPattern may be the result of a manager or developer not knowing any better, not having sufficient knowledge or experience in solving a particular type of problem,
or having applied a perfectly good pattern in the wrong context.

AntiPatterns provide real-world experience in recognizing recurring problems in the software industry and provide a detailed remedy for the most common predicaments.
AntiPatterns highlight the most common problems that face the software industry and provide the tools to enable you to recognize these problems and to determine their underlying causes.

Furthermore, AntiPatterns present a detailed plan for reversing these underlying causes and implementing productive solutions.
AntiPatterns effectively describe the measures that can be taken at several levels to improve the developing of applications,
the designing of software systems, and the effective management of software projects. 
\subpart{Software Development AntiPatterns}\label{SDA}
A key goal of development AntiPatterns is to describe useful forms of software refactoring.
Software refactoring~\ref{SREF} is a form of code modification, used to improve the software structure in support of subsequent extension and long-term maintenance.
In most cases, the goal is to transform code without impacting correctness.

Good software structure is essential for system extension and maintenance.
Software development is a chaotic activity, therefore the implemented structure of systems tends to stray from the planned structure as determined by architecture, analysis, and design.

Software refactoring is an effective approach for improving software structure.

The resulting structure does not have to resemble the original planned structure.

The structure changes because programmers learn constraints and approaches that alter the context of the coded solutions.
When used properly, refactoring is a natural activity in the programming process.

For example, the solution for the Spaghetti Code AntiPattern defines a software development process that incorporates refactoring.
Refactoring is strongly recommended prior to performance optimization. Optimizations often involve compromises to program structure.
Ideally, optimizations affect only small portions of a program. Prior refactoring helps partition optimized code from the majority of the software.

Development AntiPatterns utilize various formal and informal refactoring approaches.
The following summaries provide an overview of the Development AntiPatterns found in this chapter and focus on the development AntiPattern problem.
Included are descriptions of both development and mini-AntiPatterns. The refactored solutions appear in the appropriate AntiPattern templates that follow the summaries.
\chapter{Singleton Anti-Pattern}\label{SingletonAntiPattern}
\url{https://www.michaelsafyan.com/tech/design/patterns/singleton}
\paragraph{Overview}
In the Singleton pattern, there is an object for which there is an assumption that there will only ever be one instance of that object.
While one can simply construct a single instance of the object and no other instances, doing so is not the Singleton pattern. 
The Singleton pattern emerges when the singleton-ness of the object is baked into its definition,
typically by providing a function to retrieve the sole instance and making the constructor accessible to only this function.

The name of the function that retrieves the sole instance is typically called "getInstance()", "instance()", or "get()", although the name used is not important to make the object a singleton. 
It is also not necessary for the object to be constructible at all; any use of global (or "static") variables for maintaining state is also a type of singleton.
\paragraph{Why not to use}
\subparagraph{Bad, Brittle Assumption}
The biggest problem with the singleton pattern (and why it is, therefore, a design anti-pattern rather than a design pattern) is that the assumption that
there will ever be only one instance is often broken during a project's lifetime, and this pattern structures the code in a way that requires a very significant effort to refactor
when this assumption is inevitably wrong.

For example, we might reasonably assume that there will only be one HTTP request processed by our application at a time
under the assumption that a new instance of the process is instantiated for every incoming HTTP request that must be processed.
Thus we might initially write the HTTP request object as a singleton.
However, if we were to later modify the architecture to use multiple threads to handle many requests within a single instance of the application,
this assumption suddenly turns out to be false, and it becomes necessary to rework the code significantly to handle this new condition.

Another example may be the object representing a particular library that we happen to use in the application.
We might reasonably assume that there will only ever be one case of that library,
but then turn out to be wrong when we dynamically load the library and need to be able to reference multiple versions of the library
in order to gracefully transition from one version of the library to another during the process of updating the library without needing to completely restart the application.
This and numerous other examples demonstrate the need to ensure that the code is flexible in the event that the assumption of singleton-ness turns out to be false,
and this pattern makes the code inflexible.
\subparagraph{Difficulty Testing}

In addition to making the code inflexible, the singleton pattern also makes it very difficult to test code.
This is because the singleton pattern introduces a dependency through a side-channel that is not explicitly given as a parameter to constructors or other functions that use it.
Even in the event that this side channel can be replaced (and often doing this is very difficult), the need to do so is less obvious and makes tests very difficult to understand.
\subparagraph{Thread-safety Bugs}

Even ignoring the issues above (which are, I believe, the strongest reasons to avoid this pattern),
the singleton pattern is especially difficult to implement correctly when
taking multithreading into account (though this is more a case to use a library to implement the pattern when using the pattern rather than a case to avoid it).
On that note, though, the singleton assumption does require that the singleton object, itself, be thread-safe;
however, moving the singleton property outside of the object allows one to create alternative implementations,
some of which are thread-safe and others which are not,
which then allows applications that are not multithreaded to instantiate a version of the object 
that doesn't have the overhead of thread synchronization while allowing multithreaded applications to instantiate the thread-safe version.
\subparagraph{General pattern}
\begin{lstlisting}[caption={General Pattern}, language=C++]
class NameOfSingletonObject 
{
  public:
    
      // Returns the sole instance of this object. The object can either be lazily created on the first invocation (a "lazy singleton") or
      // it could have been created earlier when the class was initialized, such as by using static field initialization (an "eager singleton").
      static NameOfSingletonObject* Get();
    
  private:
      // A defining feature of the singleton pattern is that the object cannot be constructed directly and instead is retrieved
      // through some other function that returns the instance
      NameOfSingletonObject(/* ... */);
};
\end{lstlisting}    

\subparagraph{What to use instead}

Instead of using this pattern, simply instantiate a single instance and propagate it to places that use the object as a parameter to make the dependency explicit.
For example, instead of this:
\begin{lstlisting}[caption={BAD: Using singleton}, language=Java]
public class CloseButtonHandler implements ButtonHandler {
   @Override
   public void buttonPressed() {
     // What will we do if we ever redesign the app to have multiple windows?
     // Using a singleton like this is inherently fragile.
     Window.getInstance().closeWindow();
   }
}
\end{lstlisting}    

... you should do this, instead:

\begin{lstlisting}[caption={GOOD: Allows dependency to be supplied explicitly}, language=Java]
public class CloseButtonHandler implements ButtonHandler {
   private final Window window;

   public CloseButtonHandler(Window window) {
     this.window = Preconditions.checkNotNull(window);
   }

   @Override
   public void buttonPressed() {
     window.closeWindow();
   }
}
\end{lstlisting}    

Both of the examples will work, but in the second example, the singleton object needs to be provided explicitly (the fact that it is singleton is merely a property of the application / caller,
not of the object, itself), which then allows tests to supply an alternative implementation and makes the code capable of dealing with multiple instances in the future.

It should be noted that a common objection to structuring code as in the second version is that doing so may result in a large number of parameters in code that relies on many singleton objects.
This problem, however, is often exacerbated by passing indirect dependencies and can be fixed by passing direct dependencies or by encapsulating multiple dependencies together into a single object;
for example, instead of passing four dependencies that are not used directly and are only used to instantiate some fifth object,
pass a factory object that creates this fifth object and encapsulates these four dependencies, instead, so that you only need a single dependency.
In addition, the burden of having to pass multiple explicit dependencies can also be greatly reduced by using a dependency injection framework such as Dagger.
\paragraph{Real Examples}

Although Singleton should generally be avoided, it is nevertheless an extremely common and popular pattern.
If you're curious to see how this pattern is used in the wild, you may find these real examples from GitHub to be helpful:

    Controller from spearskw/PuzzleFreak
    Database from cjs-smith1993/RI\_P1
    ConfigManager from HyperLiink/sbw
    AudioSystem from stuckie/ludumdare
    Config from chri55w/GEC-Engine-Refactor

\chapter{The Blob}
Procedural-style design leads to one object with a lion’s share of the responsibilities, while most other objects only hold data or execute simple processes.
The solution includes refactoring the design to distribute responsibilities more uniformly and isolating the effect of changes.
\chapter{Continuous Obsolescence}
Technology is changing so rapidly that developers often have trouble keeping up with current versions of software and finding combinations of product releases that work together.
Given that every commercial product line evolves through new releases, the situation is becoming more difficult for developers to cope with.
Finding compatible releases of products that successfully interoperate is even harder.
\chapter{Lava Flow}
Dead code and forgotten design information is frozen in an ever-changing design. This is analogous to a Lava Flow with hardening globules of rocky material.
The refactored solution includes a configuration management process that eliminates dead code and evolves or refactors design toward increasing quality.
\chapter{Ambiguous Viewpoint}
Object-oriented analysis and design (OOA\&D) models are often presented without clarifying the viewpoint represented by the model.
By default, OOA\&D models denote an implementation viewpoint that is potentially the least useful.
Mixed viewpoints don’t allow the fundamental separation of interfaces from implementation details, which is one of the primary benefits of the object-oriented paradigm.
\chapter{Functional Decomposition}
This AntiPattern is the output of experienced, nonobject-oriented developers who design and implement an application in an object-oriented language.
The resulting code resembles a structural language (Pascal, FORTRAN) in class structure.
It can be incredibly complex as smart procedural developers devise very “clever” ways to replicate their time-tested methods in an object-oriented architecture.
\chapter{Poltergeists}
Poltergeists are classes with very limited roles and effective life cycles. They often start processes for other objects.
The refactored solution includes a reallocation of responsibilities to longer-lived objects that eliminate the Poltergeists.
\chapter{Boat Anchor}
A Boat Anchor is a piece of software or hardware that serves no useful purpose on the current project. Often, the Boat Anchor is a costly acquisition, which makes the purchase even more ironic.
\chapter{Golden Hammer}
A Golden Hammer is a familiar technology or concept applied obsessively to many software problems. 
The solution involves expanding the knowledge of developers through education, training, and book study groups to expose developers to alternative technologies and approaches.
\chapter{Dead End}
A Dead End is reached by modifying a reusable component if the modified component is no longer maintained and supported by the supplier.
When these modifications are made, the support burden transfers to the application system developers and maintainers.
Improvements in the reusable component are not easily integrated, and support problems can be blamed upon the modification.
\chapter{Spaghetti Code}
Ad hoc software structure makes it difficult to extend and optimize code. Frequent code refactoring can improve software structure, support software maintenance, and enable iterative development.
\chapter{Input Kludge}
Software that fails straightforward behavioral tests may be an example of an input kludge, which occurs when ad hoc algorithms are employed for handling program input.
\chapter{Walking through a Minefield}
Using today’s software technology is analogous to walking through a high-tech mine field.
Numerous bugs are found in released software products; in fact, experts estimate that original source code contains two to five bugs per line of code.
\chapter{Cut-and-Paste Programming}
Code reused by copying source statements leads to significant maintenance problems.
Alternative forms of reuse, including black-box reuse, reduce maintenance issues by having common source code, testing, and documentation.
\chapter{Mushroom Management}
In some architecture and management circles, there is an explicit policy to keep system developers isolated from the system’s end users.
Requirements are passed second-hand through intermediaries, including architects, managers, or requirements analysts.

\subpart{Software Architecure AntiPatterns}
Architecture AntiPatterns focus on the system-level and enterprise-level structure of applications and components.
Although the engineering discipline of software architecture is relatively immature,
what has been determined repeatedly by software research and experience is the overarching importance of architecture in software development.

Architecture AntiPatterns focus on the system-level and enterprise-level structure of applications and components.
Although the engineering discipline of software architecture is relatively immature,
what has been determined repeatedly by software research and experience is the overarching importance of architecture in software development:

    Good architecture is a critical factor in the success of the system development.

    Architecture-driven software development is the most effective approach to building systems.
    Architecture-driven approaches are superior to requirements-driven, document-driven, and methodology-driven approaches. Projects often succeed in spite of methodology, not because of it.

Software architecture is a subset of the overall system architecture, which includes all design and implementation aspects, including hardware and technology selection.
Important principles of architecture include the following:

    Architecture provides a view of the whole system. This distinguishes architecture from other analysis and design models that focus on parts of a system.

    An effective way to model whole systems is through multiple viewpoints. The viewpoints correlate to various stakeholders and technical experts in the system-development process.


The following AntiPatterns focus on some common problems and mistakes in the creation, implementation, and management of architecture.

\chapter{Autogenerated Stovepipe}
This AntiPattern occurs when migrating an existing software system to a distributed infrastructure.
An Autogenerated Stovepipe arises when converting the existing software interfaces to distributed interfaces.
If the same design is used for distributed computing, a number of problems emerge.
\chapter{Stovepipe Enterprise}
A Stovepipe System is characterized by a software structure that inhibits change.
The refactored solution describes how to abstract subsystem and components to achieve an improved system structure.
The Stovepipe Enterprise AntiPattern is characterized by a lack of coordination and planning across a set of systems.
\paragraph{Background}
Stovepipe is a popular term used to describe software systems with ad hoc architectures. It is a metaphor to the exhaust pipes of wood-burning stoves, so-called pot-bellied stoves.
Since wood burning produces corrosive substances that erode metal, a stovepipe must be constantly maintained and repaired in order to avoid leakage.
Often, the pipes are repaired with any materials at hand, thus wood-burning stovepipes quickly become a hodgepodge of ad hoc repairs—hence,
the reference is used to describe the ad hoc structure of many software systems.
\chapter{Jumble}
When horizontal and vertical design elements are intermixed, an unstable architecture results.
The intermingling of horizontal and vertical design elements limits the reusability and robustness of the architecture and the system software components.
\chapter{Stovepipe System}
Subsystems are integrated in an ad hoc manner using multiple integration strategies and mechanisms, and all are integrated point to point.
The integration approach for each pair of subsystems is not easily leveraged toward that of other subsystems.
The Stovepipe System AntiPattern is the single-system analogy of Stovepipe Enterprise, and is concerned with how the subsystems are coordinated within a single system.
\chapter{Cover Your Assets}
Document-driven software processes often produce less-than-useful requirements and specifications because the authors evade making important decisions.
In order to avoid making a mistake, the authors take a safer course and elaborate upon alternatives.
\chapter{Vendor Lock-In}
Vendor Lock-In occurs in systems that are highly dependent upon proprietary architectures.
The use of architectural isolation layers can provide independence from vendor-specific solutions.
\chapter{Wolf Ticket}
A Wolf Ticket is a product that claims openness and conformance to standards that have no enforceable meaning.
The products are delivered with proprietary interfaces that may vary significantly from the published standard.
\paragraph{Background}
The term Wolf Ticket originates from its slang use, where it is an unofficial pass sold to an event, such as a rock concert, by scalpers.
\chapter{Architecture by Implication}
Management of risk in follow-on system development is often overlooked due to overconfidence and recent system successes.
A general architecture approach that is tailored to each application system can help identify unique requirements and risk areas.
\chapter{Warm Bodies}
Software projects are often staffed with programmers with widely varying skills and productivity levels.
Many of these people may be assigned to meet staff size objectives (so-called “warm bodies”).
Skilled programmers are essential to the success of a software project.
So-called heroic programmers are exceptionally productive, but as few as 1 in 20 have this talent. They produce an order of magnitude more working software than an average programmer.
\chapter{Design by Committee}
The classic AntiPattern from standards bodies, Design by Committee creates overly complex architectures that lack coherence.
Clarification of architectural roles and improved process facilitation can refactor bad meeting processes into highly productive events.
\chapter{Swiss Army Knife}
A Swiss Army Knife is an excessively complex class interface. The designer attempts to provide for all possible uses of the class.
In the attempt, he or she adds a large number of interface signatures in a futile attempt to meet all possible needs.
\chapter{Reinvent the Wheel}
The pervasive lack of technology transfer between software projects leads to substantial reinvention.
Design knowledge buried in legacy assets can be leveraged to reduce time-to-market, cost, and risk.
\chapter{The Grand Old Duke of York}
Egalitarian software processes often ignore people’s talents to the detriment of the project.
Programming skill does not equate to skill in defining abstractions.
There appear to be two distinct groups involved in software development: abstractionists and their counterparts the implementationists.


\subpart{Project Management AntiPatterns}
In the modern engineering profession, more than half of the job involves human communication and resolving people issues.
The management AntiPatterns identify some of the key scenarios in which these issues are destructive to software processes.

In the modern engineering profession, more than half of the job involves human communication and resolving people issues.
The management AntiPatterns identify some of the key scenarios in which these issues are destructive to software processes.

The role of the technical manager is changing. Before ubiquitous electronic mail and intranets, managers were primarily organizational communicators.
Management chains conveyed information across organizational boundaries, whereas in the electronic organization, communication can occur seamlessly across space, time, and boundaries.

Traditionally, a key role of management has been to authorize exceptions to rules and procedures.
But business-process reengineering (BPR) of organizational structures has changed that role significantly.
Before reengineering, organizational boundaries enforced legacy business rules that were often counterproductive.
In reengineered organizations, unproductive boundaries are eliminated, and people are empowered to solve problems without management intervention.

In software development, however, managers still play several important roles, in the areas of:

    Software process management

    Resource management (human \& IT infrastructure)

    External relationship management (e.g., customers, development partners)

\chapter{Blowhard Jamboree}
The opinions of so-called industry experts often influence technology decisions.
Controversial reports that criticize particular technologies frequently appear in popular media and private publications.
In addition to technical responsibilities, developers spend too much time answering the concerns of managers and decision makers arising from these reports.
\chapter{Analysis Paralysis}
Striving for perfection and completeness in the analysis phase often leads to project gridlock and excessive thrashing of requirements/models.
The refactored solution includes a description of incremental, iterative development processes that defer detailed analysis until the knowledge is needed.
\chapter{Viewgraph Engineering}
On some projects, developers become stuck preparing viewgraphs and documents instead of developing software.
Management never obtains the proper development tools, and engineers have no alternative but to use office automation software to produce psuedo-technical diagrams and papers.
\chapter{Death by Planning}
Excessive planning for software projects leads to complex schedules that cause downstream problems.
We explain how to plan a reasonable software development process that includes incorporating known facts and incremental replanning.
\chapter{Fear of Success}
An interesting phenomenon often occurs when people and projects are on the brink of success.
Some people begin to worry obsessively about the kinds of things that can go wrong. Insecurities about professional competence come to the surface.
\chapter{Corncob}
Difficult people frequently obstruct and divert the software development process.
Corncobs can be dealt with by addressing their agendas through various tactical, operational, and strategic organizational actions.
\chapter{Intellectual Violence}
Intellectual violence occurs when someone who understands a theory, technology, or buzzword uses this knowledge to intimidate others in a meeting situation.
\chapter{Irrational Management}
Habitual indecisiveness and other bad management habits lead to de facto decisions and chronic development crises.
We explain how to utilize rational management decision-making techniques to improve project resolution and for keeping managers on track.
\chapter{Smoke and Mirrors}
Demonstration systems are important sales tools, as they are often interpreted by end users as representational of production-quality capabilities.
A management team, eager for new business, sometimes (inadvertently) encourages these misperceptions and makes commitments beyond the capabilities of the organization to deliver operational technology.
\chapter{Project Mismanagement}
Inattention to the management of software development processes can cause directionlessness and other symptoms.
Proper monitoring and control of software projects is necessary to successful development activities.
Running a product development is as complex an activity as creating the project plan,
and developing software is as complex as building skyscrapers, involving as many steps and processes, including checks and balances. Often, key activities are overlooked or minimized.
\chapter{Throw It over the Wall}
Object-oriented methods, design patterns, and implementation plans intended as flexible guidelines are too often taken literally by the downstream managers and object-oriented developers.
As guidelines progress through approval and publication processes, they often are attributed with unfulfilled qualities of completeness, prescriptiveness, and mandated implementation.
\chapter{Fire Drill}
Airline pilots describe flying as “hours of boredom followed by 15 seconds of sheer terror.”
Many software projects resemble this situation: “Months of boredom followed by demands for immediate delivery.”
The months of boredom may include protracted requirements analysis, replanning, waiting for funding, waiting for approval, or any number of technopolitical reasons.
\chapter{The Feud}
Personality conflicts between managers can dramatically affect the work environment.
The employees reporting to these managers often suffer the consequences of their supervisors’ disagreements.
Animosity between managers is reflected in the attitudes and actions of their employees.
\chapter{E-mail Is Dangerous}
E-mail is an important communication medium for software managers. Unfortunately, it is an inappropriate medium for many topics and sensitive communications.

\subpart{Refactoring}\label{SREF}
\chapter{Bad code smells}
\subsection{Bloaters}
Bloaters are code, methods and classes that have increased to such gargantuan proportions that they are hard to work with.
Usually these smells do not crop up right away, rather they accumulate over time as the program evolves (and especially when nobody makes an effort to eradicate them).
\paragraph{Long Method}
A method contains too many lines of code. Generally, any method longer than ten lines should make you start asking questions.
\paragraph{Large Class}
A class contains many fields/methods/lines of code.
\paragraph{Primitive Obsession}
    Use of primitives instead of small objects for simple tasks (such as currency, ranges, special strings for phone numbers, etc.)
    Use of constants for coding information (such as a constant USER\_ADMIN\_ROLE = 1 for referring to users with administrator rights.)
    Use of string constants as field names for use in data arrays.
\paragraph{Long Parameter List}
More than three or four parameters for a method.
\paragraph{Data Clumps}
Sometimes different parts of the code contain identical groups of variables (such as parameters for connecting to a database). These clumps should be turned into their own classes.

\subsection{Object-Orientation Abusers}

All these smells are incomplete or incorrect application of object-oriented programming principles.
\subsection{Change Preventers}

These smells mean that if you need to change something in one place in your code, you have to make many changes in other places too.
Program development becomes much more complicated and expensive as a result.
\subsection{Dispensables}

A dispensable is something pointless and unneeded whose absence would make the code cleaner, more efficient and easier to understand
\subsection{Couplers}

All the smells in this group contribute to excessive coupling between classes or show what happens if coupling is replaced by excessive delegation.
\chapter{Refactoring techniques}
\subsection{Composing methods}

Much of refactoring is devoted to correctly composing methods. In most cases, excessively long methods are the root of all evil.
The vagaries of code inside these methods conceal the execution logic and make the method extremely hard to understand – and even harder to change.

The refactoring techniques in this group streamline methods, remove code duplication, and pave the way for future improvements.
\subsection{Moving Features between Objects}
Even if you have distributed functionality among different classes in a less-than-perfect way, there is still hope.

These refactoring techniques show how to safely move functionality between classes, create new classes, and hide implementation details from public access.
\subsection{Organizing Data}
These refactoring techniques help with data handling, replacing primitives with rich class functionality.
Another important result is untangling of class associations, which makes classes more portable and reusable.
\subsection{Simplifying Conditional Expressions}
Conditionals tend to get more and more complicated in their logic over time, and there are yet more techniques to combat this as well.
\subsection{Simplifying Method Calls}

These techniques make method calls simpler and easier to understand. This, in turn, simplifies the interfaces for interaction between classes.

\subsection{Dealing with Generalisation}

Abstraction has its own group of refactoring techniques, primarily associated with moving functionality along the class inheritance hierarchy,
creating new classes and interfaces, and replacing inheritance with delegation and vice versa.

\chapter{Introduce Null Object}\label{rfINO}
See ``Null Object Pattern'' at ~\ref{NullObjectPattern}. Since some methods return null instead of real objects, you have many checks for null in your code.
\begin{lstlisting}[caption={Problem}, language=Java]
if (customer == null) {
  plan = BillingPlan.basic();
}
else {
  plan = customer.getPlan();
}
\end{lstlisting}

Instead of null, return a null object that exhibits the default behavior.
\begin{lstlisting}[caption={Solution}, language=Java]
if (customer == null) {
class NullCustomer extends Customer {
  boolean isNull() {
    return true;
  }
  Plan getPlan() {
    return new NullPlan();
  }
  // Some other NULL functionality.
}
// Replace null values with Null-object.
customer = (order.customer != null) ?  order.customer : new NullCustomer();
plan = customer.getPlan(); // Use Null-object as if it's normal subclass.
\end{lstlisting}
\paragraph{Why Refactor}
Dozens of checks for null make your code longer and uglier.
\paragraph{Drawbacks}
    The price of getting rid of conditionals is creating yet another new class.
\paragraph{How to Refactor}

    From the class in question, create a subclass that will perform the role of null object.

    In both classes, create the method isNull(), which will return true for a null object and false for a real class.

    Find all places where the code may return null instead of a real object. Change the code so that it returns a null object.

    Find all places where the variables of the real class are compared with null. Replace these checks with a call for isNull().

    If methods of the original class are run in these conditionals when a value does not equal null, redefine these methods in the null class and insert the code from the else part of the condition there.
    Then you can delete the entire conditional and differing behavior will be implemented via polymorphism.

    If things are not so simple and the methods cannot be redefined,
    see if you can simply extract the operators that were supposed to be performed in the case of a null value to new methods of the null object.
    Call these methods instead of the old code in else as the operations by default.


\part{Architecures}

\subpart{Architecural patterns}
\paragraph{Wikipedia} An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context.
Architectural patterns are often documented as software design patterns.
\chapter{Three-tier}\label{ThreeTier}
\paragraph{wikipedia}
Three-tier architecture is a client–server software architecture pattern in which the user interface (presentation),
functional process logic ("business rules"), computer data storage and data access are developed and maintained as independent modules, most often on separate platforms.
It was developed by John J. Donovan in Open Environment Corporation (OEC), a tools company he founded in Cambridge, Massachusetts.

Apart from the usual advantages of modular software with well-defined interfaces,
the three-tier architecture is intended to allow any of the three tiers to be upgraded or replaced independently in response to changes in requirements or technology. 
For example, a change of operating system in the presentation tier would only affect the user interface code.

Typically, the user interface runs on a desktop PC or workstation and uses a standard graphical user interface,
functional process logic that may consist of one or more separate modules running on a workstation or application server,
and an RDBMS on a database server or mainframe that contains the computer data storage logic.
The middle tier may be multitiered itself (in which case the overall architecture is called an "n-tier architecture").

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/arc_3tiers.PNG}}{\caption{Three-tier Architecure}\label{3ta}}
\end{floatrow}
\end{figure}
\paragraph{Three-tier architecture:}

\textbf{Presentation tier}
    This is the topmost level of the application. The presentation tier displays information related to such services as browsing merchandise,
    purchasing and shopping cart contents. It communicates with other tiers by which it puts out the results to the browser/client tier and all other tiers in the network.
    In simple terms, it is a layer which users can access directly (such as a web page, or an operating system's GUI).

\textbf{Application tier (business logic, logic tier, or middle tier)}
    The logical tier is pulled out from the presentation tier and, as its own layer, it controls an application’s functionality by performing detailed processing.

\textbf{Data tier}
    The data tier includes the data persistence mechanisms (database servers, file shares, etc.) and the data access layer that encapsulates the persistence mechanisms and exposes the data.
    The data access layer should provide an API to the application tier that exposes methods of managing the stored data without exposing or creating dependencies on the data storage mechanisms.
    Avoiding dependencies on the storage mechanisms allows for updates or changes without the application tier clients being affected by or even aware of the change. As with the separation of any tier,
    there are costs for implementation and often costs to performance in exchange for improved scalability and maintainability.

\paragraph{Web development usage}

In the web development field, three-tier is often used to refer to websites, commonly electronic commerce websites, which are built using three tiers:

    A front-end web server serving static content, and potentially some cached dynamic content. In web-based application, front end is the content rendered by the browser.
    The content may be static or generated dynamically.

    A middle dynamic content processing and generation level application server (e.g., Symfony, Spring, ASP.NET, Django, Rails).

    A back-end database or data store, comprising both data sets and the database management system software that manages and provides access to the data.

\paragraph{Other considerations}
Data transfer between tiers is part of the architecture.
Protocols involved may include one or more of SNMP, CORBA, Java RMI, \.NET Remoting, Windows Communication Foundation, sockets, UDP, web services or other standard or proprietary protocols.
Often middleware is used to connect the separate tiers. Separate tiers often (but not necessarily) run on separate physical servers, and each tier may itself run on a cluster.
\chapter{Multilayered architecture}
\paragraph{wikipedia}
In software engineering, multitier architecture (often referred to as n-tier architecture) or multilayered architecture is a client–server architecture in which presentation,
application processing, and data management functions are physically separated. The most widespread use of multitier architecture is the three-tier architecture.

N-tier application architecture provides a model by which developers can create flexible and reusable applications.
By segregating an application into tiers, developers acquire the option of modifying or adding a specific layer, instead of reworking the entire application.
A three-tier architecture is typically composed of a presentation tier, a domain logic tier, and a data storage tier.

While the concepts of layer and tier are often used interchangeably, one fairly common point of view is that there is indeed a difference.
This view holds that a layer is a logical structuring mechanism for the elements that make up the software solution, while a tier is a physical structuring mechanism for the system infrastructure.
[1][2] For example, a three-layer solution could easily be deployed on a single tier, such as a personal workstation.[3]

\paragraph{Common layers}

In a logical multilayered architecture for an information system with an object-oriented design, the following four are the most common:

    Presentation layer (a.k.a. UI layer, view layer, presentation tier in multitier architecture)

    Application layer (a.k.a. service layer[5][6] or GRASP Controller Layer [7])

    Business layer (a.k.a. business logic layer (BLL), domain layer)

    Data access layer (a.k.a. persistence layer, logging, networking, and other services which are required to support a particular business layer)

The book Domain Driven Design describes some common uses for the above four layers, although its primary focus is the domain layer.[8]

If the application architecture has no explicit distinction between the business layer and the presentation layer (i.e., the presentation layer is considered part of the business layer),
then a traditional client-server (two-tier) model has been implemented.[citation needed]

The more usual convention is that the application layer (or service layer) is considered a sublayer of the business layer,
typically encapsulating the API definition surfacing the supported business functionality. The application/business layers can, in fact,
be further subdivided to emphasize additional sublayers of distinct responsibility. For example, if the Model View Presenter pattern is used,
the presenter sublayer might be used as an additional layer between the user interface layer and the business/application layer (as represented by the model sublayer).[citation needed]

Some also identify a separate layer called the business infrastructure layer (BI), located between the business layer(s) and the infrastructure layer(s).
It's also sometimes called the "low-level business layer" or the "business services layer".
This layer is very general and can be used in several application tiers (e.g. a CurrencyConverter).[9]

The infrastructure layer can be partitioned into different levels (high-level or low-level technical services).[9]
Developers often focus on the persistence (data access) capabilities of the infrastructure layer and therefore only talk about
the persistence layer or the data access layer (instead of an infrastructure layer or technical services layer). 
In other words, the other kind of technical services are not always explicitly thought of as part of any particular layer.[citation needed]

A layer is on top of another, because it depends on it. Every layer can exist without the layers above it, and requires the layers below it to function.
Another common view is that layers do not always strictly depend on only the adjacent layer below.
For example, in a relaxed layered system (as opposed to a strict layered system) a layer can also depend on all the layers below it.[4]
\chapter{Model-View-View-Model}\label{MVVM}
Separate Presentation from business logic.
most useful when binding is available.

\chapter{Model-view-controller}\label{MVCAR}
\paragraph{Advantages \& disadvantages}
\textbf{Advantages}

    Simultaneous development – Multiple developers can work simultaneously on the model, controller and views.

    High cohesion – MVC enables logical grouping of related actions on a controller together. The views for a specific model are also grouped together.

    Low coupling – The very nature of the MVC framework is such that there is low coupling among models, views or controllers

    Ease of modification – Because of the separation of responsibilities, future development or modification is easier

    Multiple views for a model – Models can have multiple views

\textbf{Disadvantages}

    Code navigability – The framework navigation can be complex because it introduces new layers of abstraction and requires users to adapt to the decomposition criteria of MVC.

    Multi-artifact consistency – Decomposing a feature into three artifacts causes scattering. Thus, requiring developers to maintain the consistency of multiple representations at once.

    Pronounced learning curve – Knowledge on multiple technologies becomes the norm. Developers using MVC need to be skilled in multiple technologies.

\chapter{Domain Driven Design}

Domain-driven design (DDD) is an approach to software development for complex needs by connecting the implementation to an evolving model.[1] The premise of domain-driven design is the following:

    placing the project's primary focus on the core domain and domain logic;

    basing complex designs on a model of the domain;

    initiating a creative collaboration between technical and domain experts to iteratively refine a conceptual model that addresses particular domain problems.

\chapter{Micro-kernel}
Many applications have a core set of operations that are used again and again in different patterns that depend upon the data and the task at hand.
The popular development tool Eclipse, for instance, will open files, annotate them, edit them, and start up background processors.
The tool is famous for doing all of these jobs with Java code and then, when a button is pushed, compiling the code and running it.

In this case, the basic routines for displaying a file and editing it are part of the microkernel.
The Java compiler is just an extra part that’s bolted on to support the basic features in the microkernel.
Other programmers have extended Eclipse to develop code for other languages with other compilers.
Many don’t even use the Java compiler, but they all use the same basic routines for editing and annotating files.

The extra features that are layered on top are often called plug-ins. Many call this extensible approach a plug-in architecture instead.

Richards likes to explain this with an example from the insurance business: “Claims processing is necessarily complex, but the actual steps are not. What makes it complex are all of the rules.”

The solution is to push some basic tasks—like asking for a name or checking on payment—into the microkernel.
The different business units can then write plug-ins for the different types of claims by knitting together the rules with calls to the basic functions in the kernel.

Caveats:

    Deciding what belongs in the microkernel is often an art. It ought to hold the code that’s used frequently.

    The plug-ins must include a fair amount of handshaking code so the microkernel is aware that the plug-in is installed and ready to work.

    Modifying the microkernel can be very difficult or even impossible once a number of plug-ins depend upon it. The only solution is to modify the plug-ins too.

    Choosing the right granularity for the kernel functions is difficult to do in advance but almost impossible to change later in the game.

Best for:

    Tools used by a wide variety of people

    Applications with a clear division between basic routines and higher order rules

    Applications with a fixed set of core routines and a dynamic set of rules that must be updated frequently
\chapter{Blackboard pattern}
In software engineering, the blackboard pattern is a behavioral design pattern[1] that provides a computational framework for the design and implementation of systems
that integrate large and diverse specialized modules, and implement complex, non-deterministic control strategies.[2][1]

This pattern was identified by the members of the HEARSAY-II project and first applied to speech recognition.[2]

\paragraph{Structure}

The blackboard model defines three main components:

    blackboard - a structured global memory containing objects from the solution space
    knowledge sources - specialized modules with their own representation
    control component - selects, configures and executes modules.[2]
\chapter{Sensor-controller-actuator}
\chapter{Presentation–abstraction–control}


\subpart{Architecural styles}

\chapter{Structure}

\section{Component-based}
\section{Monolithic application}
\section{Layered}
\section{Pipes and filters}

\chapter{Shared memory}

\section{Database-centric}
\section{Blackboard}
\section{Rule-based}
    
\chapter{Messaging}

\section{Event-driven aka implicit invocation}
\section{Publish-subscribe}
\section{Asynchronous messaging}

\chapter{Adaptive systems}

\section{Plug-ins}
\section{Microkernel}
\section{Reflection}
\section{Domain specific languages}

\chapter{Distributed systems}

\section{Client-server (2-tier, 3-tier, n-tier exhibit this style)}
\section{Shared nothing architecture}
\section{Space-based architecture}
\section{Object request broker}
\section{Peer-to-peer}
\section{Representational state transfer (REST)}
\section{Service-oriented}
\section{Cloud computing patterns}

\chapter{Service-Oriented Architecure}\label{SOA}

\part{Procedural programming patters}
\url{https://stackoverflow.com/questions/10491175/does-procedural-language-have-design-patterns}
Procedural languages indeed have design patterns. But since the procedural approach is generally neglected in favor of the class based OOP, they are not widely recognized.


\chapter{Handles}

This is how encapsulation is done in procedural programming. The constructing function doesn't return a struct or an object. 
But a handle: it's generally an opaque pointer or just an integer. You cannot do absolutely nothing interesting, because it's just a number, The details are completely hidden. 
But you can pass this handle to the functions that deal with it:

Examples:

    On Windows the ``CreateWindow'' function returns a HWND. Which is a handle to a window, which can be passed to other functions like ShowWindow, DestroyWindow, etc.
    On Linux the ``open'' system call. Which returns just and int. Which is a file handle.

\chapter{Contexts}

Objects are usually called contexts in procedural language. Context is a struct that contains the state of some system, just like the members of an object. 
In OOP you write object.method(parameter). In procedural programming you write function(addressOfContext, parameter). 
The internal functions use the context structure directly, while public functions take a handle only and the implementation resolves it to the actual context structure.

\chapter{Callbacks}

Or function pointers. The user of the function passes the address of his function to add custom behavior to a system. This how polymorphism is done in procedural programming. 
This allows writing generic functions.

A notable example of this is the ``qsort'' C function. This takes the address of an array of elements. 
Takes how large one element is and how many elements in the array and a comparator function which performs the comparison. That's completely generic implementation and allows sorting all kinds of data.

\chapter{Setup structs}

When a function can be parameterized in lots of ways. Typically a setup structure is used. 
Specifications often require that these structs are zero filled by default, and only the relevant members are filled. 
If some members are mutually exclusive they are placed in an union. Typical example of such setup struct is the ``WNDCLASS'' from WinAPI.

\chapter{Variable size data}

Well this is rather a C pattern than a general design pattern. Sometimes objects may hold an arbitrary size binary payload. 
This pattern typically occur when reading data from binary files than can contain several types of data chunks. That's done by a struct like this.
\begin{lstlisting}
typedef struct
{
    int someData;
    int otherData;
    int nPayloadLength;
    unsigned char payload[1];
} VariableSized;
\end{lstlisting}

And in the code the following is done:
\begin{lstlisting}
VariableSized *vs = malloc(sizeof(VariableSized) + extraLength);
\end{lstlisting}

This allocates memory thats larger than the struct allowing space for a variable length payload. Whose 5th byte then can be accessed by eg. vs->payload[4].

The advantage of this that the whole object can be freed in one free call. And it's guaranteed that it have a continous block in the memory. 
So it utilizes the cache better than allocating the corresponding buffer somewhere else in the heap.

\chapter{Procedural counterparts of OOP design patterns}

OOP patterns are never called in their names in procedural languages. So I can only guess here.

Creation patterns

    Abstract factory: An abstract factory is generally a singleton. In that case this pattern is not used at all and conditional compilation is used instead. 
                        Otherwise setup structs providing the creation functions.
    Builder: setup structs are used.
    Factory method: callbacks are used for creation.
    Lazy initialization: In C++ static local variables are used for this purpose. 
                    In C you can use the if (!initialized) { initialize(); initialized = 1; } pattern at places that are not performance critical. 
                    For performance critical code, lazy loading is not used at all. The user must find a place to initialize the context.
    Prototype: In procedural world we simply return handles to stock objects. An example of this is the GetStockObject function in the WinAPI. 
                    For mutable objects a copy-on-write mechanism is often used for performance reasons.
    Singleton: simply write top level functions (and use global variables when you absolutely need global state).

Structural patterns

    Adapter and Facade: A pattern for building another interface upon an existing one. Simply new functions will call the old and other ones.
    Bridge: Callbacks to the concrete implementations are provided in a form of setup struct.
    Composite: top level functions are used specifying a handle to the parent node it should operate on.
    Decorator: The decorating behavior is supplied in a form of callbacks. 
                Or one event handler callback is provided for all possible decorations that receives various messages and decides to handle them or not (example is the window procedure in WinAPI).
    Flyweight: Read-only binary data used packed in structs and arrays.
    Proxy: Pretty much the same as in OOP, but without classes.

Behavioral patterns

    Chain of responsibility: An array or linked list of callbacks traversed by a loop. Specification describes how should the callbacks indicate that they handled the request causing the loop to break.
    Command: Commands are structs that contain a do and undo callback. These callbacks usually take some kind of context to operate on. And array of commands are maintained to perform the undo.
    Interpreter: A compiler/parser/interpreter is written or generated using lex and yacc.
    Iterator: Handles are used, otherwise the same. For performance reasons in C we often stick to arrays.
    Mediator: Usually realized by using some message dispatching mechanism and message loops and event handlers.
    Memento: Same as in OOP, but without classes.
    Observer: Same as the chain of responsibility, but the loop won't break. An example is the atexit.
    State: Realized by 2 dimensional dispatch tables that maps the current state and the requested operation into a function. (In sparse cases simply ifs are used.)
    Strategy: This is the basic use case of callbacks.
    Template method: Typically frameworks let the user supply his own callbacks for some functions. 
                    Libraries often provide a way to use custom memory allocating function providing a custom malloc and free.
    Visitor: Realized by using multidimensional arrays of callbacks, which is typically NULL filled at the start (for default behavior), and populated in the main initialization code for each type pair.



\part{Appendix}
\section{Appendix A0 C++ Grammar}
\subsection{A0.1 Introduction to the pointer-to-member function}
Pointer-to-member function is one of the most rarely used C++ grammar features.  Even experienced C++ programmers are occasionally be confused. 
This article is a tutorial to beginners, and also shares my findings about the under-the-hood mechanism with more experienced programmers.
Before we move on, let's first take a look at a piece of code that might be a surprise at the first sight.
\begin{lstlisting}[caption={code 1},label={lst:a1},language=C++]
#include <iostream>
 
class Foo{
    public:
        Foo(int i=0){ _i=i;}
        void f(){ std::cout<<"Foo::f()"<<std::endl; }
    private:
        int _i;
};
 
int main(){
  Foo *p=0;
  p->f(); 
} 

Output:
Foo::f()
\end{lstlisting}
Why can we call a member function through a NULL pointer? It seems that the compiler doesn't care what value "p" holds. 
Only the type of "p" counts. 
We will leave the answer of this question to a later section.
For now, what we care about is that the compiler knows exactly which function to call and this is just the well-known "static binding".
Because member functions can have static binding (not always, discussed later on), so their addresses are determined at compile time (not always).
Intuitively, there should be a way to hold the address of member functions and here comes the pointer-to-member functions.

The following grammar shows how to declare a pointer-to-member function.
\begin{lstlisting}
    Return_Type (Class_Name::* pointer_name) (Argument_List);
     
    Return_Type:   member function return type.
    Class_Name:    name of the class in which the member function is declared.
    Argument_List: member function argument list.
    pointer_name:  a name we'd like to call the pointer variable.
\end{lstlisting}
e.g. We have a class Foo and a member function f:
\begin{lstlisting}
    int Foo::f(string);
\end{lstlisting}

We could come up with a name for the pointer-to-member function as fptr, then we have:

\begin{lstlisting}
    Return_Type:   int
    Class_Name:    Foo
    Argument_List: string
\end{lstlisting}
    declaration of a  pointer-to-member function named ``fptr'':
\begin{lstlisting}
      int (Foo::*fptr) (string);
\end{lstlisting}

To assign a member function to the pointer, the grammar is:

\begin{lstlisting}
      fptr= &Foo::f;
\end{lstlisting}
Of course declaration and initialization can be absorbed by one definition:

\begin{lstlisting}
      int (Foo::*fptr) (string) = &Foo::f;
\end{lstlisting}
To invoke the member function through the pointer, we use the pointer-to-member selection operators, either .* or -$>$* . The following code demonstrates the basics.

\begin{lstlisting}
    #include <iostream>
    #include <string>
    using std::string;
     
    class Foo{
    public:
      int f(string str){
        std::cout<<"Foo::f()"<<std::endl;
        return 1;
      }
    };
     
    int main(int argc, char* argv[]){
      int (Foo::*fptr) (string) = &Foo::f;
      Foo obj;
      (obj.*fptr)("str");//call: Foo::f() through an object
      Foo* p=&obj;
      (p->*fptr)("str");//call: Foo::f() through a pointer
    }
\end{lstlisting}
Notice that ".*fptr" binds fptr to the object "obj", on the other hand "-$>$*fptr" binds fptr to the object pointed to by "p".
(Another difference is that we can overload -$>$*, but not .* ) . The parenthesis around (obj.*fptr) and (p-$>$*fptr) is grammatically mandatory.

\paragraph{Pointer-to-member function is not regular pointer}

Pointer-to-member function doesn't hold the "exact address" like a regular pointer does.
We can imagine it holds the "relative address" of where the function is in the class layout. Let's now demonstrate the difference.

Now we make only one change in class Foo. Member function f is now "static".

\begin{lstlisting}
    #include <iostream>
    #include <string>
    using std::string;
     
    class Foo{
    public:
      static int f(string str){ std::cout<<"Foo::f()"<<std::endl; return 1; }
    };
     
    int main(int argc, char* argv[]){
      //int (Foo::*fptr) (string) = &Foo::f;//error 
      int (*fptr) (string) = &Foo::f;//correct
      (*fptr)("str");//call Foo::f()
    }
\end{lstlisting}
A "static" member function has no "this" pointer, it is the same as a regular global function,
except it shares the name scope of class Foo with other class members (In our case the name scope is Foo::).
So the "static" member function is NOT part of the class. 
The pointer-to-member function grammar doesn't work on regular function pointers, such as a pointer to "static" member function shown above. The error information of

\begin{lstlisting}
    int (Foo::*fptr) (string) = &Foo::f;
\end{lstlisting}
from the compiler (g++ 4.2.4 ) is: " cannot convert 'int (*)(std::string)' to 'int (Foo::*)(std::string)". 
This example demonstrates that pointer-to-member function is not regular pointer, otherwise,
why does C++ bother to invent such grammar? Because it is different from regular pointer, the type conversion rules are also counter-intuitive.

\paragraph{C++ Type Conversion rules - Non-virtual case}

Of course, pointer-to-member function (non-static member functions) can not be converted to regular pointers.
(while, if one really really wants, using assembly technique and this can be done in a brute force way.)
As we see in the previous section, pointer-to-member function is not regular pointer. 
Pointer-to-member function represents the "offset" rather than an "absolute address".
But what about the conversion between pointer-to-member function themselves?

\begin{lstlisting}
//memfun4.cpp
class Foo{
public:
  int f(char* c=0){ std::cout<<"Foo::f()"<<std::endl; return 1; }
};
 
class Bar{
public:
  void b(int i=0){ std::cout<<"Bar::b()"<<std::endl; }
};
 
class FooDerived:public Foo{
public:
  int f(char* c=0){ std::cout<<"FooDerived::f()"<<std::endl; return 1; }
};
 
int main(int argc, char* argv[]){
  typedef  int (Foo::*FPTR) (char*);
  typedef  void (Bar::*BPTR) (int);
  typedef  int (FooDerived::*FDPTR) (char*);
 
  FPTR fptr = &Foo::f;
  BPTR bptr = &Bar::b;
  FDPTR fdptr = &FooDerived::f;
 
  //Bptr = static_cast<void (Bar::*) (int)> (fptr); //error
  fdptr = static_cast<int (Foo::*) (char*)> (fptr); //OK: contravariance
 
  Bar obj;
  ( obj.*(BPTR) fptr )(1);//call: Foo::f()
}
 
Output:
Foo::f()
\end{lstlisting}

In the above, we first introduce our friend "typedef". It makes the definition and type information much clear to programmers. What is the type of "fptr", btw? It is of the type:

\begin{lstlisting}
    int (Foo::*) (char*);

\end{lstlisting}
or equivalently, FPTR. If we look closely in the above code:

\begin{lstlisting}
    Bptr = static_cast<void (Bar::*) (int)> (fptr);//error

\end{lstlisting}
is an error, because different non-static non-virtual pointers-to-member function have strong type and can not be converted from one another. However,

\begin{lstlisting}
    fdptr = static_cast<int (Foo::*) (char*)> (fptr); 
\end{lstlisting}
is correct! This contravariance rule appears to be the opposite of the rule that we can assign a pointer to a derived class to a pointer to its base class (the "is-a" relationship).
Nevertheless, the rule preserves the fundamental guarantee that FooDerived::* can be applied to any "interface" that Foo::* can be applied. The last line of the code:

\begin{lstlisting}
      Bar obj;
      ( obj.*(BPTR) fptr )(1);//call: Foo::f()

\end{lstlisting}
Although we want to call Bar::b(), but Foo::f() is called because fptr has static binding. (also see Member function call and this pointer)
\paragraph{Virtual case}

We only change all member functions to be virtual and all class definition is the same as the previous case.

\begin{lstlisting}
    #include <iostream>
    class Foo{
    public:
      virtual int f(char* c=0){
        std::cout<<"Foo::f()"<<std::endl;
        return 1;
      }
    };
     
    class Bar{
    public:
      virtual void b(int i=0){
        std::cout<<"Bar::b()"<<std::endl;
      }
    };
     
    class FooDerived:public Foo{
    public:
      int f(char* c=0){
        std::cout<<"FooDerived::f()"<<std::endl;
        return 1;
      }
    };
     
    int main(int argc, char* argv[]){
      typedef  int (Foo::*FPTR) (char*);
      typedef  void (Bar::*BPTR) (int);
      FPTR fptr=&Foo::f;
      BPTR bptr=&Bar::b;
     
      FooDerived objDer;
      (objDer.*fptr)(0);//call: FooDerived::f(), not Foo::f()
     
      Bar obj;
      ( obj.*(BPTR) fptr )(1);//call: Bar::b() , not Foo::f()
    }
     

    Output:

    FooDerived::f()
    Bar::b()
\end{lstlisting}
As can be seen, when the member function is virtual, pointer-to-member function can have polymorphism and FooDerived::f() is called.Bar::b() now is also correctly called.
Because "a pointer to a virtual member can safely be passed between different address spaces as long as the same object layout is used in both."
(Bjarne Stroustrup , "The C++ Programming Language"). When the function is virtual, the compiler will generate virtual-table to store the address of virtual functions. 
This is the major difference to non-virtual member functions and hence the run time behavior is different.
Pointer-to-member function array and an application.

An important application of pointer-to-member functions is to generate the response events according to inputs. The following Printer class and the pointer array "pmf" demonstrate this.

\begin{lstlisting}
    #include <stdio.h>
    #include <string>
    #include <iostream>
    class Printer{//An abstract printing machine
    public:
      void Copy(char * buff, const char * source){//copy the file
        strcpy(buff, source);
      }
      void Append(char * buff, const char * source){//extend the file
        strcat(buff, source);
      }
    };
     
    enum OPTIONS { COPY, APPEND };//two possible commands in the menu.
    typedef void(Printer::*PTR) (char*, const char*);//pointer-to-member function 
     
    void working(OPTIONS option,
    Printer* machine,
    char* buff,
    const char* infostr){
     
      PTR pmf[2]= {&Printer::Copy, &Printer::Append}; //pointer array 
     
      switch (option){
      case COPY:
        (machine->*pmf[COPY])(buff, infostr);
        break;
      case APPEND:
        (machine->*pmf[APPEND])(buff, infostr);
        break;
      }
    }
     
    int main(){
      OPTIONS option; 
      Printer machine;
      char buff[40];//target
     
      working(COPY, &machine, buff, "Strings ");  
      working(APPEND, &machine, buff, "are concatenated! ");
     
      std::cout<<buff<<std::endl;
    } 

    Output:
      Strings are concatenated! 
\end{lstlisting}
In the above code, working is a function to carry out the printing work given 
1. the menu option,
2. an available printing machine,
3. target,
4. source.
The source is represented by two character strings "Strings " and "are concatenated!".
The pointer-to-member function array is used to select corresponding action according to different menu options.
Another important application of pointer-to-member functions can be found in STL mem\_fun().

\paragraph{Member function call and this pointer}

Now we look back at the beginning of this article.
Why a null pointer can call a member function? For a non-virtual function call like: p->f(), the compiler will generate code like the following:

\begin{lstlisting}
    Foo* const this=p;
    void Foo::f( Foo *const this){ std::cout<<"Foo::f()"<<std::endl; }
\end{lstlisting}
So the function Foo::f can be called no matter what the value of "p" is. It is just like a global function!
"p" is passed as "this pointer" to the function argument. 
The "this pointer" is not dereferenced in the function (in our special case) and therefore the compiler will let us go.
What if we want to see the value of member data ``\_i''? 
Then the compiler need to dereference the "this pointer" and as a result, an undefined behavior.
For a virtual function call, the correct version of the member function need to be found through virtual-table,
then "this pointer" is passed to the correct version of the function. That's why pointer-to-member function for non-virtual, virtual, static member functions are implemented in different ways.

\paragraph{Conclusion}

In conclusion, what we learned here is:

1. The grammar of pointer-to-member function declaration and definition.

2. The grammar to invoke member functions by pointer-to-member selection operators.

3. Use typedef to write clearer code.

4. Difference of non-virtual, virtual, static member functions.

5. Pointer-to-member function vs. regular pointer to member.

6. Pointer-to-member function conversion rules in different situations.

7. How to use pointer-to-member function array to solve a practical design problem.

8. How the member function call is reinterpreted by the compiler.
\subsection{A0.2 Pointers to members (C++ only)}

Pointers to members allow you to refer to nonstatic members of class objects.
You cannot use a pointer to member to point to a static class member because the address of a static member is not associated with any particular object. 
To point to a static class member, you must use a normal pointer.

You can use pointers to member functions in the same manner as pointers to functions.
You can compare pointers to member functions, assign values to them, and use them to call member functions.
Note that a member function does not have the same type as a nonmember function that has the same number and type of arguments and the same return type.
Pointers to members can be declared and used as shown in the following example:
\begin{lstlisting}
#include <iostream>
using namespace std;

class X {
public:
  int a;
  void f(int b) { cout << "The value of b is "<< b << endl; }
};

int main() {

  // declare pointer to data member
  int X::*ptiptr = &X::a;

  // declare a pointer to member function
  void (X::* ptfptr) (int) = &X::f;

  // create an object of class type X
  X xobject;

  // initialize data member
  xobject.*ptiptr = 10;

  cout << "The value of a is " << xobject.*ptiptr << endl;

  // call member function
  (xobject.*ptfptr) (20);
}

The output for this example is:

The value of a is 10
The value of b is 20

\end{lstlisting}
To reduce complex syntax, you can declare a typedef to be a pointer to a member. A pointer to a member can be declared and used as shown in the following code fragment:

\begin{lstlisting}
typedef int X::*my_pointer_to_member;
typedef void (X::*my_pointer_to_function) (int);

int main() {
  my_pointer_to_member ptiptr = &X::a;
  my_pointer_to_function ptfptr = &X::f;
  X xobject;
  xobject.*ptiptr = 10;
  cout << "The value of a is " << xobject.*ptiptr << endl;
  (xobject.*ptfptr) (20);
}

\end{lstlisting}
The pointer to member operators .* and -$>$* are used to bind a pointer to a member of a specific class object.
Because the precedence of () (function call operator) is higher than .* and -$>$*, you must use parentheses to call the function pointed to by ptf.

Pointer-to-member conversion can occur when pointers to members are initialized, assigned, or compared. 
Note that pointer to a member is not the same as a pointer to an object or a pointer to a function.

\subsection{A0.3 copy initialization}
Initializes an object from another object

\begin{lstlisting}[caption={Syntax}, language=C++]
T object = other; 	(1) 	
T object = {other} ; 	(2) 	(until C++11)
f(other) 	(3) 	
return other; 	(4) 	
throw object;

catch (T object) (5) 	
T array[N] = {other}; 	(6) 	
\end{lstlisting}
\paragraph{Explanation}

Copy initialization is performed in the following situations:

1) when a named variable (automatic, static, or thread-local) of a non-reference type T is declared with the initializer consisting of an equals sign followed by an expression.

2) (until C++11)when a named variable of a scalar type T is declared with the initializer consisting of an equals sign followed by a brace-enclosed expression
(Note: as of C++11, this is classified as list initialization, and narrowing conversion is not allowed).

3) when passing an argument to a function by value

4) when returning from a function that returns by value

5) when throwing or catching an exception by value

6) as part of aggregate initialization (Initializes an aggregate from braced-init-list), to initialize each element for which an initializer is provided

The effects of copy initialization are:

        First, if T is a class type and the initializer is a prvalue expression whose cv-unqualified type is the same class as T,
        the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object: see copy elision 

	(since C++17)

    If T is a class type and the cv-unqualified version of the type of other is T or a class derived from T,
    the non-explicit constructors of T are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object. 

    If T is a class type, and the cv-unqualified version of the type of other is not T or derived from T, or if T is non-class type,
    but the type of other is a class type, user-defined conversion sequences that can convert from the type of other to
    T (or to a type derived from T if T is a class type and a conversion function is available) are examined and the best one is selected through overload resolution.
    The result of the conversion, which is a prvalue temporary (until C++17)prvalue expression (since C++17) if a converting constructor was used, is then used to direct-initialize the object.
    The last step is usually optimized out and the result of the conversion is constructed directly in the memory allocated for the target object,
    but the appropriate constructor (move or copy) is required to be accessible even though it's not used. (until C++17) 

    Otherwise (if neither T nor the type of other are class types), standard conversions are used, if necessary, to convert the value of other to the cv-unqualified version of T. 

Notes

Copy-initialization is less permissive than direct-initialization: explicit constructors are not converting constructors and are not considered for copy-initialization.

\begin{lstlisting}
struct Exp { explicit Exp(const char*) {} }; // not convertible from const char*
Exp e1("abc");  // OK
Exp e2 = "abc"; // Error, copy-initialization does not consider explicit constructor
 
struct Imp { Imp(const char*) {} }; // convertible from const char*
Imp i1("abc");  // OK
Imp i2 = "abc"; // OK
\end{lstlisting}
In addition, the implicit conversion in copy-initialization must produce T directly from the initializer,
while, e.g. direct-initialization expects an implicit conversion from the initializer to an argument of T's constructor.

\begin{lstlisting}
struct S { S(std::string) {} }; // implicitly convertible from std::string
S s("abc"); // OK: conversion from const char[4] to std::string
S s = "abc"; // Error: no conversion from const char[4] to S
S s = "abc"s; // OK: conversion from std::string to S
\end{lstlisting}
If other is an rvalue expression, move constructor will be selected by overload resolution and called during copy-initialization. There is no such term as move-initialization.

Implicit conversion is defined in terms of copy-initialization: if an object of type T can be copy-initialized with expression E, then E is implicitly convertible to T.

The equals sign, =, in copy-initialization of a named variable is not related to the assignment operator. Assignment operator overloads have no effect on copy-initialization.
Example
\begin{lstlisting}
#include <string>
#include <utility>
#include <memory>
 
struct A 
{
  operator int() { return 12;}
};
 
struct B 
{
  B(int) {}
};
 
int main()
{
    std::string s = "test"; // OK: constructor is non-explicit
    std::string s2 = std::move(s); // this copy-initialization performs a move
 
//  std::unique_ptr<int> p = new int(1); // error: constructor is explicit
    std::unique_ptr<int> p(new int(1)); // OK: direct-initialization
 
 
    int n = 3.14;    // floating-integral conversion
    const int b = n; // const doesn't matter
    int c = b;       // ...either way
 
 
    A a;
    B b0 = 12;
//    B b1 = a; //< error: conversion from 'A' to non-scalar type 'B' requested
    B b2{a};        // < identical, calling A::operator int(), then B::B(int)
    B b3 = {a};     // <
    auto b4 = B{a}; // <
 
//    b0 = a; //< error, assignment operator overload needed 
}

\end{lstlisting}

\subsection{A0.4 Inheritance and access specifiers}
\paragraph{Public inheritance}

Public inheritance is by far the most commonly used type of inheritance. In fact, very rarely will you see or use the other types of inheritance,
so your primary focus should be on understanding this section. Fortunately, public inheritance is also the easiest to understand. When you inherit a base class publicly,
inherited public members stay public, and inherited protected members stay protected.
Inherited private members, which were inaccessible because they were private in the base class, stay inaccessible.

For \textit{base class members,} 

1). visibility to \textcolor{red}{objects}\textit{of base class}, public members are accessible only.

3). visibility to \textcolor{red}{objects}\textit{of derived class}, public members are accessible only.

2). visibility to \textit{derived class}, public and protected members are accessible.

4). visibility to \textit{the second derived class, AKA, derived derived class}, public and protected members are accessible.
\begin{lstlisting}[caption={Public inheritance exmaple }, language=C++]
class Base
{
    public:
        int m_public;
    private:
        int m_private;
    protected:
        int m_protected;
};
 
class Pub: public Base // 2). Pub is derived class with public inheritance
{
public:
    Pub()
    {
    // Public inherited members stay public (so m_public is treated as public)
        m_public = 1; // okay: m_public was inherited as public
    // Private inherited members stay inaccessible (so m_private is inaccessible)
        m_private = 2; // Error: m_private is inaccessible from derived class
    // Protected inherited members stay protected (so m_protected is treated as protected)
        m_protected = 3; // okay: m_protected was inherited as protected
    }
};
 
int main()
{
    // Outside access uses the access specifiers of the class being accessed.
    Base base; //1). base is a object of Base class
    base.m_public = 1; // okay: m_public is public in Base
    base.m_private = 2; // Error: m_private is private in Base, see 1)
    base.m_protected = 3; // Error: m_protected is protected in Base, see 1)
 
    Pub pub; //3). pub is a object of derived class
    pub.m_public = 1; // okay: m_public is public in Pub
    pub.m_private = 2; // Error: m_private is inaccessible in Pub, see 3)
    pub.m_protected = 3; // Error: m_protected is protected in Pub, see 3)
}
\end{lstlisting}

\paragraph{Protected inheritance}
It is almost never used, except in very particular cases. With protected inheritance, the public and protected members become protected, and private members stay inaccessible.

For \textit{base class members,}

1). visibility to \textit{\textcolor{red}{objects} of base class}, public members are accessible only (same as public inheritance).

3). visibility to \textit{\textcolor{red}{objects} of derived class}, No members is accessible (same as private inheritance).

2). visibility to \textit{derived class}, public and protected members are accessible(same as public inheritance).

4). visibility to \textit{the second derived class, i.e., derived derived class}, public and protected members are accessible (same as public inheritance, difference from private inheritance).
\begin{lstlisting}[caption={Protected inheritance exmaple}, language=C++]
class Base
{
    public:
        int m_public;
    private:
        int m_private;
    protected:
        int m_protected;
};
 
class Pro: protected Base // 2). Pro is derived class with Protected inheritance
{
  public:
   Pro()
    {
    // Public inherited members become private (so m_public is treated as private)
        m_public = 1; // okay: m_public is now private in Pri
    // Private inherited members stay inaccessible (so m_private is inaccessible)
        m_private = 2; // NOT okay: derived classes can't access private members in the base class
    // Protected inherited members become private (so m_protected is treated as private)
        m_protected = 3; // okay: m_protected is now private in Pri
    }
};
 
int main()
{
    // Outside access uses the access specifiers of the class being accessed.
    // In this case, the access specifiers of base.
    Base base;// 1). base is a object of Base
    base.m_public = 1; // okay: m_public is public in Base
    base.m_private = 2; // NOT okay: m_private is private in Base
    base.m_protected = 3; // NOT okay: m_protected is protected in Base
 
    Pro pro;// 3). pro is a object of derived class
    pro.m_public = 1; // NOT okay: m_public is now inaccessible in Pro
    pro.m_private = 2; // NOT okay: m_private is inaccessible in Pro
    pro.m_protected = 3; // NOT okay: m_protected is now private in Pro
}
\end{lstlisting}

\paragraph{Private inheritance}
With private inheritance, all members from the base class are inherited as private. This means private members stay private, and protected and public members become private.

Note that this does not affect the way that the derived class accesses members inherited from its parent! It only affects the code trying to access those members through the derived class.
For \textit{base class members,}

1). visibility to \textit{\textit{red}{objects} of base class}, public members are accessible (same as public and protected inheritance). 

3). visibility to \textit{\textit{red}{objects} of derived class}, NO members is accessible (same as protected inheritance).

2). visibility to \textit{derived class}, public and protected members are accessible (same as public and protected inheritance).

4). visibility to \textit{the second derived class}, NO members are accessible.
\begin{lstlisting}[caption={Private inheritance exmaple }, language=C++]
class Base
{
    public: int m_public;
    private: int m_private;
    protected: int m_protected;
};
 
class Pri: private Base // 2). Pri is derived class with private inheritance
{
  public:
    Pri()
    {
    // Public inherited members become private (so m_public is treated as private)
        m_public = 1; // okay: m_public is now private in Pri
    // Private inherited members stay inaccessible (so m_private is inaccessible)
        m_private = 2; // NOT okay: derived classes can't access private members in the base class
    // Protected inherited members become private (so m_protected is treated as private)
        m_protected = 3; // okay: m_protected is now private in Pri
    }
};
 
int main()
{
    // Outside access uses the access specifiers of the class being accessed.
    // In this case, the access specifiers of base.
    Base base;// 1). base is a object of Base
    base.m_public = 1; // okay: m_public is public in Base
    base.m_private = 2; // NOT okay: m_private is private in Base
    base.m_protected = 3; // NOT okay: m_protected is protected in Base
 
    Pri pri;// 3). pri is a object of derived class
    pri.m_public = 1; // NOT okay: m_public is now private in Pri
    pri.m_private = 2; // NOT okay: m_private is inaccessible in Pri
    pri.m_protected = 3; // NOT okay: m_protected is now private in Pri
}
\end{lstlisting}
\textbf{Private inheritance} models an \textit{IS-IMPLEMENTED-USING} relationship (or whatever that's called). With
\begin{verbatim}
class B {};
class D : private B {};
\end{verbatim}

a D is not a B, but every D uses its B in its implementation. Private inheritance can always be eliminated by using containment instead:

\begin{verbatim}
class B {};
class D {
  private: 
    B b_;
};
\end{verbatim}

This D, too, can be implemented using B, in this case using its b\_.
Containment is a less tight coupling between types than inheritance, so in general it should be preferred.
Sometimes using containment instead of private inheritance is not as convenient as private inheritance. Often that's a lame excuse for being lazy. 
\subparagraph{Private Inheritance is one of the ways of implementing the has-a relationship.}
With private inheritance, public and protected member of the base class become private members of the derived class.
That means the \textit{public and protected methods} of the base class do not become the public interface of the derived object.
However, they can be used inside the member functions of the derived class.

Because there are implications of using private inheritance, in his book, "Effective C++ 55 ...",
Scott Meyers gave a separate item for private inheritance: item 39: "Use private inheritance judiciously."
Let's briefly look at the head of that section showing \textit{not is-a but has-a} property of private inheritance.

\begin{lstlisting}[caption={Private inheritance exmaple 2}, language=C++]
class Person {};
class Student:private Person {};	// student is private inheritance
void eat(const Person& p){}		// person can eat
void study(const Student& s){}		// only students study

int main() 
{
	Person p;	// p is a Person
	Student s;	// s is a Student
	eat(p);		// fine, p is a Person
	eat(s);		// error! s isn't a Person
	return 0;
}
\end{lstlisting}

He explains, in contrast to public inheritance,
compilers will generally not convert a derived class object (Student) into a base class object (Person) if the inheritance relationship between the classes is private.
That's why the call to eat() fails for the object ``s''.

With public inheritance, the public methods of the base class become public methods of the derived class.
In other words, the derived class inherits the base-class interface (the interface is still visible to outside and can use it), This is the ``is-a'' relationship. 
But with the private inheritance, the public methods of the base class become private methods of the derived class,
even if they were protected or public in the base class. So, the derived class does not inherit the base-class interface.

But we should be careful when we talk about private inheritance. Sometimes it is very confusing. The inherit does not mean "own".
Suppose, a parent gave a child a secret recipe for a candy under the condition of not releasing the recipe.
The child can give variety of candies to other people but not the recipe.
With private inheritance, the derived class does enjoy(implement) the inherited interface but does not own the method.
\textit{Therefore, derived class cannot show the interface to outside world.} The only thing that they can show off to the outside is the product whose inner secret workings are hidden.

A class does inherit the implementation with private inheritance.

In his new book, "Programming Principles and Practice Using C++", Stroustrup described the implementation and interface as follows:
The interface is the part of the class's declaration that its users access directly.
The implementation is the part of the class's declaration that its users access only indirectly through the interface.

Let's look at the following example:

\begin{lstlisting}[caption={Private inheritance exmaple 2}, language=C++]
#include <iostream>
using namespace std;

class Engine 
{
 public:
	Engine(int nc){ cylinder = nc; }
	void start() { cout << getCylinder() <<" cylinder engine started" << endl; };
	int getCylinder() { return cylinder; }
private:
	int cylinder;
 };
 
class Car : private Engine // Car has-a Engine
{
 public:
   Car(int nc = 4) : Engine(nc) { }        
   void start() {
	cout << "car with " << Engine::getCylinder() << " cylinder engine started" << endl;
	Engine:: start();
   }
}; 

int main( ) 
{ 
	Car c(8);
	c.start();
	return 0; 
}
\end{lstlisting}
The output is:
\begin{verbatim}
car with 8 cylinder engine started
8 cylinder engine started
\end{verbatim}

As we see from the example, the Car class winds up with an inherited Engine component such as cylinder and the Car method can use the Engine method,
getCylinder(), internally to access the Engine component, cylinder.

In short, private inheritance does acquire the implementation, but does not acquire interface.

From Scott Meyers'book :

    ``Private inheritance is most likely to be a legitimate design strategy when you're dealing with two classes not related by ``is-a'' where
    one either needs access to the protected members of another or needs to redefine one or more its virtual functions.''

    "Private inheritance means ``is-implemented-in-terms-of''. It's usually inferior to composition"

    "If you make a class D privately inherit from a class B, you do so because you are interested in taking advantage of some of the features available in class B,
    not because there is any conceptual relationship between objects of types B and D."

    "Private inheritance means nothing during software design, only during software implementation."

\subparagraph{Composition}

As you may know, the private inheritance is a variant of composition, aggregation, or containment. So, the ``has-a'' relationship can be achieved using composition as in the example below.

\begin{lstlisting}[caption={Private inheritance exmaple 3 Composition}, language=C++]
#include <iostream>
using namespace std;

class Engine 
{
 public:
	Engine(int nc){ cylinder = nc; }
	void start() { cout << getCylinder() <<" cylinder engine started" << endl; };
	int getCylinder() { return cylinder; }
private:
	int cylinder;
 };
 
class Car 
{
 public:
	Car(int n = 4): eng(n) { }	

	void start() {
	   cout << "car with " << eng.getCylinder() <<
		   " cylinder engine started" << endl;
		eng.start();
	}
private:
	Engine eng;	// Car has-a Engine
 }; 

int main( ) 
{ 
	Car c(8);
	c.start();
	return 0; 
}
\end{lstlisting}

This produced the same output as the example for private inheritance.
\begin{verbatim}
car with 8 cylinder engine started
8 cylinder engine started
\end{verbatim}

\subparagraph{Composition vs. Private Inheritance}

So, what are the similarities and differences between private inheritance and composition?

\textbf{    Similarities}

        In both cases, there is exactly one Engine member object contained in every Car object.

        In both cases the Car class has a start() method that calls the start() method on the contained Engine object.

        In neither case can users (outsiders) convert a ``Car*'' to an ``Engine*''.

    \textbf{differences}

        The composition is needed if you want to contain several Engines per Car.

        The private inheritance can introduce unnecessary multiple inheritance.

        The private inheritance allows members of Car to convert a Car* to an Engine*.

        The private inheritance allows access to the protected members of the base class.

        The private inheritance allows Car to override Engine's virtual functions.

Let's look at the following example which shows the transitions of designs from private inheritance to composition.

Private inheritance lets us inherit the functionality, but not the public interface of another class. In the following code, Circle does not expose any of the member functions of Ellipse.

\begin{lstlisting}
class Circle : private Ellipse
{
public:
	Circle();
	explicit Circle(float r);

	void setRadius(float r);
	float getRadius() const;
};
\end{lstlisting}

But objects of type Circle cannot be passed to code that accepts an Ellipse because the Ellipse base type is not publicly accessible.
If we really want to expose a public or protected method of Ellipse in Circle, then we can do this as in the example below:

\begin{lstlisting}
class Circle : private Ellipse
{
public:
	Circle();
	explicit Circle(float r);

	using Ellipse::getMajorRadius;
	using Ellipse::getMinorRadius;

	void setRadius(float r);
	float getRadius() const;
};
\end{lstlisting}

However, preferred is to use composition. 
This simply means that instead of class A inheriting from B, A declares B as a private data member (has-a) or A declares a pointer or reference to B as a member variable (holds-a):

\begin{lstlisting}
class Circle
{
public:
	Circle();
	explicit Circle(float r);

	void setRadius(float r);
	float getRadius() const;

private:
	Ellipse mEllipse:
};

void Circle::setRadius(float r)
{
	mEllipse.setMajorRadius(r);
	mEllipse.setMinorRadius(r);
}

float Circle::getRadius() const
{
	return mEllipse.getMajorRadius();
}
\end{lstlisting}

The interface for Ellipse is not exposed in the interface for Circle, however, Circle still builds upon the functionality of Ellipse by creating a private instance of Ellipse.
Therefore, composition provides the functional equivalent of private inheritance.

\textit{Use compostion over private inheritance because inheritance produces a more tightly coupled design.}

\textbf{Which should I prefer: composition or private inheritance?}

Given that we can achieve a has-a relationship either with composition or with private inheritance, which should we use? Use composition when you can, but use private inheritance when you have to.

When we look at the class declaration, we see explicitly named objects representing the contained classes, and our code can refer to these objects by name.
While the private inheritance makes the relationship seem more abstract. Also, inheritance can raise problems of multi-inheritance.

In short, we're less likely to run into trouble if we use composition. Also, as we summarized in the previous section, composition allows us to include several objects.

On the other hand, private inheritance does offer features that composition can't. Suppose, for example, that a class has protected members.
Such members are available to derived classes but not to the world.
If we include such a class in another class by using composition, the new class becomes part of that world, not a derived class.
So, it can't access protected members. But by using inheritance makes the new class a derived class, so it can access protected members.

Another case that gives private inheritance advantage is if we want to redefine virtual functions. This is a privilege awarded to a derived class but not to a containing class.

\textbf{Summary}

I'll use Scott Meyers' statements as a summary, Private inheritance means ``is-implemented-in-terms-of''.
If you make a class D privately inherit from a class B, you do so because you are interested in taking advantage of some of the features available in class B,
not because there is any conceptual relationship between objects of types B and D.
As such, private inheritance is purely an implementation technique.
(That's why everything you inherit from a private base class becomes private in your class: it's all just implementation detail.)
....
private inheritance means that implementation only should be inherited; interface should be ignored.
If D privately inherits from B, it means that D objects are implemented in terms of B objects, nothing more.
Private inheritance means nothing during software design, only during software implementation.

\section{Appendix A1 more Concepts}
\subsection{A1.1 Coupling And Cohesion}
\url{http://wiki.c2.com/?CouplingAndCohesion}
Given two lines of code, A and B, they are coupled when B must change behavior only because A changed.

They are cohesive when a change to A allows B to change so that both add new value. 
\subsection{A1.2 Reflection}\label{reflectionincpp}
%\url{http://donw.io/post/reflection-cpp-1/}
\paragraph{What is Reflection?}\mbox{}
A reflection API is a very basic, powerful tool that every game studio should have at their disposal. It normally contains some or all of the following features:

    A database of types and their inheritance relationship with each other.

    A means of creating objects of a specific type by name.

    A list of data member descriptions for each type, with name/type/offset tuples.

    A database of enumeration types and their associated key/value pairs.

    A database of functions/methods with their return types and parameter lists.

    A means of calling functions/methods by name at runtime with an arbtrarily constructed parameter list.

    A database of properties represented as Get/Set method pairs that externally look like a named value.

    A database of attributes that can be attached to any of the above, describing how they should be used.

Each language has varying levels of support for reflection, while C++ has RTTI. You can do various things with RTTI but it’s an incredibly limited system that only gives you:

    The ability to discover an object’s type at runtime through the typeid operator.

    A typeid operator that can also be applied to types themselves.

    A type’s name, its hash code and some comparison functions.

    Runtime downcasting and similar operations through dynamic\_cast.

This is not nearly enough! RTTI also has varying levels of support between compilers and type names are implementation specific.

So why would you want reflection? Perhaps it’s best to list a few things that it can enable:

    Serialisation of any game type.

    Transparent implementations of various backend data formats with one point of serialisation for any given format.

    Versionable serialisation of any data.

    Inspect game state of any object at runtime for debugging.

    Dependency tracking with the pointer graph (ever wanted to know what objects are dependent on another before deleting?).

    Reloadable resource (mesh, texture, script, etc) reference updating.

    Automatically populate and describe user interfaces for editing tools.

    Binding to arbitrary programming languages (Lua, C\#, Python, etc.) through minimal translation layers.

    Network communication/replication through serialisation and RPC.

    Memory mapping of data formats with post-load pointer patching.

    Live C++ code editing.

    Garbage collection or defragmentable memory heaps (useful on systems where the GPU uses physical addressing).

You can of course build individual systems for each of these but they all share the same need to register type data and access it offline or at runtime.
Using reflection for these systems can either make everything easier to understand and maintain or obfuscate intent and lead to a brittle code base.
As such, a clean and simple reflection API is absolutely vital if you intend to adopt one.

Generating a reflection database can be done in any number of different ways with C++, including:

    Using macros to simultaneously annotate your code and generate registration calls.

    Using templates and meta-programming techniques to achieve the same goal.

    Using a hybrid of the above or even doing it non-intrusively. Collectively these are runtime databases with no offline representation.

    Using an IDL/DDL compiler to generate cpp/h files containing C++ equivalents and registration code. This can also generate an offline representation of your database that can be used in tools.

    Using an existing language that already has reflection to describe your data/interfaces to achieve the same as the previous method (C\# is a good candidate for this).

    Performing a pre/post process on your C++ code using a custom parser that picks up interesting information.

    Inspecting debug information emitted by the compiler.

There are many tradeoffs with each technique and covering each is beyond the scope of these posts. However, the use-cases should be broad enough to show how varied implementations can be.
\section{Appendix B rules}
\subsection{B1.1 Composition over Inheritance}\label{copi}

Prefer composition over inheritance as it is more malleable / easy to modify later, but do not use a compose-always approach.
With composition, it's easy to change behavior on the fly with Dependency Injection / Setters.
Inheritance is more rigid as most languages do not allow you to derive from more than one type.
So the goose is more or less cooked once you derive from TypeA.

My acid test for the above is:

    Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates Inheritance.

e.g. A Cessna biplane will expose the complete interface of an airplane, if not more. So that makes it fit to derive from Airplane.

    Does TypeB want only some/part of the behavior exposed by TypeA? Indicates need for Composition.

e.g. A Bird may need only the fly behavior of an Airplane. In this case, it makes sense to extract it out as an interface / class / both and make it a member of both classes.

Update: Just came back to my answer and it seems now that it is incomplete without a specific mention of Barbara Liskov's Liskov Substitution Principle~\ref{LSP}
as a test for 'Should I be inheriting from this type?'


\subsection{B1.2 Inversion Of Control - IOC}\label{IOC}
Inversion of Control is a common phenomenon that you come across when extending frameworks. Indeed it's often seen as a defining characteristic of a framework.

Let's consider a simple example. Imagine I'm writing a program to get some information from a user and I'm using a command line enquiry. I might do it something like this

\begin{lstlisting}
typedef int X::*my_pointer_to_member;
  #ruby
  puts 'What is your name?'
  name = gets
  process_name(name)
  puts 'What is your quest?'
  quest = gets
  process_quest(quest)
\end{lstlisting}
In this interaction, my code is in control: it decides when to ask questions, when to read responses, and when to process those results.

However if I were were to use a windowing system to do something like this, I would do it by configuring a window.

\begin{lstlisting}
typedef int X::*my_pointer_to_member;
  require 'tk'
  root = TkRoot.new()
  name_label = TkLabel.new() {text "What is Your Name?"}
  name_label.pack
  name = TkEntry.new(root).pack
  name.bind("FocusOut") {process_name(name)}
  quest_label = TkLabel.new() {text "What is Your Quest?"}
  quest_label.pack
  quest = TkEntry.new(root).pack
  quest.bind("FocusOut") {process_quest(quest)}
  Tk.mainloop()
\end{lstlisting}
There's a big difference now in the flow of control between these programs $-$ in particular the control of when the ``process\_name'' and ``process\_quest'' methods are called.
In the command line form I control when these methods are called, but in the window example I don't. 
Instead I hand control over to the windowing system (with the Tk.mainloop command).
It then decides when to call my methods, based on the bindings I made when creating the form. 
The control is inverted - it calls me rather me calling the framework. 
This phenomenon is Inversion of Control (also known as the Hollywood Principle - "Don't call us, we'll call you").

    One important characteristic of a framework is that the methods defined by the user to tailor the framework will often be called from within the framework itself, 
    rather than from the user's application code.
    The framework often plays the role of the main program in coordinating and sequencing application activity. 
    This inversion of control gives frameworks the power to serve as extensible skeletons.
    The methods supplied by the user tailor the generic algorithms defined in the framework for a particular application.

    -- Ralph Johnson and Brian Foote

Inversion of Control is a key part of what makes a framework different to a library. 
A library is essentially a set of functions that you can call, these days usually organized into classes.
Each call does some work and returns control to the client.

A framework embodies some abstract design, with more behavior built in.
In order to use it you need to insert your behavior into various places in the framework either by subclassing or by plugging in your own classes. 
The framework's code then calls your code at these points.

There are various ways you can plug your code in to be called. 
In the ruby example above, we invoke a bind method on the text entry field that passes an event name and a Lambda as an argument.
Whenever the text entry box detects the event, it calls the code in the closure. Using closures like this is very convenient, but many languages don't support them.

Another way to do this is to have the framework define events and have the client code subscribe to these events.
``.NET'' is a good example of a platform that has language features to allow people to declare events on widgets.
You can then bind a method to the event by using a delegate.

The above approaches (they are really the same) work well for single cases, but sometimes you want to combine several required method calls in a single unit of extension.
In this case the framework can define an interface that a client code must implement for the relevant calls.

EJBs are a good example of this style of inversion of control. 
When you develop a session bean, you can implement various methods that are called by the EJB container at various lifecyle points.
For example the Session Bean interface defines ejbRemove, ejbPassivate (stored to secondary storage), and ejbActivate (restored from passive state).
You don't get to control when these methods are called, just what they do. The container calls us, we don't call it.

These are complicated cases of inversion of control, but you run into this effect in much simpler situations.
A template method is a good example: the super-class defines the flow of control, subclasses extend this overriding methods or implementing abstract methods to do the extension.
So in JUnit, the framework code calls setUp and tearDown methods for you to create and clean up your text fixture. It does the calling, your code reacts - so again control is inverted.

There is some confusion these days over the meaning of inversion of control due to the rise of IoC containers;
some people confuse the general principle here with the specific styles of inversion of control (such as dependency injection)
that these containers use. The name is somewhat confusing (and ironic) since IoC containers are generally regarded as a competitor to EJB,
yet EJB uses inversion of control just as much (if not more).

Etymology: As far as I can tell, the term Inversion of Control first came to light in Johnson and Foote's paper Designing Reusable Classes,
published by the Journal of Object-Oriented Programming in 1988.
The paper is one of those that's aged well - it's well worth a read now over fifteen years later. They think they got the term from somewhere else, but can't remember what.
The term then insinuated itself into the object-oriented community and appears in the Gang of Four book.
The more colorful synonym ``Hollywood Principle'' seems to originate in a paper by Richard Sweet on Mesa in 1983. 
In a list of design goals he writes: ``Don't call us, we'll call you (Hollywood's Law):
A tool should arrange for Tajo to notify it when the user wishes to communicate some event to the tool,
rather than adopt an ``ask the user for a command and execute it'' model.''
John Vlissides wrote a column for C++ report that provides a good explanation of the concept under the ``Hollywood Principle'' moniker.
(Thanks to Brian Foote and Ralph Johnson for helping me with the Etymology.)



\section{Appendix C0: SOLID Principles}\label{ac0sp}
\subsection{C0.1 SRP: Single Responsibility Principle}\label{SRP}
The single responsibility principle is a computer programming principle that states that every module or class should 
have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class.
All its services should be narrowly aligned with that responsibility.
Robert C. Martin expresses the principle as, ``A class should have only one reason to change.''

\paragraph{Exmaple}
Let's assume we need an object to keep an email message. We are going to use the IEmail interface from the below sample.
At the first sight everything looks just fine. At a closer look we can see that our IEmail interface and Email class have 2 responsibilities (reasons to change).
One would be the use of the class in some email protocols such as pop3 or imap.
If other protocols must be supported the objects should be serialized in another manner and code should be added to support new protocols.
Another one would be for the Content field. Even if content is a string maybe we want in the future to support HTML or other formats.

If we keep only one class, each change for a responsibility might affect the other one:

    Adding a new protocol will create the need to add code for parsing and serializing the content for each type of field.

    Adding a new content type (like html) make us to add code for each protocol implemented.


\begin{lstlisting}[caption={single responsibility principle - bad example}, language=C++]
class IEmail {
    public:
    virtual void setSender(String sender)  = 0;
	virtual void setReceiver(String receiver) = 0;
	virtual void setContent(String content) = 0;
}

class Email : public IEmail {
    public:
    virtual void setSender(String sender) {// set sender; }
	virtual void setReceiver(String receiver) {// set receiver; }
	virtual void setContent(String content) {// set content; }
}
\end{lstlisting}

We can create a new interface and class called IContent and Content to split the responsibilities. Having only one responsibility for each class give us a more flexible design:

    adding a new protocol causes changes only in the Email class.

    adding a new type of content supported causes changes only in Content class.
 

\begin{lstlisting}[caption={single responsibility principle - good example}, language=C++]
class IEmail {
    public:
   virtual void setSender(String sender) = 0;
	virtual void setReceiver(String receiver) = 0;
	virtual void setContent(IContent content) = 0;
};

class Content {
    public:
    virtual String getAsString(); // used for serialization
};

class Email: public IEmail {
    public:
    virtual void setSender(String sender) {// set sender; }
	virtual void setReceiver(String receiver) {// set receiver; }
	virtual void setContent(IContent content) {// set content; }
}
\end{lstlisting}
\subsection{C0.2 OCP: Open for extension,Closed for modification principle}\label{OCP}
%\subsection{OCP: Software Entities Should Be Open For Extension, Yet Closed For Modification}\label{OCP}
\paragraph{Meyer's open/closed principle}

Bertrand Meyer is generally credited for having originated the term open/closed principle,[2] which appeared in his 1988 book Object Oriented Software Construction.

        A module will be said to be \textbf{open} if it is still available for extension. For example, it should be possible to add fields to the data structures it contains,
        or new elements to the set of functions it performs.
        A module will be said to be \textbf{closed} if it is available for use by other modules. This assumes that the module has been given a well-defined,
        stable description (the interface in the sense of information hiding).

At the time Meyer was writing, adding fields or functions to a library inevitably required changes to any programs depending on that library.
Meyer's proposed solution to this dilemma relied on the notion of object-oriented inheritance (specifically implementation inheritance):

    A class is closed, since it may be compiled, stored in a library, baselined, and used by client classes.
    But it is also open, since any new class may use it as parent, adding new features.
    When a descendant class is defined, there is no need to change the original or to disturb its clients.

\paragraph{Polymorphic open/closed principle}

During the 1990s, the open/closed principle became popularly redefined to refer to the use of abstracted interfaces,
where the implementations can be changed and multiple implementations could be created and polymorphically substituted for each other.

In contrast to Meyer's usage, this definition advocates inheritance from abstract base classes. Interface specifications can be reused through inheritance but implementation need not be.
The existing interface is closed to modifications and new implementations must, at a minimum, implement that interface.

Robert C. Martin's 1996 article "The Open-Closed Principle" was one of the seminal writings to take this approach.
In 2001 Craig Larman related the open/closed principle to the pattern by Alistair Cockburn called Protected Variations, and to the David Parnas discussion of information hiding.

\paragraph{Example}

Bellow is an example which violates the Open Close Principle. It implements a graphic editor which handles the drawing of different shapes.
It's obviously that it does not follow the Open Close Principle since the GraphicEditor class has to be modified for every new shape class that has to be added.

There are several disadvantages:
1)    for each new shape added the unit testing of the GraphicEditor should be redone.
2)    when a new type of shape is added the time for adding it will be high since the developer who add it should understand the logic of the GraphicEditor.
3)    adding a new shape might affect the existing functionality in an undesired way, even if the new shape works perfectly

In order to have more dramatic effect, just imagine that the Graphic Editor is a big class, with a lot of functionality inside,
written and changed by many developers, while the shape might be a class implemented only by one developer.
In this case it would be great improvement to allow the adding of a new shape without changing the GraphicEditor class.

\begin{lstlisting}[caption={Open-Close Principle - bad example}, language=C++]
 class GraphicEditor {
   public:
     void drawShape(Shape s) {
 		if (s.m_type==1)
 			drawRectangle(s);
 		else if (s.m_type==2)
 			drawCircle(s);
 	}
 	 void drawCircle(Circle r) {....}
 	 void drawRectangle(Rectangle r) {....}
 };
 
 class Shape { int m_type; };
 
 class Rectangle: public  Shape {
 	Rectangle() { this.m_type=1; }
 };
 
 class Circle : public Shape {
 	Circle() { this.m_type=2; }
 } 
\end{lstlisting}

Bellow is a example which supports the Open Close Principle. In the new design we use abstract draw() method in GraphicEditor for drawing objects,
while moving the implementation in the concrete shape objects. Using the Open Close Principle the problems from the previous design are avoided,
because GraphicEditor is not changed when a new shape class is added:

1)    no unit testing required.
 2)   no need to understand the sourcecode from GraphicEditor.
  3)  since the drawing code is moved to the concrete shape classes, it's a reduced risk to affect old functionallity when new functionallity is added.
 
\begin{lstlisting}[caption={Open-Close Principle - good example}, language=C++]
class GraphicEditor {
  public:
     void drawShape(Shape s) { s.draw(); }
 };
 
class Shape {
  public:
 	virtual void draw() =0;
 };
 
 class Rectangle :public Shape  {
  public:
     void draw() {
 		// draw the rectangle
 	}
 };
\end{lstlisting}

\subsection{C0.3 LSP:Liskov Substitution Principle}\label{LSP}
%\url{https://en.wikipedia.org/wiki/Liskov_substitution_principle}
Substitutability is a principle in object-oriented programming stating that, in a computer program, if S is a subtype of T, 
then objects of type T may be replaced with objects of type S (i.e. an object of type T may be substituted with any object of a subtype S) 
without altering any of the desirable properties of T (correctness, task performed, etc.).
More formally, the Liskov substitution principle (LSP) is a particular definition of a subtyping relation,
called (strong) behavioral subtyping, that was initially introduced by Barbara Liskov in a 1987 conference keynote address titled Data abstraction and hierarchy.
It is a semantic rather than merely syntactic relation because it intends to guarantee semantic interoperability of types in a hierarchy, object types in particular.

\textbf{Function That Use Referennces To Base(Super) Classes Must Be Able To Use Objects Of Derived(Sub) Classes Without Knowing It.}

\paragraph{Example}

Below is the classic example for which the Likov's Substitution Principle is violated.
In the example 2 classes are used: Rectangle and Square. Let's assume that the Rectangle object is used somewhere in the application.
We extend the application and add the Square class. The square class is returned by a factory pattern, based on some conditions and we don't know the exact what type of object will be returned.
But we know it's a Rectangle. We get the rectangle object, set the width to 5 and height to 10 and get the area.
For a rectangle with width 5 and height 10 the area should be 50. Instead the result will be 100.

\begin{lstlisting}[caption={Violation of Likov's Substitution Principle}, language=C++]
class Rectangle
{
 public:
    void setWidth(int width){ m_width = width; }
	 void setHeight(int height){ m_height = height; }
    int getWidth(){ return m_width; }
	 int getHeight(){ return m_height; } 
	 int getArea(){ return m_width * m_height; }	
 private:
	 int m_width;
	 int m_height;
};

class Square: public  Rectangle 
{
    public:
    void setWidth(int width){
		m_width = width;
		m_height = width;
	}

	 void setHeight(int height){
		m_width = height;
		m_height = height;
	}
};

class LspTest
{
    private:
    static Rectangle getNewRectangle()
	{
		// it can be an object returned by some factory ... 
		return new Square();
	}
};

int main (String args[])
{
	Rectangle r = LspTest.getNewRectangle();
        
	r.setWidth(5);
	r.setHeight(10);
	// user knows that r it's a rectangle. 
	// It assumes that he's able to set the width and height as for the base class

	System.out.println(r.getArea()); // now he's surprised to see that the area is 100 instead of 50.
}
\end{lstlisting}
\subsection{C0.4 ISP: Interface segregation Principle}\label{ISP}
The interface-segregation principle (ISP) states that no client should be forced to depend on methods it does not use.
ISP splits interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them.
Such shrunken interfaces are also called role interfaces. ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy.
ISP is one of the five SOLID principles of object-oriented design, similar to the High Cohesion Principle of GRASP.

\textbf{When} we design an application we should take care how we are going to make abstract a module which contains several submodules.
Considering the module implemented by a class, we can have an abstraction of the system done in an interface.
But if we want to extend our application adding another module that contains only some of the submodules of the original system,
we are forced to implement the full interface and to write some dummy methods.
Such an interface is named fat interface or polluted interface. Having an interface pollution is not a good solution and might induce inappropriate behavior in the system.

\paragraph{Example}

Below is an example which violates the Interface Segregation Principle. We have a Manager class which represent the person which manages the workers.
And we have 2 types of workers some average and some very efficient workers. Both types of workers works and they need a daily launch break to eat.
But now some robots came in the company they work as well , but they don't eat so they don't need a launch break.
One on side the new Robot class need to implement the IWorker interface because robots works.
On the other side, the don't have to implement it because they don't eat.

This is why in this case the IWorker is considered a polluted interface.

If we keep the present design, the new Robot class is forced to implement the eat method.
We can write a dummy class which does nothing(let's say a launch break of 1 second daily),
and can have undesired effects in the application(For example the reports seen by managers will report more lunches taken than the number of people).

According to the Interface Segregation Principle, a flexible design will not have polluted interfaces. In our case the IWorker interface should be split in 2 different interfaces.

\begin{lstlisting}[caption={interface segregation principle - bad example}]
class IWorker {
    public:
    virtual void work() = 0;
	virtual void eat() = 0;
};

class Worker :public IWorker{
    public:
    void work() { /* ....working */ }
	void eat() { /* ...... eating in launch break*/ }
};

class SuperWorker : public IWorker{
    public:
    void work() { /*.... working much more */ }
	 void eat() { /*.... eating in launch break */ }
};

class Manager {
    public :
        void setWorker(IWorker w) { worker=w; }
    	 void manage() { worker.work(); }
    private:
    	IWorker worker;
};
\end{lstlisting}
Following it's the code supporting the Interface Segregation Principle.
By splitting the IWorker interface in 2 different interfaces the new Robot class is no longer forced to implement the eat method.
Also if we need another functionality for the robot like recharging we create another interface IRechargeble with a method recharge.

\begin{lstlisting}[caption={interface segregation principle - good example}]
class IWorker :public Feedable, public Workable {
};

class IWorkable {
    public: virtual void work() = 0;
};

class IFeedable{
    public: virtual void eat() = 0;
};

class Worker :public IWorkable, public IFeedable{
    public:
        void work() { /* ....working */}
	    void eat() { /*.... eating in launch break */ }
};

class Robot :public IWorkable{
    public: void work() { /* ....working*/ }
};

class SuperWorker : public IWorkable, public IFeedable{
    public:
    void work() { /*.... working much more*/ }
	 void eat() { /*.... eating in launch break*/ }
};

class Manager {
	Workable worker;

    public:
    void setWorker(Workable w) { worker=w; }
	 void manage() { worker.work(); }
};
\end{lstlisting}

\subsection{C0.5 DIP: Dependence Inversion Principle}
In object-oriented design, the dependency inversion principle refers to a specific form of decoupling software modules.
When following this principle, the conventional dependency relationships established from high-level, policy-setting modules to low-level,
dependency modules are reversed, thus rendering high-level modules independent of the low-level module implementation details. The principle states:

        A. High-level modules should not depend on low-level modules. Both should depend on abstractions.

        B. Abstractions should not depend on details. Details should depend on abstractions.

By dictating that both high-level and low-level objects must depend on the same abstraction this design principle inverts the way some people may think about object-oriented programming.

The idea behind points A and B of this principle is that when designing the interaction between a high-level module and a low-level one, the interaction should be thought of
as an abstract interaction between them.  This not only has implications on the design of the high-level module, but also on the low-level one:
the low-level one should be designed with the interaction in mind and it may be necessary to change its usage interface.

In many cases, thinking about the interaction in itself as an abstract concept allows the coupling of the components to be reduced without introducing additional coding patterns,
allowing only a lighter and less implementation dependent interaction schema.

When the discovered abstract interaction schema(s) between two modules is/are generic and generalization makes sense,
this design principle also leads to the following dependency inversion coding pattern.
\subsection{C0.6 KLP: Least Knowledge Principle or LOD: Law of Demeter}

\section{Appendix C1 Other Principles}
\subsection{C1.1 Favor Composition Over Inheritance}
\url{http://blog.csdn.net/woxiaozhi/article/details/6634382}
\subsection{C1.2 Program To An Interface, Not An Implementation}
\subsection{C1.3 DRY: Don't Repeat Yourslef}\label{DRY}
\paragraph{Wikipedia -} In software engineering, don't repeat yourself (DRY) is a principle of software development aimed at reducing repetition of software patterns,
replacing them with abstractions; and several copies of the same data, using data normalization to avoid redundancy.

The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system".
The principle has been formulated by Andy Hunt and Dave Thomas in their book The Pragmatic Programmer.
They apply it quite broadly to include "database schemas, test plans, the build system, even documentation".[1]
When the DRY principle is applied successfully, a modification of any single element of a system does not require a change in other logically unrelated elements.
Additionally, elements that are logically related all change predictably and uniformly, and are thus kept in sync.
Besides using methods and subroutines in their code, Thomas and Hunt rely on code generators, automatic build systems, and scripting languages to observe the DRY principle across layers.
\paragraph{DRY vs WET solutions}
Violations of DRY are typically referred to as WET solutions, which is commonly taken to stand for either "Write Everything Twice", "we enjoy typing" or "waste everyone's time".
WET solutions are common in multi-tiered architectures where a developer may be tasked with, for example, adding a comment field on a form in a web application.
The text string "comment" might be repeated in the label, the HTML tag, in a read function name, a private variable, database DDL, queries, and so on.
A DRY approach eliminates that redundancy by leveraging frameworks that reduce or eliminate all those edit tasks excepting the most important one,
leaving the extensibility of adding new knowledge variables in one place.[2][3][4]
\subsection{C1.4 Rule of three}\label{ROT}
Rule of three is a code refactoring rule of thumb to decide when a replicated piece of code should be replaced by a new procedure.
It states that the code can be copied once, but that when the same code is used three times, it should be extracted into a new procedure.
The rule was introduced by Martin Fowler in Refactoring[1] and attributed to Don Roberts.

Duplication in programming is a bad practice because it makes the code harder to maintain.
When the rule encoded in a replicated piece of code changes, whoever maintains the code will have to change it in all places correctly.
This process is error-prone and often leads to problems.
Triplication has an even higher cost because it makes maintenance harder yet.
If the code exists in only one place, then it can be easily changed there.

However, refactoring code to eliminate duplication takes time, which might be better spent on other tasks.
Additionally, choosing a good design to refactor code into becomes easier when there are more examples of duplicated code to see patterns in.
With three examples of similar code, it is easier than with two examples to see what parts of the code should be abstracted and what parts should be the same in all cases.

The rule proposes that the cost of maintenance certainly outweighs the cost of refactoring and potential bad design when there are three copies, and may or may not if there are two copies.

As Charles Petzold puts it, "Three or more? Use a for!"[2] [3]
\subsection{C1.4.2 Rule of three in C++}\label{ROTC}
The rule of three (also known as the Law of The Big Three or The Big Three) is a rule of thumb in C++ (prior to C++11) that claims that if
a class defines one (or more) of the following it should probably explicitly define all three:

    \textbf{destructor,
    copy constructor,
    copy assignment operator}

These three functions are special member functions.
If one of these functions is used without first being declared by the programmer it will be implicitly implemented by the compiler with the following default semantics:

    Destructor – Call the destructors of all the object's class-type members
    Copy constructor – Construct all the object's members from the corresponding members of the copy constructor's argument, 
                    calling the copy constructors of the object's class-type members, and doing a plain assignment of all non-class type (e.g., int or pointer) data members
    Copy assignment operator – Assign all the object's members from the corresponding members of the assignment operator's argument, 
                    calling the copy assignment operators of the object's class-type members, and doing a plain assignment of all non-class type (e.g. int or pointer) data members.

The Rule of Three claims that if one of these had to be defined by the programmer,
it means that the compiler-generated version does not fit the needs of the class in one case and it will probably not fit in the other cases either.
The term "Rule of three" was coined by Marshall Cline in 1991.[2]

An amendment to this rule is that if the class is designed in such a way that Resource Acquisition Is Initialization (RAII) is used for all its (nontrivial) members,
the destructor may be left undefined (also known as The Law of The Big Two[3]). A ready-to-go example of this approach is the use of smart pointers instead of plain ones. [3]

Because implicitly-generated constructors and assignment operators simply copy all class data members ("shallow copy"),[4]
one should define explicit copy constructors and copy assignment operators for classes that encapsulate complex data structures or have external references such as pointers,
if you need to copy the objects pointed to by the class members. If the default behavior ("shallow copy") is actually the intended one,
then an explicit definition, although redundant, will be a "self-documenting code" indicating that it was an intention rather than an oversight.
\subsection{C1.4.3 Rule of Five}\label{ROF}
With the advent of C++11 the rule of three can be broadened to the rule of five as C++11 implements move semantics,[5]
allowing destination objects to grab (or steal) data from temporary objects. 
The following example also shows the new moving members: move constructor and move assignment operator.
Consequently, for the rule of five we have the following special members:
    \textbf{
    destructor,
    copy constructor,
    move constructor,
    copy assignment operator,
    move assignment operator }

Situations exist where classes may need destructors, but cannot sensibly implement copy and move constructors and copy and move assignment operators.
This happens, for example, when the base class does not support these latter Big Four members, but the derived class's constructor allocates memory for its own use.
In C++11, this can be simplified by explicitly specifying the five members as default.[6]
\begin{lstlisting}
#include <cstring>
#include <iostream>

class Foo
{
public:
    /** Default constructor */
    Foo() : data (new char[14])
    {
        std::strcpy(data, "Hello, World!");
    }

    /** Copy constructor */
    Foo (const Foo& other) :
        data (new char[std::strlen (other.data) + 1])
    {
        std::strcpy(data, other.data);
    }

    /** Move constructor */
    Foo (Foo&& other) noexcept : /* noexcept needed to enable optimizations in containers */
        data(other.data)
    {
        other.data = nullptr;
    }

    /** Destructor */
    ~Foo() noexcept /* explicitly specified destructors should be annotated noexcept as best-practice */
    {
        delete[] data;
    }

    /** Copy assignment operator */
    Foo& operator= (const Foo& other)
    {
        Foo tmp(other);         // re-use copy-constructor
        *this = std::move(tmp); // re-use move-assignment
        return *this;
    }

    /** Move assignment operator */
    Foo& operator= (Foo&& other) noexcept
    {
        if (this == &other)
        {
            // take precautions against `foo = std::move(foo)`
            return *this;
        }
        delete[] data;
        data = other.data;
        other.data = nullptr;
        return *this;
    }

private:
    friend std::ostream& operator<< (std::ostream& os, const Foo& foo)
    {
        os << foo.data;
        return os;
    }

    char* data;
};
 
int main()
{
    const Foo foo;
    std::cout << foo << std::endl;

    return 0;
}
\end{lstlisting}
\subsection{C1.4.4 Rule of zero}\label{ROZ}
Classes that have custom destructors, copy/move constructors or copy/move assignment operators should deal exclusively with ownership (which follows from the Single Responsibility Principle).
Other classes should not have custom destructors, copy/move constructors or copy/move assignment operators.[1]
\begin{lstlisting}
class rule_of_zero
{
    std::string cppstring;
 public:
    rule_of_zero(const std::string& arg) : cppstring(arg) {}
};
\end{lstlisting}
When a base class is intended for polymorphic use, its destructor may have to be declared public and virtual.
This blocks implicit moves (and deprecates implicit copies), and so the special member functions have to be declared as defaulted[2]
\begin{lstlisting}
class base_of_five_defaults
{
 public:
    base_of_five_defaults(const base_of_five_defaults&) = default;
    base_of_five_defaults(base_of_five_defaults&&) = default;
    base_of_five_defaults& operator=(const base_of_five_defaults&) = default;
    base_of_five_defaults& operator=(base_of_five_defaults&&) = default;
    virtual ~base_of_five_defaults() = default;
};
\end{lstlisting}
however, this can be avoided if the objects of the derived class are not dynamically allocated, or are dynamically allocated
only to be stored in a std::shared\_ptr (such as by std::make\_shared): shared pointers invoke the derived class destructor even after casting to std::shared\_ptr<Base>. 
\subsection{C1.5 OAOO: Once And Only Once}\label{OAOO}
One of the main goals (if not the main goal) when ReFactoring code. Each and every declaration of behavior should appear OnceAndOnlyOnce.
Conceptually analogous to normalization in the RelationalModel. See also DontRepeatYourself~\ref{DRY}. 
\subsection{C1.6 Separation of concerns (high cohesion/low coupling)}\label{SOC}
PDFConverter class now knows nothing about the conversion algorithms used in the application,
its main concern is to serve the clients with the various conversion features regardless how the conversion is being done.
Now that we’re able anytime to replace our low level conversion framework and no one would even know as long as we’re returning the expected result.
\section{Appendix C2: More }
\subsection{C2.1 Single Source of Truth}\label{SSOT}
\paragraph{Wikipedia -} 
In information systems design and theory, single source of truth (SSOT), is the practice of structuring information models and associated schemata such that every data element is stored exactly once.
Any possible linkages to this data element (possibly in other areas of the relational schema or even in distant federated databases) are by reference only.
Because all other locations of the data just refer back to the primary "source of truth" location,
updates to the data element in the primary location propagate to the entire system without the possibility of a duplicate value somewhere being forgotten.

Deployment of an SSOT architecture is becoming increasingly important in enterprise settings where incorrectly linked duplicate
or de-normalized data elements (a direct consequence of intentional or unintentional denormalization of any explicit data model) pose a risk for retrieval of outdated,
and therefore incorrect, information.
A common example would be the electronic health record, where it is imperative to accurately validate patient identity against a single referential repository, which serves as the SSOT.
Duplicate representations of data within the enterprise would be implemented by the use of pointers rather than duplicate database tables, rows, or cells.
This ensures that data updates to elements in the authoritative location are comprehensively distributed to all federated database constituencies in the larger overall enterprise architecture.

SSOT systems provide data that are authentic, relevant, and referable.

\subsection{C2.2 Keep it Simple Stupid}\label{KISS}
\subsection{C2.3 copy-and-swap idiom}\label{casi}
\subsection{C2.4 Named Constructor Idiom}\label{nci}
\subsection{C2.5 Construct On First Use Idiom}\label{cofui}
\subsection{C2.6 Nifty Counter Idiom}\label{ncii}
\subsection{C2.7 Named Parameter Idiom}\label{npi}

\section{Appendix D: relationships in C/C++ domain modeling class diagrams}
\subsection{Association}
In C/C++ domain modeling class diagrams, an association is a structural relationship that indicates that objects of one classifier, 
such as a class and interface, are connected and can navigate to objects of another classifier.

An association connects two classifiers: the supplier classifier and the consumer classifier. 
Associations can help you make design decisions about the structure of your data.
You can make decisions about not only the classes that are needed to contain the data, but also about which classes are needed to share the data with other classes.
An association supports data sharing between classes or, in the case of a self-association, between objects of the same class.

For example, a Customer class has a single association (1) to an Account class, indicating that each Account instance is owned by one Customer instance.
If you have an account, you can locate the owning customer of that account, and for a given customer, you can find the account of that customer.
The association between the Customer class and the Account class is important because it shows the structure between the two classifiers.

Multiplicity information can be linked to an association to show how many instances of class A are linked with instances of class B.
Multiplicity information can be linked to both ends of association relationships.

In class diagrams, association relationships in a C/C++ application represent the following things:

    A semantic relationship between two or more classes that specifies connections among their instances,
        A structural relationship that specifies that objects of one class are connected to objects of a second, possibly the same, class.

        In visualization mapping, instance variables in a C/C++ application become attributes in classifiers in class diagrams. By default, all C/C++ fields are shown as attributes.

        An association relationship connector appears as a solid line between two classifiers.

        The following illustration displays a source code example and a graphical representation of an Association Relationship.
\begin{figure}[h]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.41]{./dppic/asso.PNG}}{\caption{Association}\label{Associationcpp}}
\end{floatrow}
\end{figure}
\paragraph{more discuss}
Association is a relationship which describes the reasons for the relationship and the rules that govern the relationship. Its types as listed below,
  (1)  Unidirectional (2)  Bidirectional (3) Aggregation (4) Composition.
\begin{figure}[h]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/associationtypes.PNG}}{\caption{Association types}\label{Associationtypes}}
\end{floatrow}
\end{figure}

Let’s take an example of Teacher and Student.

\textbf{Unidirectional Association} is a specialized form of association where one object is associated with another object, but the reverse is not true. It is like one way communication.

Let’s take examples of multiple students can associate with a single teacher. 

\textbf{Bidirectional Association} is a type of association where one object is related with other objects and the reverse is also true. It is like two way communication.

Let’s take examples of multiple students can associate with a single teacher and a single student can associate with multiple teachers.

\textbf{Aggregation} is a specialized form of Association where all objects have their own life cycle but there is ownership and child object cannot belong to another parent object.

If object ``a'' related with object b and relationship rule stated that object ``a'' is taking a more important role in the relationship or it is the owner of the relationship, 
then the association is called as aggregation. Let’s take examples of:

(1)    Department and teacher. A single teacher cannot belong to multiple departments, but if we delete the department, teacher object will not destroy.
(2)A car object is an aggregation of engine, seat, wheels and other objects.
(3)Manager and worker. A manager has workers who work under him.

But if we fire the manager, still the workers are working in the organization, i.e. more happily. Let's keep this as homework. 

\textbf{Composition} is again a specialized form of Aggregation and we can call this as a “death” relationship. It is a strong type of Aggregation. 
A child object does not have its life cycle and if parent object deletes, all child objects will also be deleted.

Let’s take again an example of relationships.

(1)  Between House and rooms. House can contain multiple rooms. 
There is no independent life of room and any room cannot belong to two different houses if we delete the house room will automatically delete. 
Each class referenced is considered to be part-of the aggregate class. 
(2)Between questions and options. 
    Single questions can have multiple options and an option cannot belong to multiple questions. If we delete questions, options will automatically delete.
(3)Between class and student. 
    A class contains students and students cannot have multiple classes. A student cannot exist without a class. There exists composition between class and students.

\paragraph{more about misunderstanding}

\url{https://www.codeproject.com/Articles/880451/Really-Understanding-Association-Aggregation-and-C}
\paragraph{even more}

\url{https://bellekens.com/2010/12/20/uml-composition-vs-aggregation-vs-association/}

\paragraph{show me the code}
\textbf{Compositions}
\url{https://www.uml-diagrams.org/composition.html}
(1) typically use normal member variables (2) can use pointer values if the composition class automatically handles allocation/deallocation.
(3) responsible for creation/desctruction of subclasses (4) A has a B object as data member.
\begin{lstlisting}[caption={composition example}, language=C++]
class ArithMaticAndlLogicUnit 
{
    public:
        string printUnitName(){cout<<"ArithMaticAndlLogicUnit unit"<<endl;}
};
class ControlUnit 
{
    public:
        string printUnitName(){cout<<"control unit"<<endl;}
};

class MemoryUnit
{
    public:
        string printUnitName(){cout<<"memory unit"<<endl;}
};

class Processor{
    private:
        double clockSpeed;
        ArithMaticAndlLogicUnit *alu;
        ControlUnit *clu;
        MemoryUnit *mu;
    public:
        Processor(){ 
            clockSpeed = 2.5;
            alu = new ArithMaticAndlLogicUnit();
            clu = new ControlUnit();
            mu = new MemoryUnit();
            }
        ~Processor(){ 
            cout<<"destroying Processor"<<endl;
            delete alu;
            delete clu;
            delete mu;
        }
        Processor(double cs){ clockSpeed = cs;}
        double getClockSpeed() { return clockSpeed;}
        void setClockSpeed(double cs) {  clockSpeed = cs;}
        void printSec(){cout<<"ArithMaticAndlLogicUnit"<<endl;}
};
int main()
{
    Processor processor(3.6);
    processor.printSec();

    return 0;
}

\end{lstlisting}




\textbf{Aggregations} (1) Typicallly use pointer variables that point to an object that lives outside fo scope of the aggreate class
(2) can use reference values that pont to an object that lives outside of the scope of the aggregate class
(3) Not responsible for creating/destroying subclasses
(4) has a pointer to object and data of pointing object is deep cooped in that pointer.
\begin{lstlisting}[caption={Aggregation example}, language=C++]
class Processor{
    private:
        double clockSpeed;
    public:
        Processor(){ clockSpeed = 2.5;}
        Processor(double cs){ clockSpeed = cs;}
        double getClockSpeed() { return clockSpeed;}
        void setClockSpeed(double cs) {  clockSpeed = cs;}
};

class Computer {
    protected:
        Processor* processor;
        string operatingSystem;
    public:
        void SetOperatingSystem(string os) { this->operatingSystem = os;}
        string GetOperatingSystem( ) {return this->operatingSystem;}
        Computer(){}
        ~Computer(){delete this->processor;}
        Processor* getProcessor(){ return this->processor;}
        void setProcessor(Processor* ps){
            this->processor = new Processor();
        this->processor->setClockSpeed(ps->getClockSpeed());
        %this->processor->setClockSpeed(5.0);//try it out
        }

        void print(){cout<<"OS: "<<operatingSystem<<"CS: "<<processor->getClockSpeed(); }
};

int main()
{
    Processor processor(3.6);
    {
        Computer pc1;
        pc1.setProcessor(&processor);
        pc1.print();
    }
    cout<<"cs: "<<processor.getClockSpeed();
    return 0;
}
\end{lstlisting}



\textbf{Association}: A has a pointer to B object as a data member.

\begin{lstlisting}[caption={bidirectional association example}, language=Java]
class Processor{
    private:
        double clockSpeed;
    public:
        Processor(){ clockSpeed = 2.5;}
        Processor(double cs){ clockSpeed = cs;}
        double getClockSpeed() { return clockSpeed;}
        void setClockSpeed(double cs) {  clockSpeed = cs;}
};

class Computer {
    protected:
        Processor* processor;
        string operatingSystem;
    public:
        void SetOperatingSystem(string os) { this->operatingSystem = os;}
        string GetOperatingSystem( ) {return this->operatingSystem;}
        Computer(){}
        ~Computer(){}// different!!!!
        Processor* getProcessor(){ return this->processor;}
        void setProcessor(Processor* ps){
            this->processor = new Processor();
        this->processor->setClockSpeed(ps->getClockSpeed());
        %this->processor->setClockSpeed(5.0);//try it out
    }

        void print(){cout<<"OS: "<<operatingSystem<<"CS: "<<processor->getClockSpeed(); }
};

int main()
{
    Processor processor(3.6);
    {
        Computer pc1;
        pc1.setProcessor(&processor);
        pc1.print();
    }
    cout<<"cs: "<<processor.getClockSpeed();
    return 0;
}
\end{lstlisting}



\subsection{Dependency}

In Dependency relationships class diagrams, a dependency relationship indicates that a change to one class, the supplier, might cause a change in the other class, the consumer.
The supplier is independent because a change in the consumer does not affect the supplier.

For example, a Cart class depends on a Product class because the Product class is used as a parameter for an add operation in the Cart class.
In a class diagram, a dependency relationship points from the Cart class to the Product class. In other words, the Cart class is the consumer element,
and the Product class is the supplier element. A change to the Product class may cause a change to the Cart class.

In class diagrams, dependency relationships in a C/C++ application connect two classes to indicate that there is a connection between the two classes,
and that the connection is more temporary than an association relationship. A dependency relationship indicates that the consumer class does one of the following things:

    Temporarily uses a supplier class that has global scope,
    Temporarily uses a supplier class as a parameter for one of its operations,
    Temporarily uses a supplier class as a local variable for one of its operations,
    Sends a message to a supplier class.

As the figures in the following table illustrate, a dependency relationship connector appears as a dashed line with an open arrow that points from the consumer class to the supplier class.
A dependency relationship means an "import" statement.

\begin{figure}[h]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/dep.PNG}}{\caption{Dependency}\label{Dependency}}
\end{floatrow}
\end{figure}

\paragraph{dependency in UML}
In UML, dependency contains 4 different dependencies, which are ``usage'', ``abstraction'', ``Permission'' and ``binding''.see \url{http://blog.csdn.net/sky101010ws/article/details/6820422}
for details.

\subsection{Generalization}
In C/C++ domain modeling class diagrams, a generalization relationship, which is also called an inheritance or "an A is a B" (a human is a mammal, a mammal is an animal) relationship,
implies that a specialized, child class is based on a general, parent class.

As the figure in the following table illustrates, a generalization relationship connector appears as a solid line with an unfilled arrowhead pointing from the specialized,
child C/C++ class to the general, parent class. You can also visualize and design inheritance relationships between C/C++ classes.

\begin{figure}[h]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/gere.PNG}}{\caption{Generalization}\label{generalization}}
\end{floatrow}
\end{figure}

\subsection{Manifestation}
In domain modeling class diagrams of C/C++ elements, a manifestation relationship exists between a class and a class definition when the class definition is contained in a C/C++ header file.

In C/C++, class definitions outline the characteristics of the class design. 
The class definitions are stored in C/C++ header files which have a file name extension of *.h or *.hpp. A header file might contain more than one class definition.

As the figure in the following table illustrates, a manifestation relationship connector appears as a dashed line with an unfilled arrowhead.
The connector points from the header file, which is the class definition, to the class, which is the manifestation of the class.

\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/manife.PNG}}{\caption{Manifestation}\label{manifestation}}
\end{floatrow}
\end{figure}

\subsection{Abstract Generalizations}
In class diagrams, an abstract generalization is a dependency relationship in which a mapping exists between the parent and the child.

An abstract generalization is much like the generalization or inheritance relationship between classes.
With abstract generalization, a parent class forces the child class to inherit certain functionality to create an interface.

Note
In C/C++, an abstract generalization is achieved through pure virtual operations.
A parent class that contains a pure virtual operation is called an abstract base class.
The abstract base class can never be instantiated.
A child class must override the pure virtual operation in its declaration; otherwise, it cannot be instantiated.
The abstract base class forces a design interface on a child class.

For example, when you visualize a C/C++ class and abstract generalization, a parent class can become an interface or design template.
The Vehicle class is a parent class that uses an abstract generalization.
The Vehicle class becomes a design template or interface for all its children by forcing them to use certain operations.
The Child class Boat inherits several operations from the Vehicle class.
The Boat class cannot be implemented without using those operations. Therefore, the Vehicle class acts as a design interface for all its children.

In domain modeling class diagrams, an abstract generalization is shown by differentiating the title of the class from other classes.
A parent class that uses an abstract generalization has a class title in italic letters.
As well, all operations that are inherited by its children (pure virtual operations) also appear in italics.

The following figure illustrates the differences between a normal generalization relationship and an abstract generalization relationship.
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/abge.PNG}}{\caption{Abstract Generalizations}\label{abgeneralization}}
\end{floatrow}
\end{figure}

\subsection{Owned element association}
In C/C++ domain modeling class diagrams, an owned element association relationship is a type of association that dictates ownership.

The owned element association represents classes that are owned by another class.
This relationship is used to visualize nested classes in a class diagram where a class is declared within the scope of another, outer, class.
A nested class belongs to the namespace of the outer class and can only be used in the outer class.
That is, the parent class declares the inner, or nested, class. This construct is primarily used for implementation reasons.

A declaring class and a class in its namespace are connected by an anchor line which is referred to as owned association in the diagram,
with an anchor icon on the end connected to a declaring class. An anchor icon appears as a plus sign inside a circle.

For example, if Class B is attached to Class A by an anchor line with the anchor symbol on Class A, then Class B is declared within the Namespace of Class A.
That is, the relationship between Class A and Class B is the namespace-owned element association.

The following table illustrates the relationship of Owned element association.
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/oeass.PNG}}{\caption{Owned element association}\label{oeass}}
\end{floatrow}
\end{figure}


\subsection{Permission}
In C/C++ domain modeling class diagrams, a permission relationship is a relationship in which a class allows another class to have visibility to its encapsulated attributes or operations.

In C/C++, a special relationship allows one class to give permission to another class to access its private data area.
The class that has been given permission becomes a friend to the sharing class. A class that is a friend to another class has access to all the data and methods of the sharing class.

For example, a Customer class gives permission to an Account class so that the Account class can use personal information about the customer.
The Account class becomes a friend to the Customer class. This relationship makes it easier for the Account class to perform its tasks because it has access to the Customer class.
Note
Permission relationships in C/C++ circumvent data encapsulation and might break the intended design of a class or classes. Friends in C/C++ and should be used with caution.

As the figure in the following table illustrates, a permission relationship is shown by a dashed line connector between classes with an open arrowhead that points to the friend class,
or the class that has permission to access the private data and methods of the sharing class. 
\begin{figure}[H]
\begin{floatrow}
    \ffigbox{\includegraphics[scale = 0.45]{./dppic/perm.PNG}}{\caption{Permission}\label{permission}}
\end{floatrow}
\end{figure}


\section{Appendix D: basic but important Concepts of C++ }
\subsection{About constructor}
\subsection{About copy constructor}
The copy constructor lets you create a new object from an existing one by initialization. 

A copy constructor of a class A is a non-template constructor in which the first parameter is of type A\&, const A\&, volatile A\&, or const volatile A\&, 
and the rest of its parameters (if there are any) have default values.

If you do not declare a copy constructor for a class A, the compiler will implicitly declare one for you, which will be an inline public member.
The following example demonstrates implicitly defined and user-defined copy constructors:

\begin{lstlisting}
#include <iostream>
using namespace std;

struct A {
  int i;
  A() : i(10) { }
};

struct B {
  int j;
  B() : j(20) { cout << "Constructor B(), j = " << j << endl; }

  B(B& arg) : j(arg.j) { cout << "Copy constructor B(B&), j = " << j << endl; }

  B(const B&, int val = 30) : j(val) { cout << "Copy constructor B(const B&, int), j = " << j << endl; }
};

struct C {
  C() { }
  C(C&) { }
};

int main() {
  A a;// Constructor
  A a1(a);//implicitly call default copy Constructor
  B b;//Constructor
  const B b_const;//Constructor
  B b1(b);//copy Constructor
  B b2(b_const);//copy Constructor
  const C c_const;//copy Constructor
//  C c1(c_const);
}
\end{lstlisting}

The following is the output of the above example:

\begin{lstlisting}
Constructor B(), j = 20
Constructor B(), j = 20
Copy constructor B(B&), j = 20
Copy constructor B(const B&, int), j = 30
\end{lstlisting}

The statement A a1(a) creates a new object from a with an implicitly defined copy constructor.
The statement B b1(b) creates a new object from b with the user-defined copy constructor B::B(B\&). 
The statement B b2(b\_const) creates a new object with the copy constructor B::B(const B\&, int). 
The compiler would not allow the statement C c1(c\_const) because a copy constructor that takes as its first parameter an object of type const C\& has not been defined.

The implicitly declared copy constructor of a class A will have the form A::A(const A\&) if the following are true:

    The direct and virtual bases of A have copy constructors whose first parameters have been qualified with const or const volatile

    The nonstatic class type or array of class type data members of A have copy constructors whose first parameters have been qualified with const or const volatile

If the above are not true for a class A, the compiler will implicitly declare a copy constructor with the form A::A(A\&).

A program is ill-formed if it includes a class A whose copy constructor is implicitly defined (C++11) or explicitly defaulted (C++11) when one or more of the following conditions are true:

    Class A has a nonstatic data member of a type which has an inaccessible or ambiguous copy constructor.

    Class A is derived from a class which has an inaccessible or ambiguous copy constructor.

The compiler will implicitly define an implicitly declared (C++11) or explicitly defaulted (C++11) constructor of a class A if you initialize an object of type A or an object derived from class A.

An implicitly defined (C++11) or explicitly defaulted (C++11) copy constructor will copy the bases and members of an object in the same order that a constructor would 
initialize the bases and members of the object.
Note: C++11 You can declare copy constructors as explicitly defaulted functions or deleted functions.

\subsection{Explicitly defaulted functions (C++11)}
Explicitly defaulted function declaration is a new form of function declaration that is introduced into the C++11 standard. 
You can append the ``=default;'' specifier to the end of a function declaration to declare that function as an explicitly defaulted function. 
The compiler generates the default implementations for explicitly defaulted functions, which are more efficient than manually programmed function implementations.
A function that is explicitly defaulted must be a special member function and has no default arguments.
Explicitly defaulted functions can save your effort of defining those functions manually.
You can declare both inline and out-of-line explicitly defaulted functions. For example:

\begin{lstlisting}
class A{
public:  
   A() = default;         // Inline explicitly defaulted constructor definition
   A(const A&);
   ~A() = default;        // Inline explicitly defaulted destructor definition
};

A::A(const A&) = default; // Out-of-line explicitly defaulted constructor definition 
\end{lstlisting}

You can declare a function as an explicitly defaulted function only if the function is a special member function and has no default arguments. For example:

\begin{lstlisting}
class B {
public:
  int func() = default;  // Error, func is not a special member function.
  B(int, int) = default; // Error, constructor B(int, int) is not a special member function.
  B(int=0) = default;    // Error, constructor B(int=0) has a default argument. 
};
\end{lstlisting}

The explicitly defaulted function declarations enable more opportunities in optimization, because the compiler might treat explicitly defaulted functions as trivial.


\subsection{About copy assignment operator}
The copy assignment operator lets you create a new object from an existing one by initialization. 
A copy assignment operator of a class A is a nonstatic non-template member function that has one of the following forms:

\begin{lstlisting}
    A::operator=(A)
    A::operator=(A&)
    A::operator=(const A&)
    A::operator=(volatile A&)
    A::operator=(const volatile A&)
\end{lstlisting}

If you do not declare a copy assignment operator for a class A, the compiler will implicitly declare one for you that is inline public.
The following example demonstrates implicitly defined and user-defined copy assignment operators:

\begin{lstlisting}
#include <iostream>
using namespace std;

struct A {
  A& operator=(const A&) {
    cout << "A::operator=(const A&)" << endl;
    return *this;
  }

  A& operator=(A&) {
    cout << "A::operator=(A&)" << endl;
    return *this;
  }

};

class B {
  A a;
};

struct C {
  C& operator=(C&) {
    cout << "C::operator=(C&)" << endl;
    return *this;
  }
  C() { }
};

int main() {
  B x, y;
  x = y;

  A w, z;
  w = z;

  C i;
  const C j();
//  i = j;
}
\end{lstlisting}

See the output of the above example:

\begin{lstlisting}
A::operator=(const A&)
A::operator=(A&)
\end{lstlisting}

The assignment x = y calls the implicitly defined copy assignment operator of B, which calls the user-defined copy assignment operator A::operator=(const A\&).
The assignment w = z calls the user-defined operator A::operator=(A\&). The compiler will not allow the assignment i = j because an operator C::operator=(const C\&) has not been defined.

The implicitly declared copy assignment operator of a class A will have the form A\& A::operator=(const A\&) if the following statements are true:

    A direct or virtual base B of class A has a copy assignment operator whose parameter is of type const B\&, const volatile B\&, or B.
    A non-static class type data member of type X that belongs to class A has a copy constructor whose parameter is of type const X\&, const volatile X\&, or X.

If the above are not true for a class A, the compiler will implicitly declare a copy assignment operator with the form A\& A::operator=(A\&).

The implicitly declared copy assignment operator returns an lvalue reference to the operator's argument.

The copy assignment operator of a derived class hides the copy assignment operator of its base class.

The compiler cannot allow a program in which a copy assignment operator for a class A is implicitly defined (C++11)  explicitly defaulted (C++11) when one or more of the following conditions are true:

    Class A has a nonstatic data member of a const type or a reference type
    Class A has a nonstatic data member of a type which has an inaccessible copy assignment operator
    Class A is derived from a base class with an inaccessible copy assignment operator.

An implicitly defined copy assignment operator of a class A will first assign the direct base classes of A in the order that they appear in the definition of A. 
Next, the implicitly defined copy assignment operator will assign the nonstatic data members of A in the order of their declaration in the definition of A.
Note: C++11 You can declare copy assignment operators as explicitly defaulted functions or deleted functions. 
\subsection{private constructor - Uses of Classes with only Private and Protected Constructors}
Many inexperienced programmers view the keywords 'private' and 'protected' in C++ as access constraints on the member functions and data of an object belonging to a class.
However C++, via one of the applications of 'static', supports functions and data that are members of the class rather than any individual object. Access control is also useful in that context.

Constructors (and, to a lesser extent, destructors) though not declared static are much more class functions than object functions.
There primary job is to manage the creation (and destruction) of objects.

The access keywords are applicable to class members as well as to object members. As such 'private' (and its companion, 'protected') can be used to apply constraints on the use of class members.
The constraints that are applied to constructors can be classified as follows:

1) Limit availability of class object to a particular scope, either the class scope or another function or class scope granted access via 'friend'.

2) Prevent the declaration of global or auto variables of the class.

3) Inhibit copy construction of class objects.

4) Inhibit the creation of any objects of the class

5) Inhibit the use of the class as a base class

To some extent the familiarity of a programmer with each of these constraints on constructors is a measure of their familiarity with the potential of C++.

The novice finds any private constructor an eccentricity and is initially mystified by it. In fact many seem to assume that 'private' will not have an effect on a constructor.
Their compiler quickly corrects this mis-understanding.

Fairly early in the process of learning C++ a programmer will come across the third item above. 
Good texts and well thought out training courses include an item on inhibiting copy construction when the default copy constructor will not do what is wanted and 
the programmer is not yet ready to provide one themselves.

Actually this constraint on a copy constructor is pretty severe and greatly limits the ways in which objects of the class can be used.
It would be a rare program that could manage with a private copy constructor for a class with objects that include data items rather than only member functions.
The latter type of class probably shouldn't be instantiated: how would you distinguish one instantiation from another?

Though this inhibition of copy construction is probably the earliest example of a private constructor that a programmer will meet, it is also probably the least useful when used in isolation.
There would seem to be little more to be said about this type of private constructor.

I have not come across any useful instances of a fully defined private copy constructor in classes with one or more public constructors.
If you come across any such instances I would be delighted to add them to my menagerie of weird classes.

\subparagraph{Local and Nested classes}

Some authors make a great play of C++'s support of local and nested classes. This is really odd because such facilities have existed almost since the start of C++.
Indeed, as we shall see, the current specification of these in C++ actually applies constraints that the following method does not.

If you want to restrict a class by constraining access to it to a second class (nested class) or to a specific function (local class)
, most of the appropriate functionality can be provided by the following framework:

\begin{lstlisting}
class T {
    friend @@@@@ /* replace @@@@@ with the required class or function name */
    T(...){ }// constructor definition
    
    T(const T & t); // private copy constructor declared
    // the rest of the class declaration 
}
\end{lstlisting}

Note that this class cannot be used as a base class. ON the other hand if you change the access to the constructor to protected you have fatally damaged the constraint.

It is only fair to ask what extra facilities are provided by true local and nested classes. Basically two extras are provided by these.
First is the avoidance of namespace pollution.
Second you regain the ability to use 'private' to constrain access to class T members from the enclosing scope.
The first of these is quite important in large projects where the single global namespace is all too easily polluted. This will become less important when 'namespace' is introduced into C++.

I am not convinced that the second item (constraining access) offers any great advantage in the context of a local or nested class.
On the other hand the above technique allows a single specialist class to be a 'local' or 'nested' member of several functions and/or classes.

As there are some other constraints applied to local classes as currently provided in the standards Working Paper. 
These include prohibiting static members from local classes and requiring the entire definition to be within the class declaration.
In the case of nested classes there are restrictions on the type names available. 
In view of these constraints on the normal forms of local and nested classes the above method of providing restricted access to a class may remain as a viable technique even 
when all compilers support the normal forms.

One objection I have heard raised by traditionalists to both this instance and a number of the following is that it produces a tight binding between two separate program objects.
I think that this is symptomatic of an entirely false view of C++ and Abstract Data Types and objects.

Abstract Data Types are not effectively encapsulated in a single class. Generally an ADT is best represented by a tightly bound cluster of classes and global functions.
These form a de facto module which could be encapsulated in a pair of source code files; a header file providing the public interface and a file of code that implements the interface.
I would suggest that even here we may have to conceptually separate parts of the interface information that 
enables the system to link to the implementation from those parts that are intended for use by the rest of the program world.

In general it is not sensible to implement an ADT without the use of at least some friend functions.
Those familiar with methods for managing libraries designed to support more than one platform or machine architecture will know that 
two or more closely coupled classes are often the most effective way of providing a consistent interface with alternative (system dependant) implementations.

Those with even more experience may be familiar with techniques for supporting multiple interfaces to a single complex but well defined data structure.

The above few paragraphs have little to do with the direct subject of this paper (and have only been inserted in this derived version) but 
experience shows that it is an area where many programmers need to change their interface to C++.

\subparagraph{Nested Functions}

I hear programmers refer to nested function extensions provided by some compilers (I believe GNU G++ is one such) with either awe or horror.
Many seem to think that such an extension is dangerous and should not be encouraged.
I find this attitude strange because all the functionality of nested functions has been implicit in C++ since 'friend' was implemented.

Consider:
\begin{lstlisting}
class T {
  friend X();
  T();
  T(const T & t);
  static void fn(){cout<<"nested function"<<endl;}
};
\end{lstlisting}

This effectively provides T::fn() nested inside X().
Its nice to have nested functions provided explicitly but this should demonstrate that making it explicit is all that need be happening.
As we can nest functions when we want to, perhaps those involved with developing the standard should add a suitable standard syntax for nested functions immediately and thereby limit namespace pollution.

Note that one of the major purposes of nesting functions is to increase the binding between two functions while ensuring that the inner function cannot be used externally.
One problem is that of considering overload resolution. 
The method I have outlined ensures that such an issue does not arise as the encapsulating class name will specifically identify the scope where the function is located.
I leave it to the reader to explore the consequences of calling a member function that does not exist.
If you do not know the answer without investigation then you still have much work to do if you expect your programs to work the way you intend.

\subparagraph{Shared Data}

The first programming language I learnt was FORTRAN. It provided a facility by which data could be declared COMMON to a number of modules of a program.
In those days it was an important facility for allowing clear communication between overlays. 
Overlays were far more important in the early days where memory was measured in kilobytes and having more than 16K was a luxury.
None-the-less the idea of providing a common data block shared between specified parts of a program that had little other communication still has its uses.

The following idiom may be useful in such circumstances.

In the ancestral language, C, identifiers were either local to a block, local to a file or global. 
The arguments about global data will continue to rage but most programmers want easy methods for restricted sharing of data between functions.
The classic student avoidance of globals (put all your global variables in a struct in main and pass a pointer to it to all your functions) entirely misses the real danger lurking in global variables.

C++ provides a number of other ways of restricting access to data. One that deserves to be better known is exemplified by:
\begin{lstlisting}
class T {
  friend ... // list all functions sharing data
  T();
  T(const T &);  // prevent use of inheritance and composition
  static ...    // list of variables common to the functions 
}
\end{lstlisting}

This method has several advantages. 
For me, the friend list is one of them. 
It provides specific and necessary documentation of all the functions (and, possibly, classes) that have direct access to this data.

Another way of achieving this is to leave out the friend statements and put the function prototypes in the class as static member functions.
The disadvantage of this is that all uses of such functions have to be scoped to the class.
The method above only requires the data to be scoped within the friend functions and is transparent to the rest of your code.

\subparagraph{Preventing global and auto objects}

Programmers who have only worked with single tasking operating systems often look mystified when I talk about the need to prevent construction of global or auto objects.
Those with more experience and those who have considered the problems of writing for products such as MS Windows or X are aware of the problem but do not always know that a solution exists.

I first became conscious of the problem when my phone rang one day and I was asked "Is 'delete this' legal." I had never considered the problem before.
On checking I found that libraries accompanying both Borland C++ and Microsoft Visual C++ contained 'delete this'.

Clearly the statement is syntactically well formed so the question came down to whether there was any reason to specifically ban that construct.
Put it another way, could a ban be enforced and if it was, would that make a legitimate piece of source code illegal? The answers are 'no' and 'yes'.

'delete this' is sometimes referred to as the 'suicide statement' (I recently had a programmer talk about a Caligula function, one that destroyed its siblings, parents and children.
That is another issue and I wonder if there is any legitimate use for such a function.) because the object instigates its own destruction. 
'delete this' is a statement that should be used with great care because it has the potential for seriously damaging your product. 
Auto and global objects cannot commit suicide successfully because their 'ghosts' will hang around to haunt you.

Consider:
\begin{lstlisting}
class T {
    char * c; 
  public:
     T(char* x) : c(new char[strlen(x)+1]) {strcpy(c,x);}
    ~T(){delete[]  c;}
    void suicide() {delete this}
};

int main()
{
  T ex("disaster"); 
  ex.suicide(); 
  return 0;
}
\end{lstlisting}

Now the destructor for 'ex' is called twice, once via suicide() and once when 'ex' goes out of scope.
You will probably get away with it in such a simple case but you certainly will not in most situations where the statement is used to handle a real problem.

This failure to properly destroy the object with 'delete this' is a fundamental problem. It is impossible to stop the call of a destructor for a variable that is going out of scope.

What we can do is to prevent auto, static local or global objects capable of suicide from ever coming into existence.

The way to achieve this is to make all constructors for the class private. You must be careful to remember that there are two constructors provided by the compiler.
Both must be constrained by making them private or protected. The choice between these two is governed by whether you want your class to be available as a base class or not.
Make the constructors private and your class cannot be a base class because the derived class will not be able to construct the base object (unless you grant 
the derived class friend status but see later on for a development of this idea).

If you choose to make one of these classes available as a base class it is essential that the suicide position is fully documented.
If you do not, a client's derived class may destroy your protective mechanisms with the resulting risk of an auto, static local or global object suiciding.
This is because any public constructors for derived classes will have access to the protected constructors of the base class.
Auto, static local and global objects of the derived type can then be constructed.
Any call to the suicide function then has all the potential for a real disaster.
The 'delete this' in the original suicide function will refer to the base class object, not the derived object.

Leaving these problems aside, there are several mechanisms for using private constructors to create objects.
The fundamental principle is to use a pointer to handle an object that is created with new.
Do not be tempted to even consider references in this context, to do so will almost certainly undo all that you had achieved.

The naive programmer does something like this:
\begin{lstlisting}
class T {
  friend T* make_T();
  int i[20];
  T(){};
  T(const T & t) // inhibit copying
  ~T(){}; 
public: 
  // public interface
} 

T * make_T() { return new T();}
\end{lstlisting}

The problem with this is that we are (unnecessarily) trusting the programmer to capture the returned pointer.
We should ensure that there is a pointer by passing it as a parameter so make\_T() should be:

\begin{lstlisting}
boolean make_T(T * t){ 
  t=new T;
  if (t) return TRUE; 
  else return FALSE;
}
\end{lstlisting}

The reason that the destructor has been made private (protected) is that in the context of suicide classes it is almost always essential that 
the object IS destroyed by suicide and not by some other mechanism.

To make this clear consider the common use of suicide classes to handle window objects in an event driven environment such as MS Windows.

The problem is that there are two objects involved, the program object created as a member of an appropriate class and the Windows object.
When the time comes to destroy a window both objects must be destroyed by the same event.

If you first destroy the program object there is nothing left to send a message to Windows.
On the other hand if you first send a message to Windows there is the danger that the programmer forgets to destroy the program object.

The safe way to do this is to cause the same function to send a message to Windows and suicide. The Windows experts can probably elaborate with more sophisticated mechanisms via callback functions.
\subparagraph{Mustn't be a Base}

I am not at all certain that this mechanism has any real life practical uses and I am indebted to Rob Murray for drawing my attention to the idea. I would welcome examples of its practical use.

You design a class 'end\_of\_branch' that must not ever become a base class. 
How do you ensure that no programmer manages to use it as a base? 
The method is as follows (I have slightly amended Rob's solution so that it will actually work despite the potential for using pathological behaviour of copy constructors to self copy an object):

\begin{lstlisting}
class inhibit 
{
  friend class end_of_branch; 
// and any other similar classes that you wish to inhibit
  inhibit(){};
  inhibit( const inhibit & i){}; 
}; 

class end_of_branch : virtual inhibit 
{
  // the code for your class 
}
\end{lstlisting}

Now if you try to use end\_of\_branch as a base class for a derived class D, for example:

\begin{lstlisting}
class D : end_of_branch
{
};
\end{lstlisting}

Then the compiler will reject it because the rules for construction require the constructors for virtual bases to be called directly and not via the inheritance hierarchy.
Actually it is not quite true as the following shows:

\begin{lstlisting}
class DD : end_of_branch 
{
  end_of_branch();
  end_of_branch(const end_of_branch & e); 
  // remaining code
};
\begin{lstlisting}

By declaring the constructors but not defining them you prevent the compiler from detecting the problem and as long as you never call either constructor there will not be a link time error.
The result is that you can have a derived class but you cannot have derived objects. A number of items in this paper show that such a class can have its uses.

In his original presentation, Rob forgot the copy constructor with the result that a derived class could be sneaked past the compiler 
by declaring an ordinary constructor but not defining it and then using the copy constructor to construct objects.

This is all great fun and works on paper but before you actually inhibit a class by this mechanism go away and do some research on the cost of having a virtual base class.
The most obvious candidates for the method are what Bjarne Stroustrup calls concrete data types (things like complex, string etc.) which the programmer wants to make as like a built-in as possible.
With the current methods of supporting virtual base classes there is no way that a sane programmer would want to use this method to protect a concrete data type.

And the final problem is that there is nothing you can do against the determined programmer who insists on wanting to grab your class as a base class. Consider the following:

\begin{lstlisting}
class wrapper 
{
public: 
  end_of_branch e;
};
\end{lstlisting}

This  new class  has almost  exactly the functionality of end\_of\_branch without the inhibition. 
Using classes derived from wrapper will be a little more awkward and some of the overloading and hiding rules will be changed but that is about all.

If grey haired writers can come up with schemes like this what will the young whiz-kids produce? 
If you work for a company that does not use code inspections then I suggest that either they change their policy or you find another employer.
The job of trying to maintain code that is the result of the creative programming from an under-supervised programmer is a nightmare.
\subparagraph{Providing restricted mutual friendship}

This is not my idea but one that was passed on to me at Munich. 
The problem is basically to provide mutual access between a pair of functions in two different classes so that each function has access to the other one but no more.
All you can do by straightforward methods is to allow each function access to the whole of the other class. 
This is fine normally but if you want to ensure that the compiler will resist any access other than that specifically required how can you do it?

Try this:

\begin{lstlisting}
class X 
{
  friend LINK::xfn();
  fn();
  // rest of code 
};

class Y 
{
  friend LINK::yfn();
  fn(); 
  // rest of code
};

class LINK 
{
  static xfn(){X::fn();}
  static yfn(){Y::fn();} 
  friend X::fn(); 
  friend Y::fn(); 
};
\end{lstlisting}

Remember that friendship is not transitive so each of the two original functions can only get at the wrapped version of the other in LINK.
Of course if you are being that careful to allow the compiler to detect problems you do not want any LINK objects instantiated so you better inhibit construction as well.
\subparagraph{class-as-object}

Writing a class with both default constructors declared as private and not defined would seem to be about as useless a piece of source as you could imagine.
But we have already seen several uses of such classes. In those, however, the constraint was desirable, not necessary.
In this final example it is essential that the class cannot be instantiated.

Oddly, among all the types of class with private constructors this is the first type that I actually had a use for.

One of the principles of object-oriented programming is to create program objects to represent real world objects. The question arises as how to represent an essentially unique object?

I first came across this when I was sitting in on a test run of a course for C programmers converting to C++. 
One of the course exercises was to develop a Screen class. The specification was that the constructor should switch the VDU to graphics mode.

The destructor would revert the screen back to text mode.

The purpose of the exercise was to demonstrate that a class object did not need data members. 
A secondary purpose was that students would have to anticipate problems created by the instantiation of a second object before the destruction of the first. 
The course designer suggested that this should be done via a static data member that the constructor could inspect. 
If an object already existed the constructor would abort the program. Even with exception handling this approach seems flawed.

What is needed is an object to keep track of the current display mode. Even better it should maintain a record of prior states on a stack (or other appropriate data structure). 
The constructor/destructor approach does not meet the needs of the problem.

One solution would be to create a screen object at the start of the program and destruct it at the end. 
I am unhappy with this approach because, in the context, there is only one screen and it should not be possible to create more than one program object to interact with a unique real world object. 
I am also profoundly unhappy with simply generating an abort if an attempt is made to instantiate a second object. The constructor method does not leave much space for a graceful exit.

In the context of a course this kind of exercise is useful because it brings programmers face to face with some of the problems associated with constructors. 
At the time I felt that a better solution to representing unique objects must exist. I must admit that it was several months before I recognised a potential solution; treat the class-as-object.

Consider:

\begin{lstlisting}
class Screen 
{
  static stack_of_int s;
  Screen();
  Screen(const Screen & ss);
public:
  // static functions to handle desired functionality
}
\end{lstlisting}

As the constructor is private (and undefined) it is impossible to construct a Screen object. Therefore it may seem unnecessary to include a copy constructor but this is not the case. Bizarrely, C++ allows you to construct an object with a copy of itself. For example:

\begin{lstlisting}
Screen s(s);
\end{lstlisting}

Would create a Screen object, s, unless the copy constructor has been inhibited as well as the ordinary default constructor.
Alternatively you can declare a private destructor as all the compilers I have tried recognise this and prevent any objects being constructed. 
This would be sufficient to prevent compilation but it is a quality of implementation issue for the compiler to recognise the problem at construction time. 
Anyway take your choice but watch out for that unexpected use of a copy constructor.

The key idea that has to be coupled with private constructors when implementing a class-as-object is the use of static to make all members class-members rather than object-members.

We can now add whatever other facilities and functionality that we want for our Screen object in the secure knowledge that there is a single program class-as-object connected to our single real world screen.

This idea is fine as far as it goes but how do we handle objects that are not unique but must be uniquely addressed. 
A good example in the PC world is that of managing interfacing to serial ports. 
A design that allowed two objects to try to use a serial port simultaneously is almost certainly faulty.
But to try to use object-oriented methods and not provide an object to manage a serial port seems perverse.

There are certainly a number of alternative approaches including having a unique monolithic serial port class. 
Another approach is to have the serial port class maintain a static list of ports that are currently assigned.

The problem with the latter approach is that it suffers from similar problems to the putative Screen class, what does the constructor do when it finds that the required port is already in use?

I think this is the wrong direction. Though there are often several serial ports each one should be uniquely addressable and therefore have a single program object associated with it.
Once I phrased the problem in these terms and started thinking of implementing an individual class-as-object for each port an answer surfaced, templates. 
Consider:

\begin{lstlisting}
template <int port> class SerialPort
{
  SerialPort();
  // static member data to handle a port 
public:
  // static member functions to handle a port 
}
\begin{lstlisting}

Now it is impossible to have more than one handler per serial port (well as long as you don't provide a handler via an alternative method). There are no constructors to fail but we do still have some things to consider.

We cannot pass a class-as-object to a function. We cannot have arrays of them and all such items must be specifically identified at compile time. For example if we want a program to initialise all existing serial ports and create a list of those available we cannot write code such as:

\begin{lstlisting}
for (int i=1;i<5;i++) SerialPort<i>::init();
\end{lstlisting}

Instead I must unroll such a loop. As there will only be a limited number of serial ports I can live with that solution.

In fact every time we need to make run-time decisions about which serial port to use we will have to provide switch statements or something similar. 
In this case the problems caused by using a class-as-object may be acceptable but it would be nice to have some other method.

If you elect to implement serial port handling this way it is probably a good idea to include all the functionality in a single normal but data free class (with object instatiation inhibited) and use the template class as a wrapper so that code duplication is minimised.

I think that the use of a class-as-object idiom is only appropriate to handling real-world objects that you expect to be globally available to your program.
In such circumstances we can live with the handicaps introduced because we cannot use pointers, references, nor directly select an object at run­time.
\subparagraph{Conclusion}

I hope you have enjoyed this ramble through some of the odd uses of classes with only private copy constructors. 
Please do not stop here, instead get out your favourite compiler and text editor and explore a bit further.
When you have done so report back via these pages. 
The principle object of papers such as this one is to set programmers thinking and to dig out some of the more obscure idioms that some are already using.

I hope that your editor will be swamped with responses and will find space to publish them. 
I give him my full consent to include the vitriol from those that consider such procedures as the above have no place in a well ordered programming environment.

Finally, as the Harpist would assure you, there are bound to be errors in the above to catch the too casual reader.
\subsection{ Local classes (C++ only)}

A local class is declared within a function definition. 
Declarations in a local class can only use type names, enumerations, static variables from the enclosing scope, as well as external variables and functions.

For example:
\begin{lstlisting}
int x;                         // global variable
void f()                       // function definition
{
      static int y;            // static variable y can be used by local class
      int x;                   // auto variable x canNOT be used by  local class
      extern int g();          // extern function g can be used by  local class

      class local              // local class
      {
            int g() { return x; }      // error, local variable x  canNOT be used by g
            int h() { return y; }      // valid,static variable y
            int k() { return ::x; }    // valid, global x
            int l() { return g(); }    // valid, extern function g
      };
}

int main()
{
      local* z;                // error: the class local is not visible
      // ...
}
\end{lstlisting}
Member functions of a local class have to be defined within their class definition, if they are defined at all. 
As a result, member functions of a local class are inline functions. Like all member functions, those defined within the scope of a local class do not need the keyword inline.

A local class cannot have static data members. In the following example, an attempt to define a static member of a local class causes an error:

\begin{lstlisting}
void f()
{
    class local
    {
       int f();              // error, local class has noninline  member function
       int g() {return 0;}   // valid, inline member function
       static int a;         // error, static is not allowed for  local class
       int b;                // valid, nonstatic variable
    };
}
\end{lstlisting}
An enclosing function has no special access to members of the local class.

\subsection{This pointer}

\subsection{static class member function}
static member function cannot be declared with the keywords virtual, const, volatile, or const volatile.

A static member function can access only the names of static members, enumerators, and nested types of the class in which it is declared. 
Suppose a static member function f() is a member of class X. 
The static member function f() cannot access the nonstatic members X or the nonstatic members of a base class of X.

static member functions do not have this pointer.
\section{Appendix E: basic but important Concepts in C }
\subsection{callback}
\chapter{Callback in C using Function Pointer}

In C, callback is implemented using Function Pointer. Function Pointer - as the name suggests, is a pointer to a function.

For example, int (*ptrFunc) ();

Here, ptrFunc is a pointer to a function that takes no arguments and returns an integer. 
DO NOT forget to put in the parenthesis, otherwise the compiler will assume that ptrFunc is a normal function name, which takes nothing and returns a pointer to an integer.

Here is some code to demonstrate the function pointer.
\begin{lstlisting}
int func(int, int);

int main(void)
{

    int result1,result2;

    /* declaring a pointer to a function which takes two int arguments and returns an integer as result */
    int (*ptrFunc)(int,int);

    /* assigning ptrFunc to func's address */                        
    ptrFunc=func;

    /* calling func() through explicit dereference */
    result1 = (*ptrFunc)(10,20);

    /* calling func() through implicit dereference */            
    result2 = ptrFunc(10,20);                  

    printf("result1 = %d result2 = %d\n",result1,result2);

    return 0;
}

int func(int x, int y)
{
    return x+y;
}
\end{lstlisting}

Now let us try to understand the concept of Callback in  C using function pointer.

The complete program has three files: callback.c, reg\_callback.h and  reg\_callback.c.
\begin{lstlisting}[caption={reg\_callback.h}, language=C]
typedef void (*callback)(void);
void register_callback(callback ptr_reg_callback);
\end{lstlisting}

\begin{lstlisting}[caption={reg\_callback.c}, language=C]
#include"reg_callback.h"

void register_callback(callback ptr_reg_callback)
{
    printf("inside register_callback\n");

    /* calling our callback function my_callback */

    (*ptr_reg_callback)();                                      
}
\end{lstlisting}
\begin{lstlisting}[caption={callback.c}, language=C]
#include"reg_callback.h"

/* callback function definition goes here */

void my_callback(void)
{
    printf("inside my_callback\n");
}

int main(void)
{
    /* initialize function pointer to my_callback */

    callback ptr_my_callback=my_callback;                              

    printf("This is a program demonstrating function callback\n");

    /* register our callback function */

    register_callback(ptr_my_callback);                                

    printf("back inside main program\n");

    return 0;
}
\end{lstlisting}


If we run this program, the output will be
\begin{Verbatim}
This is a program demonstrating function callback

inside register_callback

inside my_callback

back inside main program
\end{Verbatim}
The higher layer function calls a lower layer function as a normal call and the callback mechanism allows the lower layer function to call the higher layer function 
through a pointer to a callback function.
\paragraph{exmaple 2}
\begin{lstlisting}[caption={server}, language=C]
typedef void (*event_cb_t)(const struct event *evt, void *userdata);// define the type of function used for the callback


int event_cb_register(event_cb_t cb, void *userdata);// define a function that is used to register a callback:
\end{lstlisting}

\begin{lstlisting}[caption={user to register a callback}, language=C]
static void my_event_cb(const struct event *evt, void *data)
{
    /* do stuff and things with the event */
}

   event_cb_register(my_event_cb, &my_custom_data);
\end{lstlisting}


\begin{lstlisting}[caption={internal of the event dispatcher}, language=C]
struct event_cb {
    event_cb_t cb;
    void *data;
};
\end{lstlisting}

\begin{lstlisting}[caption={execute a callback}, language=C]
truct event_cb *callback;

...

/* Get the event_cb that you want to execute */

callback->cb(event, callback->data);
\end{lstlisting}



\chapter{synchronous callback and asynchronous callback} 
A synchronous callback is provided to another function which is going to do some task and then return to the caller with the task completed. 
An asynchronous callback is provided to another function which is going to start a task and then return to the caller with the task possibly not completed.

A synchronous callback is typically used to provide a delegate to another function to which the other function delegates some step of the task. 
Classic examples of this delegation are the functions bsearch() and qsort() from the C Standard Library. 
Both of these functions take a callback which is used during the task the function is providing so that the type of the data being searched, 
in the case of bsearch(), or sorted, in the case of qsort(), does not need to be known by the function being used.

An asynchronous callback is different in that when the called function to which we provide a callback returns, the task may not be completed. 
This type of callback is often used with asynchronous I/O in which an I/O operation is started and then when it is completed, the callback is invoked.
\end{document}
